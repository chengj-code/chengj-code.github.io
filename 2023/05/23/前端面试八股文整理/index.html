<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>前端面试八股文整理</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="HTML+CSSHTML语义化HTML语义化就是指在使用HTML标签构建页面时，避免大篇幅的使用无语义的标签，比如div、span，要求尽可能的使用具有语义的标签，比如&lt;h1&gt;~&lt;h5&gt;、&lt;header&gt;、&lt;aside&gt;、&lt;footer&gt;等。 使用HTML语义化标签的作用:  易于用户阅读，样式文件未加载时，页面结构清晰。 有利于SEO，">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试八股文整理">
<meta property="og:url" content="http://example.com/2023/05/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="HTML+CSSHTML语义化HTML语义化就是指在使用HTML标签构建页面时，避免大篇幅的使用无语义的标签，比如div、span，要求尽可能的使用具有语义的标签，比如&lt;h1&gt;~&lt;h5&gt;、&lt;header&gt;、&lt;aside&gt;、&lt;footer&gt;等。 使用HTML语义化标签的作用:  易于用户阅读，样式文件未加载时，页面结构清晰。 有利于SEO，">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2023-05-23T12:55:00.000Z">
<meta property="article:modified_time" content="2023-09-14T14:29:35.670Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/05/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: John Doe","link":"Link: ","source":"Source: Hexo","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端面试八股文整理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-14 22:29:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chenxz21/bcxm" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/shuoba"><i class="fa-fw fas fa-comment-dots"></i><span> 说吧</span></a></div><div class="menus_item"><a class="site-page" href="/gedan"><i class="fa-fw fas fa-music"></i><span> 歌单</span></a></div><div class="menus_item"><a class="site-page" href="/game"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk"><i class="fa-fw fa fa-heartbeat"></i><span> 时光</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tools"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/google"><span> 镜像</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://json.xbyzs.cf"><span> Json格式化</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://draw.xbyzs.cf"><span> Draw画布</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://enkey.xbyzs.cf"><span> EnKey</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/shuoba"><i class="fa-fw fas fa-comment-dots"></i><span> 说吧</span></a></div><div class="menus_item"><a class="site-page" href="/gedan"><i class="fa-fw fas fa-music"></i><span> 歌单</span></a></div><div class="menus_item"><a class="site-page" href="/game"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk"><i class="fa-fw fa fa-heartbeat"></i><span> 时光</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tools"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/google"><span> 镜像</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://json.xbyzs.cf"><span> Json格式化</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://draw.xbyzs.cf"><span> Draw画布</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://enkey.xbyzs.cf"><span> EnKey</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">前端面试八股文整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">Created</span><time datetime="2023-05-23T12:55:00.000Z" title="Created 2023-05-23 20:55:00">2023-05-23</time></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><h1 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML+CSS"></a>HTML+CSS</h1><h2 id="HTML语义化"><a href="#HTML语义化" class="headerlink" title="HTML语义化"></a>HTML语义化</h2><p>HTML语义化就是指在使用HTML标签构建页面时，避免大篇幅的使用无语义的标签，比如div、span，要求尽可能的使用具有语义的标签，比如<code>&lt;h1&gt;~&lt;h5&gt;、&lt;header&gt;、&lt;aside&gt;、&lt;footer&gt;</code>等。</p>
<p>使用HTML语义化标签的作用:</p>
<ol>
<li>易于用户阅读，样式文件未加载时，页面结构清晰。</li>
<li>有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。</li>
<li>方便屏幕阅读器解析，如盲人阅读器根据语义渲染网页。</li>
<li>代码更具可读性，更好维护</li>
</ol>
<p>HTML5新增的语义化标签主要有：<code>&lt;article&gt;、&lt;section&gt;、&lt;nav&gt;、&lt;aside&gt;、&lt;header&gt;、&lt;footer&gt;、&lt;time&gt;、mark、figure、caption、context、menu、audio，video，embed</code></p>
<h2 id="CSS样式优先级"><a href="#CSS样式优先级" class="headerlink" title="CSS样式优先级"></a>CSS样式优先级</h2><p>第一类：!important ∞</p>
<p>第二类：行内样式 1000</p>
<p>第三类：id选择器(100)&gt;(类选择器|伪类选择器|属性选择器)(10)&gt; (标签选择器、伪元素选择器(1) &gt;通配符选择器(0)。</p>
<p>第四类：继承样式，是所有样式中优先级比较低的。</p>
<p><strong>伪类选择器</strong>：<code>:first-child、:last-child、:nth-child(n)、:first-of-type、:last-of-type、:nth-of-type(n)</code></p>
<p><code>.demo li:nth-child(n)</code>：在父元素下找到第n个元素</p>
<p><code>.demo span:nth-of-type(n)</code>：在父元素下找到type为li的第n个元素</p>
<p><strong>属性选择器</strong>：</p>
<ul>
<li>**div[title]{}**：选择含有指定属性title的div元素</li>
<li>**div[title&#x3D;ab]{}**：选择含有指定属性title并且属性值为ab的div元素</li>
<li>**div[title^&#x3D;ab]{}**：选择含有指定属性title并且属性值以ab开头的div元素</li>
<li>**div[title$&#x3D;ab]{}**：选择含有指定属性title并且属性值以ab结尾的div元素</li>
<li>*<em>div[title</em>&#x3D;ab]{}**：选择含有指定属性title并且属性值包含ab的div元素</li>
</ul>
<p><strong>伪元素选择器</strong>：新创建的这个元素在文档树中是找不到的，所以称为伪元素，必须写<strong>content</strong>属性</p>
<ul>
<li><strong>::before</strong>：在元素前面插入内容</li>
<li><strong>::after</strong>：在元素后面插入内容</li>
</ul>
<h3 id="可以被继承的css属性"><a href="#可以被继承的css属性" class="headerlink" title="可以被继承的css属性"></a>可以被继承的css属性</h3><ol>
<li><strong>字体系列属性</strong>：font、font-family、font-weight、font-size、fontstyle;</li>
<li><strong>文本系列属性</strong>：<ol>
<li><strong>内联元素</strong>：color、line-height、word-spacing（设置单词之间的间距）、letter-spacing（设置文本字符间距）、 text-transform(用于设置文本的大小写：uppercase所有字符强制转为大写，lowercase转小写，capitalize首字符强制转为大写);</li>
<li><strong>块级元素</strong>：text-indent、text-align;</li>
</ol>
</li>
<li><strong>元素可见性</strong>：visibility </li>
<li><strong>表格布局属性</strong>：caption-side（标题位置）、border-collapse（设置边框分离还是合并）、border-spacing（边框分离状态下设置边框间距）、empty-cells（定义如何渲染无可视内容的单元格边框和背景）、table-layout（定义用于布局单元格行和列的算法）;</li>
<li><strong>列表布局属性</strong>：list-style</li>
</ol>
<h3 id="不可以被继承的css属性"><a href="#不可以被继承的css属性" class="headerlink" title="不可以被继承的css属性"></a>不可以被继承的css属性</h3><ol>
<li><strong>display</strong>：规定元素应该生成的框的类型；</li>
<li><strong>文本属性</strong>：vertical-align、text-decoration(用于设置文本的修饰线外观包括上&#x2F;下划线，管穿线，删除线，闪烁 ); </li>
<li><strong>盒子模型的属性</strong>：width、height、margin、border、padding; </li>
<li><strong>背景属性</strong>：background、background-color、background-image; </li>
<li><strong>定位属性</strong>：float、clear、position、top、right、bottom、left、min-width、min-height、maxwidth、max-height、overflow、clip;</li>
</ol>
<h2 id="CSS尺寸设置的单位"><a href="#CSS尺寸设置的单位" class="headerlink" title="CSS尺寸设置的单位"></a>CSS尺寸设置的单位</h2><p><strong>px</strong>: pixel像素的缩写，绝对长度单位，它的大小取决于屏幕的分辨率，是开发网页中常常使用的单位。</p>
<p><strong>em</strong>:相对长度单位，在font-size 中使用是相对于父元素的字体大小。</p>
<p><strong>rem</strong>:相对长度单位，相对于根元素的字体大小，根元素字体大小未设置，使用浏览器默认字体大小。</p>
<p><strong>vw</strong>:相对长度单位，相对于视窗宽度的1%。</p>
<p><strong>vh</strong>:相对长度单位，相对于视窗高度的1%。</p>
<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p><strong>BFC</strong>(Block Formatting Context)块级格式化上下文，是Web页面一块独立的渲染区域，内部元素的渲染不会影响边界以外的元素。</p>
<p>BFC布局规则:内部盒子会在垂直方向，一个接一个地放置。</p>
<p>BFC形成的条件：</p>
<ul>
<li>float设置成left 或right</li>
<li>position设置成absolute或fixed</li>
<li>overflow设置成auto、scroll、hidden</li>
<li>display设置成flex或inline-block等</li>
</ul>
<p>BFC能解决的问题:</p>
<ul>
<li>BFC盒子默认会包裹内部子元素——清除浮动</li>
<li>BFC盒子与子盒子不存在margin塌陷问题—–解决margin塌陷问题</li>
</ul>
<h2 id="高度塌陷和外边距塌陷"><a href="#高度塌陷和外边距塌陷" class="headerlink" title="高度塌陷和外边距塌陷"></a>高度塌陷和外边距塌陷</h2><h3 id="高度塌陷"><a href="#高度塌陷" class="headerlink" title="高度塌陷"></a>高度塌陷</h3><p>出现原因：父元素没有设置高度，依靠子元素撑开，子元素设置浮动后会脱离标准流，造成父元素高度为0产生塌陷。</p>
<p>解决方法：</p>
<ul>
<li>给父元素设置高度</li>
<li>设置父元素display: flex</li>
<li>设置父元素overflow: hidden</li>
</ul>
<h3 id="外边距塌陷"><a href="#外边距塌陷" class="headerlink" title="外边距塌陷"></a>外边距塌陷</h3><p>外边距塌陷：垂直方向上的两个块级元素外边距出现了合并的现象，距离为较大外边距。(水平方向上的元素没有外边距塌陷现象)</p>
<p>解决方法 ：</p>
<ul>
<li>相邻块元素<ul>
<li>不用margin，用padding</li>
<li>中间加个空标签隔开，高度为两者margin之和</li>
<li>只有一个元素设置margin</li>
<li>改变元素的显示方式，将其中一个块元素设置为行内块元素</li>
</ul>
</li>
<li>嵌套块元素<ul>
<li>改变元素的显示方式，将其中一个块元素设置为行内块元素</li>
<li>更改元素的文档流，给其中一个元素设置浮动</li>
<li>给父元素设置overflow: hidden</li>
<li>给父元素设置上边框</li>
</ul>
</li>
</ul>
<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><p><strong>浮动作用</strong>：设置浮动的图片，可以实现文字环绕图片，设置了浮动的块级元素可以排列在同一行，设置了浮动的行内元素可以设置宽高，同时可以按照浮动设置的方向对齐排列盒子。 </p>
<p><strong>设置浮动</strong>：css属性float：left&#x2F;right&#x2F;none 左浮动&#x2F;右浮动&#x2F;不浮动（默认）</p>
<p><strong>浮动元素特点</strong>：元素脱标，元素不占位置</p>
<p>浮动可以进行模式转换(行内块元素) </p>
<p>浮动造成的影响：</p>
<p>盒子脱离文档流。如果父级盒子没有设置高度，需要被子盒子撑开，子盒子设置浮动后父级盒子的高度就塌陷了，同时也会造成父级盒子后面的兄弟盒子布局受到影响。如果浮动元素后面还有其他兄弟元素，其他兄弟元素的布局也会受到影响。 </p>
<p><strong>清除浮动</strong>：</p>
<ol>
<li>父级div定义overflow: hidden</li>
<li>额外标签法：在父元素最后一个浮动子元素后面添加一个空标签div设置样式clear: both</li>
<li>父元素添加after伪元素</li>
<li>给父元素添加before和after双伪元素</li>
</ol>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>相对定位和粘性定位没有脱离文档流</p>
<p>绝对定位，固定定位都是脱离文档流的</p>
<h2 id="自适应布局的实现方案"><a href="#自适应布局的实现方案" class="headerlink" title="自适应布局的实现方案"></a>自适应布局的实现方案</h2><h3 id="左列固定右列自适应："><a href="#左列固定右列自适应：" class="headerlink" title="左列固定右列自适应："></a>左列固定右列自适应：</h3><p>(1) 左侧float: left右侧margin-left 左侧设置固定width，</p>
<p>(2) 左侧float: left右侧float: right左侧设置固定width，右侧width: calc(100%-左侧width)</p>
<p>(3) 左侧右侧都设置float: left; 左侧设置固定width，右侧width: calc(100%-左侧width)</p>
<p>(4) 子绝父相，左侧left:0，右侧right:0; 左侧设置固定width，右侧width: calc(100%-左侧width)</p>
<p>(5) 父元素盒子设置display: flex；左侧设置固定width，右侧设置flex: 1</p>
<h3 id="左右宽度固定，中间宽度自适应"><a href="#左右宽度固定，中间宽度自适应" class="headerlink" title="左右宽度固定，中间宽度自适应"></a>左右宽度固定，中间宽度自适应</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>center<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>// 左中右都设置float: left; 左右两侧设置固定width，中间width: calc(100%-左侧width-右侧width)<br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.center</span>,<span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.left</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.center</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">100%</span>-<span class="hljs-number">200px</span>-<span class="hljs-number">200px</span>);</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>// 父盒子设置display: flex；左右侧设置固定width，中间设置flex: 1<br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.container</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.left</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.center</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>// 左右中三列设置position: absolute; 左列设置left:0; 右列设置right:0; 左右设置固定宽度，中间设置left：左列width；right：右列width；<br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.container</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.left</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;        </span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.center</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">right</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>



<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>center<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>// 左侧设置float: left; 右侧设置float: right; 左右宽度固定，中间设置左右外边距，距离为左右宽度<br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.left</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">float</span>: right;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.center</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>// 左右中三列设置position: absolute; 左列设置left:0; 右列设置right:0; 左右设置固定宽度，中间设置left：左列width；right：右列width；<br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.container</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.left</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;        </span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.center</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">right</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-class">.center</span>,<span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.center</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-comment">/* 通过margin+相对定位设置位置 */</span></span><br><span class="language-css">      <span class="hljs-selector-class">.left</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="language-css">        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">        <span class="hljs-attribute">left</span>: -<span class="hljs-number">300px</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: grey;</span><br><span class="language-css">        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">300px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-comment">/* 两边留白 */</span></span><br><span class="language-css">      <span class="hljs-selector-class">.container</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">padding-left</span>:<span class="hljs-number">300px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">padding-right</span>:<span class="hljs-number">300px</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>中间<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左边<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右边<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="盒子水平垂直居中"><a href="#盒子水平垂直居中" class="headerlink" title="盒子水平垂直居中"></a>盒子水平垂直居中</h2><p>方法一：利用定位</p>
<p>父盒子使用相对定位relative,子盒子使用绝对定位absolute, 子盒子设置top:50%; left:50%，</p>
<p>(1)当子盒子width, height已知时，设置margin-top: -height&#x2F;2; margin-left: -width&#x2F;2;</p>
<p>(2)当子盒子width, height未知时，设置transform: translate(-50%, -50%)</p>
<p>方法二：flex布局</p>
<p>父盒子设置display: flex; justify-content: center(设置主轴(默认<em>x</em>轴)元素居中); align-items: center(设置侧轴(<em>y</em>轴)元素居中)。</p>
<p>方法三：margin: auto</p>
<p>父盒子使用相对定位relative,子盒子使用绝对定位absolute, 子盒子设置margin: auto; top: 0; left: 0; right: 0; bottom: 0。</p>
<p>方法四：display: table-cell</p>
<p>父盒子设置display: table-cell; vertical-align: middle; text-align: center;</p>
<h2 id="移动端布局"><a href="#移动端布局" class="headerlink" title="移动端布局"></a>移动端布局</h2><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><p>是指利用媒体查询(media query)，@media查询针对不同的媒体类型定义不同的样式，从而实现响应式布局。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css">// <span class="hljs-keyword">@media</span> 后面跟媒体类型 <br>// <span class="hljs-keyword">and</span> () 条件查询的拼接<br>@media screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">500px</span>)&#123;<br>    <span class="hljs-selector-class">.container</span>&#123;<br>        <span class="hljs-attribute">display</span>: flex;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">500px</span>) <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">1000px</span>)&#123;<br>    <span class="hljs-selector-class">.container</span>&#123;<br>        <span class="hljs-attribute">display</span>: inline-block;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="流式布局（百分比布局）"><a href="#流式布局（百分比布局）" class="headerlink" title="流式布局（百分比布局）"></a>流式布局（百分比布局）</h3><p>流式布局是宽度使用百分比(宽度自适应)代替固定宽度px，高度大多使用px来固定，因此在大屏幕手机下显示的效果会变成页面元素的宽度被拉长，高度和原来保持一致。</p>
<p>优点：可以解决自适应的问题</p>
<p>缺点：</p>
<ul>
<li>实际显示的效果不友好,屏幕越大，宽度被拉的很长，容易变形</li>
<li>大量使用百分比布局，会出现兼容性问题</li>
</ul>
<h3 id="rem布局"><a href="#rem布局" class="headerlink" title="rem布局"></a>rem布局</h3><p>rem是指相对于根元素的字体大小的单位，即根据html元素的font-size来计算大小。</p>
<p>rem原理：在布局过程中使用rem设置元素的尺寸，改变html的字体大小，页面上的元素将等比例缩放实现适配。</p>
<p>比如说html的font-size大小为100px, div的width为1rem，则div的width大小为100px</p>
<p>rem实现布局：</p>
<p>1.先设置视口meta viewport理想视口</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=2.0, maximum-scale=2.00, minimum-scale=2.00, user-scalable=no&quot;</span></span><br></code></pre></td></tr></table></figure>

<p> 2.写媒体查询(根据不同设备宽度修改样式)或原生JS适配文件</p>
<p>750px—100px；320px—?px</p>
<p>当前屏幕的html字体大小&#x3D;当前屏幕宽度×预设字体大小&#x2F;psd设计稿宽度;</p>
<p>3.在设计稿测量px转换为rem (px&#x2F;100)写rem单位</p>
<p>优点：</p>
<ul>
<li>有利于手机端各种机型的适配</li>
<li>减少代码的重复性</li>
</ul>
<p>缺点：必须通过js来动态控制根元素的大小(VSCode装一个插件: px to rem)</p>
<h3 id="vw-vh布局"><a href="#vw-vh布局" class="headerlink" title="vw&#x2F;vh布局"></a>vw&#x2F;vh布局</h3><p>使用纯css实现动态改变font-size属性值，不需要引用js文件</p>
<p>vw：viewport’s width 是css3规范中视口宽度单位，将视口宽度平均分成100份</p>
<p>vh：viewport’s height 将视口高度平均分成100份</p>
<p>原理：确定基准值以常见的750像素宽度的设计稿为例，根据vw单位的原理100vw &#x3D; 750px,即1vw &#x3D; 7.5px，根据设计稿中的px值，转换成对应的vw值进行布局，也可以直接写px</p>
<p>100vw &#x3D; 750px 1vw &#x3D; 7.5px;</p>
<p>100vw &#x3D; 375px 1vw &#x3D; 3.75px</p>
<p>1px &#x3D;0.1333333333333333vw</p>
<p>优点：页面元素随着页面宽度变化</p>
<p>缺点：</p>
<ul>
<li>兼容性没有rem好 ,得大量计算，不是很精确</li>
<li>转换后的长度单位不够直观修改维护困难(VS Code装一个插件: px to vw)</li>
</ul>
<p>(5) vw + rem布局</p>
<p>确定基准值以常见的750px设计稿为例（宽度），根据vw单位和rem单位原理实现</p>
<p>在750px设计搞下，如果使用vw单位换算，可以理解成100vw &#x3D; 750px，1px &#x3D; 0.13333333vw；如果使用rem单位换算，预设1rem &#x3D; 100px; 则100px &#x3D; 13.333333vw html{ font-size: 13.333333vw; }</p>
<p>弊端：不是很精确</p>
<p>750px  100vw  1vw &#x3D; 7.5px;</p>
<p>375px  100vw  1vw &#x3D; 3.75px</p>
<p>以设计稿为准:</p>
<p>假设还是750px设计稿 750px&#x3D;100vw 1px&#x3D;0.1333vw;  </p>
<p>预设字体基础值 100px 1rem &#x3D; 100px&#x3D; 13.33vw;</p>
<h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p>定义：Flex是Flexible Box的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性。</p>
<p>原理：通过给父元素添加display: flex;属性来控制子元素的位置和排列方式。</p>
<p>父元素属性：</p>
<p>(1)flex-direction：设置主轴的方向。它可能有4个值：</p>
<p>row: （默认值）主轴为水平方向，起点在左端，从左至右排列；</p>
<p>row-reverse：主轴为水平方向，起点在右端，从右至左排列；</p>
<p>column：主轴为垂直方向，起点在上沿，从上至下排列；</p>
<p>column-reverse：主轴为垂直方向，起点在下沿，从下至上排列。</p>
<p>(2) flex-wrap： 控制项目(子元素)是否换行。它可能取三个值：</p>
<p>nowrap：（默认值）不换行；</p>
<p>wrap：换行，第一行在上方；</p>
<p>wrap-reverse：换行，第一行在下方。</p>
<p>默认不换行，如果父元素装不下会缩小所有子元素的宽度，使子元素挤在一起。</p>
<p>(3) flex-flow：是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</p>
<p>(4) justify-content：设置主轴上的子元素对齐方式。它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右：</p>
<p>flex-start：（默认值）从头部开始排列；如果主轴是<em>x</em>轴则从左到右;</p>
<p>flex-end：从尾部开始排列;</p>
<p>center：在主轴居中对齐；如果主轴是<em>x</em>轴则水平居中;</p>
<p>space-around：平分剩余空间，盒子左右间距相等;</p>
<p>space-between: 先两侧贴边，平分剩余空间。</p>
<p>(5) align-items：设置侧轴上的子元素排列方式(单行)。它可能取5个值，具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下：</p>
<p>flex-start：从上到下；</p>
<p>flex-end：从下到上；</p>
<p>center：垂直居中；</p>
<p>stretch：(默认值)，如果项目未设置高度或设为auto，将占满整个容器的高度。</p>
<p>(6) align-content：设置侧轴上的子元素排列方式(多行)。该属性可能取6个值：</p>
<p>flex-start：从侧轴头部开始排列；</p>
<p>flex-end：从侧轴尾部开始排列；</p>
<p>center：侧轴中间显示；</p>
<p>space-around：子元素在侧轴平分剩余空间</p>
<p>space-between：子元素在侧轴先分布两头，平分剩余空间；</p>
<p>stretch：(默认值)，子元素高度平分父元素高度。</p>
<p>子元素属性：</p>
<p>(1) order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
<p>(2) flex属性：子元素占的份数</p>
<p>(3) align-self 控制子元素自己在侧轴排列方式，可覆盖align-items属性。</p>
<p>默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>
<p>align-self: auto | flex-start | flex-end | center | stretch;</p>
<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>
<h2 id="CSS实现三角形"><a href="#CSS实现三角形" class="headerlink" title="CSS实现三角形"></a>CSS实现三角形</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css">// 等腰三角形<br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">20px</span> solid transparent;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">20px</span> solid red;<br>  <span class="hljs-attribute">border-left</span>: <span class="hljs-number">20px</span> solid transparent;<br>  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">20px</span> solid transparent;<br>&#125;<br>// 直角三角形<br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">0px</span> solid transparent;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">20px</span> solid red;<br>  <span class="hljs-attribute">border-left</span>: <span class="hljs-number">10px</span> solid transparent;<br>  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">0px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="块元素和行内元素"><a href="#块元素和行内元素" class="headerlink" title="块元素和行内元素"></a>块元素和行内元素</h2><h3 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">div、p、h1-h6、form、ul、ol、dl、dt、dd、li、table、tr、td、th、hr、blockquote、address、table、menu、pre<br><br><span class="hljs-title class_">HTML5</span>：header、section、article、footer等等<br><br>块元素特性<br><span class="hljs-number">1.</span>块级元素独占一行，当没有设置宽高时，它默认设置为<span class="hljs-number">100</span>%<br><span class="hljs-number">2.</span>块级元素允许设置宽高，width、height、margin、padding、border都可控制<br><span class="hljs-number">3.</span>块级元素可以包行内元素、块级元素<br><span class="hljs-number">4.</span>块级元素可以设置margin和padding属性<br></code></pre></td></tr></table></figure>

<h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">span、img、a、label、code、input、abbr、em、b、big、cite、i、q、textarea、select、small、sub、sup，strong、u，button<br><br>行内元素特性<br><span class="hljs-number">1.</span>行内元素不能独占一行，与其他行内元素排成一行<br><span class="hljs-number">2.</span>行内元素不能设置width、height、margin、padding<br><span class="hljs-number">3.</span>行内元素默认宽度为其content宽度<br><span class="hljs-number">4.</span>行内元素只能包括文字或行内元素、行内块元素，不能包括块级元素<br><span class="hljs-number">5.</span>行内元素padding-left、padding-right，margin-left，margin-right（水平方向），有边距效果，padding-top，padding-bottom，margin-top，margin-bototm，（垂直方向）没有边距效果<br></code></pre></td></tr></table></figure>

<h1 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h1><h2 id="var-let-const区别"><a href="#var-let-const区别" class="headerlink" title="var let const区别"></a>var let const区别</h2><p>var：存在变量提升；变量覆盖，已经被定义且赋值的变量，如果再次被赋值，则以后一次值为准；没有块级作用域；</p>
<p>const：定义的是常量，声明之后必须赋值；定义的值不能去修改，否则报错；有块级作用域；不存在变量提升和变量覆盖；对于数组和对象的元素修改，不算对常量的修改，不会报错。(const定义的数据是一个简单数据类型的时候，是不能修改的，但如果是一个复杂数据类型是可以修改的，因为对于数据的存放是有栈、堆之说的，当存简单数据类型的时候，是放在栈中而对于复杂数据类型，是将它的地址放在栈中，真正的数据放在堆中，当我数据变化的时候并不会去修改地址，所以用const可以修改对象中的值)</p>
<p>let：有块级作用域；不存在变量提升和变量覆盖；let不允许在相同的作用域中重复声明，注意是相同作用域，不同作用域重复声明不会报错。与var 关键字不同，var 声明的变量会挂载到window对象上，成为其属性，而使用let 在全局作用域中声明的变量不会成为 window 对象的属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;w&#x27;</span><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;o&#x27;</span>,<br>    <span class="hljs-attr">print</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> p = obj.<span class="hljs-property">print</span><br>obj.<span class="hljs-title function_">print</span>() <span class="hljs-comment">// &#x27;o&#x27;</span><br><span class="hljs-title function_">P</span>()         <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>

<p>obj.print()就是obj调用的print()，this指向obj，所以在函数内部寻找变量，发现是o。p()相当于window.p()，this指向window，但let定义的变量a，他不会挂载到window上，所以结果是undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;<br><span class="hljs-comment">// 10 10 10 10 10 10 10 10 10 10</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;<br><span class="hljs-comment">// 0 1 2 3 4 5 6 7 8 9 10</span><br></code></pre></td></tr></table></figure>

<p>因为setTimeout是微任务，要等同步任务执行完才执行微任务，使用var定义时变量i是全局变量，值会被覆盖掉，循环后i的值是10，所以最后会打印10个10。</p>
<p>let定义的变量有自己的块级作用域，在每次执行循环体之前，JS引擎会把i在循环体的上下文中重新声明及初始化一次。</p>
<h2 id="JS变量提升"><a href="#JS变量提升" class="headerlink" title="JS变量提升"></a>JS变量提升</h2><p>变量提升是指JS的变量和函数声明会在代码编译期，提升到代码的最前面。</p>
<p>变量提升成立的前提是使用var关键字进行声明的变量，并且变量提升的时候只有声明被提升，赋值（函数表达式）并不会被提升，同时函数的声明提升会比变量的提升优先（var 定义的变量有变量提升，function 定义的函数也有函数提升）变量提升的结果，可以在变量初始化之前访问该变量，返回的是undefined。在函数声明前可以调用该函数。</p>
<p>当变量名和函数名相同时，如果变量声明并且赋了值。变量会覆盖函数。反之，声明了没赋值，函数覆盖变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-title function_">foo</span>();<br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-comment">// 执行时变成这样</span><br><span class="hljs-keyword">var</span> foo;<br><span class="hljs-keyword">var</span> x = <span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// TypeError: foo is not a function</span><br>foo = <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> val = <span class="hljs-number">12</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val);<br>    <span class="hljs-keyword">var</span> val = <span class="hljs-number">20</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val);<br>&#125;<br><span class="hljs-title function_">fun1</span>()<br><span class="hljs-comment">// 执行时</span><br><span class="hljs-keyword">var</span> val = <span class="hljs-number">12</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> val;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val); <span class="hljs-comment">// undefined</span><br>    val = <span class="hljs-number">20</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val); <span class="hljs-comment">// 20</span><br>&#125;<br><span class="hljs-title function_">fun1</span>()<br></code></pre></td></tr></table></figure>

<p>当局部变量和全局变量同时存在时，局部变量的优先级更高（就近原则）。在函数fun1内部，由于存在变量提升，会先使用var声明局部变量val，而变量的赋值并不会跟着一起提升，接着使用console.log()输出val，由于val变量已声明但未赋值，故输出结果为undefined，然后再对val进行赋值，其值为20，最后再次输出val，输出结果为20. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> b = <span class="hljs-number">3</span>;<br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    b = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br>&#125;)();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b)<br><span class="hljs-comment">// 执行时</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-number">3</span>;<br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> b<br>    b = <span class="hljs-number">5</span>;<br>    b = <span class="hljs-number">2</span>;<br>&#125;)();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b)<br></code></pre></td></tr></table></figure>

<p>立即执行函数内部，var发生变量提升，结果相当于 (function(){ var b; b&#x3D;5; b&#x3D;2; })() 所以这个立即执行函数并没有改变全局环境中的b，所以全局环境中的b依旧是3。</p>
<h2 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h2><p>Number、String、Boolean、Biglnt (ES10新增)、Symbol (ES6新增)、Null、Undefined、Obiect、8种</p>
<p>JS数据类型分为两类:</p>
<p>一类是<strong>基本数据类型</strong>，也叫简单数据类型，包含7种类型，分别是Number、String、Boolean、Biglnt (ES10新增)、Symbol (ES6新增)、 Null、Undefined。Symbol是ES6新增的基本数据类型，表示独一无二的值。Symbol()函数会返回symbol类型的值，每个从Symbol()返回的值都是唯一的。</p>
<p>另一类是<strong>引用数据类型</strong>也叫复杂数据类型，通常用Obiect代表，普通对象，Array数组，RegExp正则，Date日期，Math数学函数都属于Obiect。</p>
<h3 id="本质区别"><a href="#本质区别" class="headerlink" title="本质区别"></a>本质区别</h3><p>基本数据类型和引用数据类型它们在<strong>内存中的存储方式</strong>不同。</p>
<p>基本数据类型是直接存储在<strong>栈</strong>中的简单数据段，占据空间小，属于被频繁使用的数据。</p>
<p>引用数据类型是存储在<strong>堆</strong>内存中，占据空间大。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址，当解释器寻找引用值时，会检索其在栈中的地址取得地址后从堆中获得实体。</p>
<h3 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h3><p>JavaScript有4种方法判断变量的类型，分别是typeof、instanceof、constructor、 Object.prototype.toString.call()(对象原型链判断方法)。</p>
<p><strong>typeof</strong>：判断基本数据类型 null返回object，function返回function，其余返回object</p>
<p><strong>使用方法</strong>：typeof 数据 返回数据类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> <span class="hljs-number">18</span>,<span class="hljs-comment">//&quot;nu ber&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-comment">//&quot;string&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">false</span>, <span class="hljs-comment">//boolean&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>, <span class="hljs-comment">//&quot;undefined&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>, <span class="hljs-comment">//&quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]，<span class="hljs-comment">//&quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-attr">fa</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">b</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">c</span>:<span class="hljs-number">3</span>], <span class="hljs-comment">//&quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)(<span class="hljs-params"><span class="hljs-variable language_">console</span>.log(<span class="hljs-string">&quot;aaa&quot;</span>);], <span class="hljs-comment">//&quot;function&quot;</span></span><br><span class="hljs-params"><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(), <span class="hljs-comment">//&quot;object&quot;</span></span><br><span class="hljs-params"><span class="hljs-keyword">typeof</span> /~[a-zh-z](<span class="hljs-number">5</span>,<span class="hljs-number">20</span>]$/， <span class="hljs-comment">//&quot;object&quot;</span></span><br><span class="hljs-params"><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>() <span class="hljs-comment">//&quot;object&quot;</span></span><br><span class="hljs-params"><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> Nurber(<span class="hljs-number">100</span>), <span class="hljs-comment">// &quot;object&quot;</span></span><br><span class="hljs-params"><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;abc&quot;</span>),<span class="hljs-comment">// &quot;string</span></span><br><span class="hljs-params"><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">true</span>),<span class="hljs-comment">// &quot;boolean</span></span><br></code></pre></td></tr></table></figure>

<p><strong>instanceof</strong>：判断复杂数据类型(引用数据类型)，判断基本数据类型返回false </p>
<p><strong>使用方法</strong>：数据 instanceof 数据类型 返回true或false</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">1ee <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span>, <span class="hljs-comment">//false</span><br><span class="hljs-string">&quot;dsfsf’ instanceof String, //false</span><br><span class="hljs-string">false instanceof Boolean, //false</span><br><span class="hljs-string">undefined instanceof Object, //false</span><br><span class="hljs-string">null instanceof object, //false</span><br><span class="hljs-string">[1,2,3] instanceof Array, //true</span><br><span class="hljs-string">(a:1,b:2c:3] instanceof object, //true</span><br><span class="hljs-string">function()(console.log(&quot;</span>aaa<span class="hljs-string">&quot;);&#125; instanceof Function, //true</span><br><span class="hljs-string">new Date() instanceof Date, //true</span><br><span class="hljs-string">/~[a-zA-Z](5,20)$/ instanceof RegExp， //true</span><br><span class="hljs-string">new Error() instanceof Error //true</span><br></code></pre></td></tr></table></figure>

<p><strong>constructor</strong>:可以检测基本数据类型，也能分辨出数组和对象，但是我们可以随意更改constructor的值，导致检测结果不准确。除了undefined和null都可以用。</p>
<p><strong>使用方法</strong>：数据.constructor &#x3D;&#x3D;&#x3D; 数据类型  返回true或false</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-literal">false</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Boolean</span>;            <span class="hljs-comment">// true</span><br>“<span class="hljs-number">123</span>”.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">String</span>;             <span class="hljs-comment">// true</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Nurber</span>(<span class="hljs-number">123</span>) .<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Nurber</span>;  <span class="hljs-comment">// true</span><br>[].<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span>;                 <span class="hljs-comment">// true</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>() .<span class="hljs-property">construetor</span> === <span class="hljs-title class_">Functions</span>;<span class="hljs-comment">// true</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() .<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Date</span>;         <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">HIMLDocument</span>;    <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Window</span>;            <span class="hljs-comment">// true</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>() .<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Error</span>;       <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p><strong>Object.prototype.toString.call()</strong>&#x2F;<strong>Object.prototype.toString.apply()</strong>: 适用于所有类型的判断检测。</p>
<p>检测方法是Object.prototype.toString.call(数据)，返回的是该数据类型的字符串<code>&quot;[object 数据类型]&quot;</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>);       <span class="hljs-comment">// ”[object Null]”</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>);  <span class="hljs-comment">// ”[object Undefined]”</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(“abc”);      <span class="hljs-comment">// ”[object String]”</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-number">123</span>);        <span class="hljs-comment">// ”[object Number]”</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">true</span>);       <span class="hljs-comment">// ”[object Boolean]”</span><br></code></pre></td></tr></table></figure>

<h2 id="数组去重方法"><a href="#数组去重方法" class="headerlink" title="数组去重方法"></a>数组去重方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1.Set去重</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">23</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">33</span>,<span class="hljs-number">22</span>,<span class="hljs-number">12</span>,<span class="hljs-number">21</span>]<br><span class="hljs-keyword">let</span> item = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)]<br><span class="hljs-comment">// 2.filter去重</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">arr</span>)&#123;<br>	<span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item, index, arr</span>)=&gt;</span>&#123;<br>		<span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">indexOf</span>(item, <span class="hljs-number">0</span>)===index;<br>		<span class="hljs-comment">// arr.indexOf(item, 0)是item在arr中第一次出现的索引值</span><br>		<span class="hljs-comment">// index是item当前索引值</span><br>	&#125;);<br>&#125;<br><span class="hljs-comment">// 3.forEach去重</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">let</span> newArr=[];<br>	arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-params">(item, index, arr)=&gt;&#123;</span><br><span class="hljs-params">		<span class="hljs-keyword">if</span>(newArr.indexOf(item))===-<span class="hljs-number">1</span>)&#123;</span><br><span class="hljs-params">			newArr.push(item);</span><br><span class="hljs-params">		&#125;</span><br><span class="hljs-params">	&#125;</span>);<br>	<span class="hljs-keyword">return</span> newArr;<br>&#125;<br><span class="hljs-comment">// 4.sort去重</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">arr</span>) &#123;<br>  arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span> a - b);<br>  <span class="hljs-keyword">let</span> newArr = [arr[<span class="hljs-number">0</span>]]<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] !== arr[i - <span class="hljs-number">1</span>]) &#123;<br>      newArr.<span class="hljs-title function_">push</span>(arr[i])<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> newArr;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//选择排序</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">123</span>,<span class="hljs-number">203</span>,<span class="hljs-number">23</span>,<span class="hljs-number">13</span>,<span class="hljs-number">34</span>,<span class="hljs-number">65</span>,<span class="hljs-number">65</span>,<span class="hljs-number">45</span>,<span class="hljs-number">89</span>,<span class="hljs-number">13</span>,<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>; i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=i+<span class="hljs-number">1</span>; j&lt;arr.<span class="hljs-property">length</span>; j++)&#123;<br>       <span class="hljs-comment">//如果第一个比第二个大，就交换他们两个位置</span><br>       <span class="hljs-keyword">if</span>(arr[i]&gt;arr[j])&#123;<br>           <span class="hljs-keyword">var</span> temp = arr[i];<br>           arr[i] = arr[j];<br>           arr[j] = temp;<br>       &#125;<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">//(11) [1, 13, 13, 23, 34, 45, 65, 65, 89, 123, 203]</span><br><span class="hljs-comment">//冒泡排序</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">123</span>,<span class="hljs-number">203</span>,<span class="hljs-number">23</span>,<span class="hljs-number">13</span>,<span class="hljs-number">34</span>,<span class="hljs-number">65</span>,<span class="hljs-number">65</span>,<span class="hljs-number">45</span>,<span class="hljs-number">89</span>,<span class="hljs-number">13</span>,<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>; i++)&#123;<br>    <span class="hljs-comment">//每一轮比较要比多少次</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>; j&lt;arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>-i; j++)&#123;<br>      <span class="hljs-comment">//如果第一个比第二个大，就交换他们两个位置</span><br>      <span class="hljs-keyword">if</span>(arr[j]&gt;arr[j+<span class="hljs-number">1</span>])&#123;<br>        <span class="hljs-keyword">var</span> temp = arr[j];<br>        arr[j] = arr[j+<span class="hljs-number">1</span>];<br>        arr[j+<span class="hljs-number">1</span>] = temp;<br>      &#125;<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">//(11) [1, 13, 13, 23, 34, 45, 65, 65, 89, 123, 203]</span><br></code></pre></td></tr></table></figure>

<h2 id="数组遍历方法"><a href="#数组遍历方法" class="headerlink" title="数组遍历方法"></a>数组遍历方法</h2><p><strong>forEach</strong>方法：遍历数组，默认有3个参数：item：遍历的每一个元素，index：遍历的索引，arr：遍历的数组</p>
<p><strong>map</strong>方法：遍历数组，和forEach一致，不同的是会返回一个新的数组，如果没有return会返回undefined</p>
<p><strong>filter</strong>方法：遍历数组，返回一个新数组，新数组由参数里条件为true的元素组成</p>
<p><strong>some</strong>方法：遍历数组，只要有一个元素符合条件就返回true，都不符合条件返回false</p>
<p><strong>every</strong>方法：遍历数组，所有元素就返都符合条件才返回true，不然返回false    </p>
<p><strong>reduce</strong>方法：遍历数组，一般作为累加器.</p>
<ul>
<li>prevValue表示上一次调用回调时的返回值(accumulator：累加器)</li>
<li>currentValue表示当前的元素。</li>
<li>currentIndex表示当前的元素索引。</li>
<li>init 代表初始值，不写默认是0。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br><span class="hljs-keyword">let</span> init=<span class="hljs-number">0</span><br><span class="hljs-keyword">let</span> res=arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">preValue,currentValue</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> preValue+cuurentValue<br>&#125;,init)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) <span class="hljs-comment">// 36</span><br><span class="hljs-comment">/////////////////////////////////</span><br><span class="hljs-keyword">let</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br><span class="hljs-keyword">let</span> init=<span class="hljs-number">3</span><br><span class="hljs-keyword">let</span> res=arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">preValue,currentValue</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> preValue+cuurentValue<br>&#125;,init)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) <span class="hljs-comment">// 39</span><br></code></pre></td></tr></table></figure>

<p>**for…of…**方法：遍历数组&#x2F;字符串，for…in…返回的是数组的下标，for…of…返回的是数组元素的索引</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> item <span class="hljs-keyword">of</span> arr)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item) <span class="hljs-comment">// 1, 2, 3, 4, 5</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="数组方法汇总"><a href="#数组方法汇总" class="headerlink" title="数组方法汇总"></a>数组方法汇总</h2><h3 id="不改变原数组的方法："><a href="#不改变原数组的方法：" class="headerlink" title="不改变原数组的方法："></a>不改变原数组的方法：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item, index, arr</span>)=&gt;</span>&#123;&#125;) <span class="hljs-comment">// 循环遍历数组、返回一个新的数组</span><br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index, arr</span>)=&gt;</span>&#123;&#125;) <span class="hljs-comment">// 循环遍历数组，不改变原数组</span><br>arr.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">item, index, arr</span>)=&gt;</span>&#123;&#125;) <span class="hljs-comment">// 有一项返回为true，则整体为true</span><br>arr.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">item, index, arr</span>)=&gt;</span>&#123;&#125;) <span class="hljs-comment">// 有一项返回为true，则整体为false</span><br>arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item, index, arr</span>)=&gt;</span>&#123;&#125;) <span class="hljs-comment">// 数组过滤</span><br>arr.<span class="hljs-title function_">reduce</span>(prevValue/accumulator, currentValue, currentIndex, arr)=&gt;&#123;&#125;,init) <span class="hljs-comment">// 数组求和</span><br>arr.<span class="hljs-title function_">slice</span>(start, end) <span class="hljs-comment">// 数组截取，包括start，不包括end，返回一个新的数组（start为起始索引end为结束索引值）</span><br>arr.<span class="hljs-title function_">concat</span>(arr) <span class="hljs-comment">// 数组的拼接，不影响原数组，浅拷贝</span><br>arr.<span class="hljs-property">indexOf</span>/<span class="hljs-title function_">lastIndexOf</span>(item) <span class="hljs-comment">// 查找数组项，返回对应的下标</span><br>arr.<span class="hljs-title function_">join</span>(‘-’) <span class="hljs-comment">// 把数组转化为字符串(split(‘-’) 将字符串分割为数组)</span><br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>].<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// &#x27;12345&#x27;</span><br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>].<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-comment">// &#x27;1-2-3-4-5&#x27;</span><br>arr.<span class="hljs-title function_">findIndex</span>(item) <span class="hljs-comment">// 查找并返回第一个符合要求的值的索引</span><br>arr.<span class="hljs-property">find</span> (item) <span class="hljs-comment">// 查找并返回第一个符合要求的值</span><br></code></pre></td></tr></table></figure>

<h3 id="改变原数组的方法："><a href="#改变原数组的方法：" class="headerlink" title="改变原数组的方法："></a>改变原数组的方法：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-property">push</span>/pop <span class="hljs-comment">// 在数组的末尾添加/删除元素改变原数组</span><br>arr.<span class="hljs-property">unshift</span>/shift <span class="hljs-comment">// 在数组的头部添加/删除元素，改变原数组</span><br><span class="hljs-comment">// 注意：pop和shift返回被删除的元素，push和unshift返回数组的新长度</span><br>arr.<span class="hljs-property">splice</span> <span class="hljs-comment">// 删除数组元素，改变原数组，返回被删除的元素</span><br>arr.<span class="hljs-title function_">splice</span>(start, number) <span class="hljs-comment">// start为起始索引 number为删除个数</span><br>arr.<span class="hljs-title function_">splice</span>(start, number, value) <span class="hljs-comment">// value为新增元素</span><br><span class="hljs-keyword">let</span> arr=[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>]<br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>) <span class="hljs-comment">// arr: [&#x27;a&#x27;,&#x27;e&#x27;,&#x27;f&#x27;]</span><br><span class="hljs-keyword">let</span> arr=[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>]<br><span class="hljs-keyword">let</span> result=arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;value&#x27;</span>) <br><span class="hljs-comment">// arr: [&#x27;a&#x27;,&#x27;value&#x27;,&#x27;e&#x27;,&#x27;f&#x27;]</span><br><span class="hljs-comment">// result: [&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]</span><br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>a-b) <span class="hljs-comment">// 数组排序改变原数组（a-b为升序，b-a为降序）</span><br>arr.<span class="hljs-title function_">reverse</span>() <span class="hljs-comment">// 数组反转，改变原数组</span><br></code></pre></td></tr></table></figure>

<h3 id="find和filter区别"><a href="#find和filter区别" class="headerlink" title="find和filter区别"></a>find和filter区别</h3><p><strong>find</strong>是寻找，是在数组中找到第一个符合条件的元素并返回这个数</p>
<p><strong>filter</strong>是过滤，是在遍历数组后拿到所有符合条件的元素，返回的是一个数组 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>item===<span class="hljs-number">2</span>)) <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>item===<span class="hljs-number">2</span>)) <span class="hljs-comment">// [2,2]</span><br></code></pre></td></tr></table></figure>

<h2 id="伪数组和数组"><a href="#伪数组和数组" class="headerlink" title="伪数组和数组?"></a>伪数组和数组?</h2><h3 id="伪数组和数组区别："><a href="#伪数组和数组区别：" class="headerlink" title="伪数组和数组区别："></a>伪数组和数组区别：</h3><ol>
<li>伪数组的类型不是Array，而是Object，数组的类型是Array。</li>
<li>可以使用length属性查看长度</li>
<li>可以使用[index]获取某个元素</li>
<li>但是不能使用数组的其他方法,也不能改变长度</li>
<li>遍历使用for in方法。</li>
</ol>
<h3 id="伪数组的常见场景"><a href="#伪数组的常见场景" class="headerlink" title="伪数组的常见场景:"></a>伪数组的常见场景:</h3><ol>
<li>function内arguments对象。</li>
<li>还有像调用getElementsByTagName, getElementsByClassName,document.childNodes, querySelectorAll，之类返回的NodeList对象都属于伪数组，也称为类数组.（注意：getElementById和querySelector获取到的是单个元素）。</li>
<li>jQuery中的$()方法获取到的全部是伪数组,本质都是html标签序列。</li>
<li>自定义的伪数组,例如 let obj&#x3D;{0:‘a’,1:‘b’,length:2}。</li>
</ol>
<h3 id="伪数组转换为数组"><a href="#伪数组转换为数组" class="headerlink" title="伪数组转换为数组"></a>伪数组转换为数组</h3><ol>
<li><code>Array.from(伪数组)</code></li>
<li><code>Array.of(伪数组)</code></li>
<li><code>new Array(伪数组)</code></li>
<li><code>Array.prototype.slice.call(伪数组)/Array.prototype.slice.apply(伪数组)</code></li>
<li><code>[].slice.call(伪数组)/[].slice.apply(伪数组)</code></li>
<li><code>var args = [...arguments]</code></li>
</ol>
<h3 id="判断变量是否为数组？"><a href="#判断变量是否为数组？" class="headerlink" title="判断变量是否为数组？"></a>判断变量是否为数组？</h3><ol>
<li><code>Array.isArray(arr) // true</code></li>
<li><code>arr.__proto__ === Array.prototype // true</code></li>
<li><code>arr instanceof Array // true</code></li>
<li><code>arr.constructor === Array // true</code></li>
<li><code>Object,prototype.toString.call(arr) // &quot;[object Array]&quot;</code></li>
</ol>
<h2 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">str.<span class="hljs-title function_">charAt</span>(index) <span class="hljs-comment">// 从一个字符串中返回指定的字符</span><br>str.<span class="hljs-title function_">concat</span>(str1, str2) <span class="hljs-comment">// 将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回</span><br>str.<span class="hljs-title function_">includes</span>(字符串中某一个字符) <span class="hljs-comment">// 用于判断一个字符串是否包含在另一个字符串中，根据情况返回true 或false。</span><br>str.<span class="hljs-title function_">indexOf</span>(字符串中某一个字符，fromIndex) <span class="hljs-comment">// 返回调用它的 string 对象中第一次出现的指定值的索引，从fromIndex处进行搜索。如果未找到该值，则返回-1。</span><br>str.<span class="hljs-title function_">match</span>(正则表达式) <span class="hljs-comment">// 检索返回一个或多个字符串匹配正则表达式的结果</span><br>str.<span class="hljs-title function_">repeat</span>(复制次数) <span class="hljs-comment">// 字符串复制指定次数</span><br>str.<span class="hljs-title function_">replace</span>(oldStr，newStr) <span class="hljs-comment">// 将oldStr替换为newStr（只能替换首个返回条件的字符） </span><br>str.<span class="hljs-title function_">replaceAll</span>(oldStr，newStr) <span class="hljs-comment">// 将所有的oldStr替换为newStr</span><br>str.<span class="hljs-title function_">search</span>(要查找的字符串) <span class="hljs-comment">// 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。返回与指定查找的字符串或者正则表达式相匹配的String对象起始位置</span><br>str.<span class="hljs-title function_">slice</span>(start, end) <span class="hljs-comment">// 提取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串。（包含start，不包含end）start和end都可以是负数，如果是负数，就从字符串的尾部开始算起，例如-1就是最后一个字符，-2就是倒数第二个字符</span><br>str.<span class="hljs-title function_">split</span>(‘-’) <span class="hljs-comment">// 使用指定的分隔符字符串将一个string对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。</span><br><span class="hljs-keyword">let</span> str=<span class="hljs-string">&#x27;a-b-c-d-e&#x27;</span><br>str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// [&#x27;a&#x27;,&#x27;-&#x27;,&#x27;b&#x27;,&#x27;-&#x27;,&#x27;c&#x27;,&#x27;-&#x27;,&#x27;d&#x27;,&#x27;-&#x27;,&#x27;e&#x27;]</span><br>str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-comment">// [&#x27;a&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;]</span><br>str.<span class="hljs-title function_">substring</span>(start, end) <span class="hljs-comment">// 截取str从start到end的所有字符(包含起始位置,但不包含结束位置)。两个参数都必须是非负整数，如果参数start与end相等，那么该方法返回的就是一个空字符串，如果start比end大，那么该方法在提取字符串之前会先交换这两个参数。如果未指定end参数，则截取从start到原字符串结尾的字符串</span><br><span class="hljs-keyword">let</span> str=<span class="hljs-string">&#x27;abcde leodonna&#x27;</span><br>str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>,<span class="hljs-number">8</span>) <span class="hljs-comment">// bcde le</span><br>str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">4</span>) <span class="hljs-comment">// e leodonna</span><br>str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">4</span>,<span class="hljs-number">1</span>) <span class="hljs-comment">// bcd</span><br>str.<span class="hljs-title function_">toLowerCase</span>() <span class="hljs-comment">// 用于把字符串转换为小写。</span><br>str.<span class="hljs-title function_">toUpperCase</span>() <span class="hljs-comment">// 用于把字符串转换为大写。</span><br>str.<span class="hljs-title function_">trim</span>() <span class="hljs-comment">// 用于删除字符串的头尾空白符，空白符包括：空格、制表符 tab、换行符等其他空白符等。</span><br></code></pre></td></tr></table></figure>

<h2 id="防抖和节流-袋鼠云笔试"><a href="#防抖和节流-袋鼠云笔试" class="headerlink" title="防抖和节流(袋鼠云笔试)"></a>防抖和节流(袋鼠云笔试)</h2><p>防抖：触发事件后，在n秒内，事件只执行一次，如果在n秒内又触发了事件，则会重新计算函数的执行时间。(注意，下面代码let timer&#x3D;null只执行一次)</p>
<p>比如点击按钮，2秒后调用函数，结果在1.5秒的时候又点了，则会重新计算2秒后在调用函数。</p>
<p>应用场景：</p>
<p>1.调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖；</p>
<p>2.文本编辑器实时保存，当无任何更改操作一秒后进行保存。</p>
<p>3.搜索框输入时，n秒后再请求后台数据，如果不到n秒又输入就重新等待n秒</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn,delay</span>)&#123;<br>    <span class="hljs-keyword">let</span> timer=<span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">let</span> arg=<span class="hljs-variable language_">arguments</span><br>        <span class="hljs-keyword">if</span>(timer) <span class="hljs-title function_">clearTimerout</span>(timer)<br>        timer=<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,arg)<br>        &#125;,delay)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>节流：连续发生的事件在n秒内，只执行为一次</p>
<p>应用场景：</p>
<p>1.鼠标连续不断地触发某事件（如点击），单位时间内只触发一次；</p>
<p>2.监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断。例如：懒加载；</p>
<p>3.浏览器播放事件，每个一秒计算一次进度信息等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn,delay</span>)&#123;<br>    <span class="hljs-keyword">let</span> timer=<span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">let</span> arg=<span class="hljs-variable language_">arguments</span><br>        <span class="hljs-keyword">if</span>(!timer) &#123;<br>            timer=<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,arg)<br>                timer=<span class="hljs-literal">null</span><br>            &#125;,delay)     <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="js闭包"><a href="#js闭包" class="headerlink" title="js闭包"></a>js闭包</h2><p>闭包就是一个函数对周围状态的引用捆绑在一起，内层函数可以访问到外层函数的作用域。</p>
<p>简单来说，闭包就是内层函数+引用的外层函数变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;<br>    <span class="hljs-title function_">f</span>()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>闭包不一定有return，当外部如果想要使用闭包的变量的时候，此时需要return。</p>
<p>闭包存在意义：</p>
<p>可以延长变量的生命周期，可以创建私有的环境</p>
<p>闭包好处：</p>
<p>可以读取其他函数的内部变量，将变量始终保存在内存中</p>
<p>主要实现数据的私有（因为外部函数可以使用但是不能修改内部函数的变量）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>        count++<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`函数被调用了<span class="hljs-subst">$&#123;count&#125;</span>次`</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> fun<br>&#125;<br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">fn</span>()<br><span class="hljs-title function_">result</span>() <span class="hljs-comment">// 2</span><br><span class="hljs-title function_">result</span>() <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>

<p>坏处：消耗内存、使用不当会造成内存溢出问题</p>
<p>result是一个全局变量，代码执行完毕不会立即销毁，result使用fn函数，fn用到fun函数，fun函数里面用到count，count被引用就不会被回收，所以一直存在，此时：闭包引起了内存泄露。</p>
<h2 id="JS垃圾回收机制-袋鼠云笔试"><a href="#JS垃圾回收机制-袋鼠云笔试" class="headerlink" title="JS垃圾回收机制(袋鼠云笔试)"></a>JS垃圾回收机制(袋鼠云笔试)</h2><p>GC–garbage collection，JS具有“自动”垃圾回收机制，即执行环境会负责管理代码执行过程中使用的内存</p>
<p>GC会定期（周期性的）找出那些不再继续使用的变量，然后释放其内存</p>
<p>不再使用的变量即生命周期结束的变量会被释放，只能是局部变量，全局变量的生命周期，直到浏览器关闭页面才会结束</p>
<p>闭包由于内部函数原因，外部函数不能算结束，无法释放内存</p>
<p>js的垃圾回收机制—-采用的方式</p>
<p>(1)<strong>标记清除法</strong></p>
<p><strong>标记</strong>：遍历所有的对象找到活动对象，进行标记的操作，表示该对象可达。</p>
<p><strong>清除</strong>：遍历所有的对象，找到那些没有标记的对象进行清除。(注意在第二阶段中也会把第一阶段涉及的标志给抹掉，便于GC下次能够正常的工作) </p>
<p>(2)<strong>引用计数法</strong></p>
<p>跟踪记录每个值被引用的次数，当某个值的引用次数变为0时，说明没有方法在访问该值了，则可将其占用的内存收回</p>
<h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><ol>
<li>以函数的形式（包括普通函数、定时器函数、立即执行函数）调用时，this的指向永远都是window。比如fun();相当于window.fun();匿名函数具有全局性，匿名函数的this指向window对象</li>
<li>以方法的形式调用时，this指向调用方法的那个对象</li>
<li>以构造函数的形式调用时，this指向实例对象</li>
<li>以事件绑定函数的形式调用时，this指向绑定事件的对象</li>
<li>使用call、apply和bind调用时，this指向指定的那个对象</li>
<li>箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象)，此处指父级作用域</li>
<li>严格模式下变量必须用关键字声明后才能使用<ul>
<li>严格模式下，普通函数的this指向undefined</li>
<li>严格模式下，立即执行函数的this指向undefined</li>
<li>严格模式下，setTimeout中函数的this指向的window（与普通函数不同）</li>
<li>严格模式下，构造函数的this指向undefined，但是构造函数实例化对象的this指向的是实例化对象本身</li>
</ul>
</li>
</ol>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">() =&gt; &#123; ... &#125;<br>() =&gt; <span class="hljs-keyword">return</span> ...<br>val =&gt; <span class="hljs-keyword">return</span> val++<br></code></pre></td></tr></table></figure>

<p>函数体中只有一句代码，且代码的执行结果就是返回值 可以省略大括号。如果形参只有一个时，可以省略小括号。</p>
<p>箭头函数的this指向父级作用域的this</p>
<p> 箭头函数与普通函数的区别</p>
<ul>
<li>箭头函数的定义要比普通函数定义简洁、清晰得多，更快捷。</li>
<li>箭头函数的this指向外层第一个普通函数，如果外层没有普通函数，则指向 window</li>
<li>箭头函数不可以作为构造函数(即不能使用new)</li>
<li>箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是外层函数执行环境中的值。箭头函数this指向全局时，不能调用 arguments</li>
<li>箭头函数没有原型prototype</li>
</ul>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><ul>
<li>JS是单线程，为防止阻塞，将代码分为同步和异步任务。</li>
<li>同步任务交给JS引擎执行，异步任务交给宿主环境执行。</li>
<li>同步代码会被放入执行栈中，异步任务会将回调函数放入任务队列中。</li>
<li>当执行栈中代码执行完毕，会去任务队列中看是否有异步任务，如果有送入执行栈执行，反复循环查看，这就是事件循环（Eventloop）。</li>
</ul>
<h2 id="宏任务微任务"><a href="#宏任务微任务" class="headerlink" title="宏任务微任务"></a>宏任务微任务</h2><p>代码可能有3种：</p>
<ol>
<li><p>同步任务（JS执行栈&#x2F;回调栈）</p>
</li>
<li><p>微任务的异步代码（JS引擎）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">process.<span class="hljs-title function_">nextTick</span>(node)<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">then</span>() <span class="hljs-keyword">catch</span>()<br><span class="hljs-title class_">Async</span>/<span class="hljs-title class_">Await</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">observe</span>()<br></code></pre></td></tr></table></figure>
</li>
<li><p>宏任务的异步代码（宿主环境）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">script</span>(代码块)<br><span class="hljs-built_in">setTimeout</span>/<span class="hljs-built_in">setInterval</span>定时器<br>I/O<br><span class="hljs-variable constant_">UI</span> render<br></code></pre></td></tr></table></figure></li>
</ol>
<p>异步任务会先执行任务队列中的微任务（promise方法），执行完毕会再去任务队列查看是否有微任务，如果有，继续执行，如果没有就去执行宏任务(setTimeout等)</p>
<p>注意：</p>
<ul>
<li>Promise本身是同步的，then&#x2F;catch的回调函数是异步的微任务</li>
<li>setTimeout，如果时间为0，则会立即插入队列，不是立即执行，等待前面的代码执行完毕。仍然是异步任务要交给宿主环境执行。</li>
</ul>
<h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><p>原型对象：每个函数都有prototype属性，称之为原型，因为这个属性的值是个对象，也称为原型对象。</p>
<p>作用：</p>
<ol>
<li>存放了一些属性和方法</li>
<li>在JavaScript中实现继承</li>
</ol>
<p>对象原型：每个对象都有<code>__proto__</code>属性，指向它的原型对象prototype</p>
<p>每个构造函数都有个prototype属性，即对象原型，构造函数的每个实例对象都有<code>__proto__</code>属性，指向构造函数的原型对象。</p>
<p>对象都有<code>__proto__</code>属性，这个属性指向它的原型对象prototype，原型对象也是对象，也有<code>__proto__</code>属性，指向原型对象的原型对象，这样一层一层形成的链式结构称为原型链，直到最顶层找不到返回null。</p>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p><strong>定义</strong>：事件委托也叫事件代理，是指将事件处理程序绑定到父元素上，然后通过判断事件的目标，来执行对应的时间处理程序</p>
<p><strong>原理</strong>：事件冒泡机制。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>可以大量节省内存占用，减少事件注册，提高代码的性能和可维护性。比如ul上代理所有li的click事件就很不错。</li>
<li>当新增子对象时，无需再对其进行事件绑定和解绑事件，对于动态内容部分尤为合适。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ol>
<li>事件委托基于冒泡，对于不冒泡的事件不支持。（不支持冒泡的事件：UI事件(load, unload, scroll, resize)，焦点事件(blur, focus), 鼠标事件(mouseleave, mouseenter)）</li>
<li>层级过多，冒泡过程中，可能会被某层阻止掉（event.stopPropagation()）。</li>
<li>理论上委托会导致浏览器频繁调用处理函数，虽然很可能不需要处理。所以建议就近委托，比如在table上代理td，而不是在document上代理td。</li>
<li>把所有事件都用代理就可能会出现事件误判。比如，在document中代理了所有button的click事件，另外的人在引用改js时，可能不知道，造成单击button触发了两个click事件。</li>
</ol>
<p>事件冒泡和事件捕获</p>
<p>事件冒泡和事件捕获都是为了解决页面中事件流（事件发生顺序）的问题。</p>
<ol>
<li><strong>事件冒泡</strong>：事件会从最内层的元素开始发生，一直向上传播，直到document对象。</li>
<li><strong>事件捕获</strong>：与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素</li>
</ol>
<p>处理顺序：</p>
<p>DOM事件流：将事件分为三个阶段：捕获阶段、目标阶段和冒泡阶段</p>
<p>先事件捕获（从 Windows -&gt; document 依次往下）；再是目标事件处理；最后是事件冒泡。</p>
<p>如何阻止事件冒泡？</p>
<p>1.<strong>event.stopPropagation()</strong></p>
<p>这是阻止事件的冒泡方法，不止事件向document上蔓延，但是默认事件任然会执行，当你调用这个方法的时候，如果点击一个连接，这个连接仍然会被打开</p>
<p>2.<strong>event.preventDefault()</strong></p>
<p>这是阻止默认事件的方法，调用此方法时，链接不会被打开，但是会发生冒泡，冒泡会传递到上一层的父元素</p>
<p>3.<strong>return false</strong>;</p>
<p>这个方法比较暴力，他会同时阻止事件冒泡也会阻止默认事件，不仅阻止了事件往上冒泡，而且阻止了事件本身</p>
<h2 id="事件扩展符用过吗-…"><a href="#事件扩展符用过吗-…" class="headerlink" title="事件扩展符用过吗(…)"></a>事件扩展符用过吗(…)</h2><p>展开语法(Spread syntax)，可以在函数调用&#x2F;数组构造时，将数组表达式或者string在语法层面展开，还可以在构造字面量对象时，将对象表达式按key-value的方式展开。</p>
<p>常见的场景：</p>
<ul>
<li>将数组展开为构造函数的参数</li>
<li>字面量数组或字符串连接不需要使用concat等方法</li>
<li>构造字面量对象时，进行浅拷贝或者属性拷贝</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span>数组拷贝 <span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]；<span class="hljs-keyword">let</span> b = [...a] <span class="hljs-comment">// b = [1,2,3]</span><br><span class="hljs-number">2.</span>数组合并 <span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]；<span class="hljs-keyword">let</span> b = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]；<span class="hljs-keyword">let</span> c = [...a, ...b] <span class="hljs-comment">// c = [1,2,3,4,5,6]</span><br><span class="hljs-number">3.</span>伪数组转成真正的数组 <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])；<span class="hljs-keyword">let</span> b = [...a] <span class="hljs-comment">// b = [1,2,3]</span><br></code></pre></td></tr></table></figure>

<h3 id="剩余参数和arguments对象"><a href="#剩余参数和arguments对象" class="headerlink" title="剩余参数和arguments对象"></a>剩余参数和arguments对象</h3><p>剩余参数语法允许将一个不定数量的参数表示为一个数组</p>
<p>表示：一个普通标识符前加3个点，例如：…args</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sum</span>=(<span class="hljs-params">f, ...args</span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args)<br>&#125;<br><span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>

<p>arguments是伪数组，跟数组很像，拥有length属性和索引元素，但是它不是一个真正的数组，不能使用数组的方法，也不能改变长度，遍历使用for in方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// arguments转化成数组的方法</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(伪数组)<br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(伪数组)<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(伪数组)<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(伪数组)/<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">apply</span>(伪数组)<br>[].<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(伪数组)/[].<span class="hljs-property">slice</span>.<span class="hljs-title function_">apply</span>(伪数组)<br></code></pre></td></tr></table></figure>

<p>剩余参数和arguments对象的区别：</p>
<ol>
<li>剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。</li>
<li>剩余参数是真正的Array实例，而arguments对象不是一个真正的数组，arguments也就不能使用数组的方法。</li>
</ol>
<h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h2><p><strong>浅拷贝</strong>：创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p>
<p><strong>深拷贝</strong>：会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。</p>
<h3 id="浅拷贝实现方法："><a href="#浅拷贝实现方法：" class="headerlink" title="浅拷贝实现方法："></a>浅拷贝实现方法：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-number">1</span>) <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>()<br><span class="hljs-comment">// 定义：用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</span><br><span class="hljs-comment">// 用法：Object.assign(target, ...sourceObj)</span><br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: &#123; <span class="hljs-attr">a</span>:<span class="hljs-string">&#x27;kobe&#x27;</span>, <span class="hljs-attr">b</span>:<span class="hljs-number">39</span> &#125;&#125;<br><span class="hljs-keyword">var</span> initalObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;,obj)<br>initalObj.<span class="hljs-property">a</span>.<span class="hljs-property">a</span> = <span class="hljs-string">&#x27;wade&#x27;</span><br>consoloe.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">a</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// &#x27;wade&#x27;</span><br><br>(<span class="hljs-number">2</span>)<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">concat</span>()<br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,&#123;<span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;kobe&#x27;</span>&#125;]<br><span class="hljs-keyword">let</span> arr2 = arr.<span class="hljs-title function_">concat</span>()<br>arr2[<span class="hljs-number">2</span>].<span class="hljs-property">username</span>=<span class="hljs-string">&#x27;wade&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">2</span>].<span class="hljs-property">username</span>) <span class="hljs-comment">// &#x27;wade&#x27;</span><br><br>(<span class="hljs-number">3</span>)<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">slice</span>()<br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,&#123;<span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;kobe&#x27;</span>&#125;]<br><span class="hljs-keyword">let</span> arr3 = arr.<span class="hljs-title function_">slice</span>()<br>arr2[<span class="hljs-number">2</span>].<span class="hljs-property">username</span>=<span class="hljs-string">&#x27;wade&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">2</span>].<span class="hljs-property">username</span>) <span class="hljs-comment">// &#x27;wade&#x27;</span><br><br>(<span class="hljs-number">4</span>) 拓展运算符(...) 用法：...object<br><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;zs&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">hobbies</span>:&#123; <span class="hljs-string">&#x27;eat&#x27;</span>,<span class="hljs-string">&#x27;sleep&#x27;</span>,<span class="hljs-string">&#x27;game&#x27;</span> &#125; &#125;<br><span class="hljs-keyword">const</span> obj2 = &#123; ...obj1 &#125;<br>obj2.<span class="hljs-property">hobbies</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;play&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">hobbies</span>[<span class="hljs-number">0</span>]) <span class="hljs-comment">// &#x27;play&#x27;</span><br></code></pre></td></tr></table></figure>

<h3 id="深拷贝实现方法："><a href="#深拷贝实现方法：" class="headerlink" title="深拷贝实现方法："></a>深拷贝实现方法：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-number">1</span>)<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>())<br><span class="hljs-comment">// 原理：用JSON.stringify()将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一来一去新的对象产生了，而对象会开辟新的栈，实现深拷贝，但是他不能处理函数</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,&#123;<span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;kobe&#x27;</span>&#125;]<br><span class="hljs-keyword">let</span> arr4 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(arr))<br>arr4[<span class="hljs-number">2</span>].<span class="hljs-property">username</span>=<span class="hljs-string">&#x27;wade&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">2</span>].<span class="hljs-property">username</span>) <span class="hljs-comment">// &#x27;kobe&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr4[<span class="hljs-number">2</span>].<span class="hljs-property">username</span>) <span class="hljs-comment">// &#x27;wade&#x27;</span><br>(<span class="hljs-number">2</span>)手写递归方法<br><span class="hljs-comment">// 原理：遍历对象、数组直到里边都是基本数据类型，再去复制</span><br><span class="hljs-comment">// 定义检测数据类型的功能阳数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkedType</span>(<span class="hljs-params">target</span>) &#123; returm <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(target).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8.</span>-<span class="hljs-number">1</span>) &#125;<br><span class="hljs-comment">//实现深度克隆---对象/数姐</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">target</span>) &#123;<span class="hljs-comment">//利断持贝的数据类型</span><br><span class="hljs-comment">//初始化变量result 成为最终克降的数据</span><br>	<span class="hljs-keyword">let</span> result, targetType = <span class="hljs-title function_">checkedType</span>(target)<br>	<span class="hljs-keyword">if</span>(tarketType === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>        result=&#123;&#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(targetType === <span class="hljs-string">&quot;Array&quot;</span>) &#123;<br>        result = []<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> target<br>    &#125;<br>	<span class="hljs-comment">// 遍历目标数据</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> target) &#123;<span class="hljs-comment">//获取玛历数据结构的每一项值。</span><br>        <span class="hljs-keyword">let</span> value = target[i]<span class="hljs-comment">//判断目标结构里的每一值是否存在对象/数组</span><br>        <span class="hljs-comment">//对象/数组里嵌套了对象/数组</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-title function_">chackedType</span>(value) === <span class="hljs-string">&quot;Object&quot;</span> || <span class="hljs-title function_">checkedType</span>(value) ===“<span class="hljs-title class_">Array</span><span class="hljs-string">&quot;)&#123; </span><br><span class="hljs-string">           //继续遍历获取到value值</span><br><span class="hljs-string">           result[i] = clone(value)</span><br><span class="hljs-string">    	&#125;else&#123; //获取到value值是基本的数据爱型或者是的数result[i] w walue;</span><br><span class="hljs-string">        	result[i] =  value</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">	&#125;</span><br><span class="hljs-string">	return rosult</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">(3)函数库lodash</span><br><span class="hljs-string">// lodash提供_.cloneDeep用来做深拷贝</span><br><span class="hljs-string">var _ = require(&#x27;lodash&#x27;)</span><br><span class="hljs-string">var obj1 = &#123;</span><br><span class="hljs-string">    a : 1,</span><br><span class="hljs-string">    b : &#123; f: &#123; g: 1 &#125; &#125;,</span><br><span class="hljs-string">    c: [1, 2, 3]</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">var obj2 = _.cloneDeep(obj1)</span><br><span class="hljs-string">console.log(obj1.b.f === obj2.b.f)</span><br></code></pre></td></tr></table></figure>

<h2 id="http请求？"><a href="#http请求？" class="headerlink" title="http请求？"></a>http请求？</h2><p>常用：get、push、put、delete</p>
<p>get和post区别：</p>
<ol>
<li>get是从服务器上获取数据，post是向服务器传送数据。</li>
<li>post比get安全。get传递的参数写在param里，会以查询字符串的方式拼接在url地址后面?key&#x3D;value。post传递的参数写在data里，携带在请求体里。</li>
<li>get方式需要使用Request.QueryString来取得变量的值，而post方式通过Request.Form来获取变量的值，也就是说get是通过地址栏来传值，而post是通过提交表单来传值。</li>
<li>get方式提交的数据字节数由浏览器或服务器限制，而post则没有此限制。</li>
</ol>
<h2 id="http状态码？"><a href="#http状态码？" class="headerlink" title="http状态码？"></a>http状态码？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 2xx（成功）表示成功处理了请求的状态代码。</span><br><span class="hljs-number">200</span>（成功）服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。<br><span class="hljs-number">201</span>（已创建）请求成功并且服务器创建了新的资源。<br><br><span class="hljs-comment">// 3xx（重定向）表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向。</span><br><span class="hljs-number">301</span>（永久移动）请求的网页已永久移动到新位置。服务器返回此响应（对<span class="hljs-variable constant_">GET</span>或<span class="hljs-variable constant_">HEAD</span>请求的响应）时，会自动将请求者转到新位置。<br><span class="hljs-number">302</span>（临时移动）服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br><span class="hljs-number">304</span>（未修改）自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。<br><br><span class="hljs-comment">// 4xx（客户端错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。</span><br><span class="hljs-number">400</span>（错误请求）服务器不理解请求的语法。<br><span class="hljs-number">401</span>（未授权）请求要求身份验证。对于需要登录的网页，服务器可能返回此响应。<br><span class="hljs-number">403</span>（禁止）服务器拒绝请求。<br><span class="hljs-number">404</span>（未找到）服务器找不到请求的网页。<br><span class="hljs-number">408</span>（请求超时）服务器等候请求时发生超时。<br><br><span class="hljs-comment">// 5xx（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</span><br><span class="hljs-number">500</span>（服务器内部错误）服务器遇到错误，无法完成请求。<br><span class="hljs-number">501</span>（尚未实施）服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。<br><span class="hljs-number">503</span>（服务不可用）服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。<br></code></pre></td></tr></table></figure>

<h2 id="http请求报文"><a href="#http请求报文" class="headerlink" title="http请求报文"></a>http请求报文</h2><p>http请求包括请求行、请求头、空行和请求体组成。</p>
<p>请求行包括请求方法、URL地址和协议版本，用空格隔开。</p>
<p>请求头用于指定服务器要使用的附加信息。请求头包括：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Accept</span>：向服务器申明客户端可以接收的媒体类型（<span class="hljs-variable constant_">MIME</span>）的资源<br><span class="hljs-title class_">Accept</span>-<span class="hljs-title class_">Encoding</span>：客户端所能够支持的压缩格式<br><span class="hljs-title class_">Accept</span>-<span class="hljs-title class_">Language</span>：指定http请求返回信息时优先选择的语言<br><span class="hljs-title class_">Connection</span>：是否需要持久连接<br><span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Length</span>：是请求体内容的长度<br><span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Type</span>：表示http请求提交的内容类型，只有在<span class="hljs-variable constant_">POST</span>方法提交时才需要设置此属性<br><span class="hljs-title class_">Cookie</span>：存放用户身份的数据<br><span class="hljs-title class_">Host</span>：请求地址<br><span class="hljs-title class_">User</span>-<span class="hljs-title class_">Agent</span>：记录客户端的详细信息<br></code></pre></td></tr></table></figure>

<p>空行就是用于分割POST请求的请求头和请求体。</p>
<p>请求体主要封装的是POST请求消息的请求参数。</p>
<h2 id="http响应报文"><a href="#http响应报文" class="headerlink" title="http响应报文"></a>http响应报文</h2><p>http请求包括状态行、响应头、空行和响应体组成。</p>
<p>状态行包括报文协议及版本、状态码以及状态描述。</p>
<p>响应头用于描述服务器的基本信息。</p>
<p>空行就是用于分割POST请求的响应头和响应体。</p>
<p>响应体主要存放服务器响应给客户端的资源内容。</p>
<h2 id="http和https协议"><a href="#http和https协议" class="headerlink" title="http和https协议"></a>http和https协议</h2><p>https协议的全称为Hypertext Transfer Protocol over Secure Socket Layer，它是以安全为目标的http通道，是http的“升级”版本。</p>
<p>https的安全基础是SSL，即在http下加入SSL层。也就是https通过安全传输机制进行传送数据，这种机制可保护网络传送的所有数据的隐秘性与完整性，可以降低非侵入性拦截攻击的可能性。</p>
<p>http协议与https协议的主要区别如下。</p>
<ol>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的SSL加密传输协议。</li>
<li>http与https协议使用的是完全不同的连接方式，http采用80端口连接，而https则是443端口。</li>
<li>https协议需要到ca 申请证书，一般免费证书很少，需要交费。而http协议却不需要。</li>
<li>http连接相对简单，是无状态的，而 https协议是由SSL+http协议构建的可进行加密传输、身份认证的网络协议，相对来说，它要比http协议更安全。</li>
</ol>
<h2 id="cookie、localStorage、sessionStorage的区别-袋鼠云笔试"><a href="#cookie、localStorage、sessionStorage的区别-袋鼠云笔试" class="headerlink" title="cookie、localStorage、sessionStorage的区别(袋鼠云笔试)"></a>cookie、localStorage、sessionStorage的区别(袋鼠云笔试)</h2><p>共同点:都是保存在浏览器端、且同源的</p>
<p>不同点：</p>
<p>1、存储位置不同：</p>
<p>cookie在浏览器和服务器间来回传递，cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下</p>
<p>sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。</p>
<p>2、存储大小限制不同：</p>
<p>cookie数据不能超过4K，sessionStorage和localStorage可以达到5M</p>
<p>3、保存数据有效时间不同：</p>
<p>sessionStorage：仅在当前浏览器窗口关闭之前有效；</p>
<p>localStorage：始终有效，窗口或浏览器关闭也一直保存，本地存储，因此用作持久数据；</p>
<p>cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭</p>
<p>作用域不同</p>
<h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>token的定义：Token是服务端生成的一串字符串，当作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token并将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</p>
<p>token认证流程：</p>
<p>token 的认证流程与cookie很相似</p>
<p>用户登录，成功后服务器返回Token给客户端。</p>
<p>客户端收到数据后保存在客户端</p>
<p>客户端再次访问服务器，将token放入headers中</p>
<p>服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</p>
<h2 id="后台管理系统中的权限管理是怎么实现的"><a href="#后台管理系统中的权限管理是怎么实现的" class="headerlink" title="后台管理系统中的权限管理是怎么实现的?"></a>后台管理系统中的权限管理是怎么实现的?</h2><p>登录：</p>
<p>当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个token，拿到token之后(将这个token存贮到cookie中，保证刷新页面后能记住用户登录状态)，前端会根据token再去拉取一个userinfo的接口来获取用户的详细信息(如用户权限，用户名等等信息)</p>
<p>权限验证：</p>
<p>通过token获取用户对应的权限，动态根据用户的权限算出其对应的路由，通过router.addRoutes 动态挂载这些路由。</p>
<p>具体思路：</p>
<p>登录成功后，服务端会返回一个token (该token的是一个能唯一标示用户身份的一个key)，之后我们将token存储在本地cookie之中，这样下次打开页面或者刷新页面的时候能记住用户的登录状态，不用再去登录页面重新登录了。</p>
<p>PS：为了保证安全性，我司现在后台所有token有效期(Expires&#x2F;Max-Age)都是Session，就是当浏览器关闭了就丢失了。重新打开游览器都需要重新登录验证，后端也会在每周固定一个时间点重新刷新token，让后台用户全部重新登录一次，确保后台用户不会因为电脑遗失或者其它原因被人随意使用账户。</p>
<p>用户登录成功之后，我们会在全局钩子router.beforeEach 中拦截路由，判断是否已获得token，在获得token之后我们就要去获取用户的基本信息了，页面会先从cookie 中查看是否存有 token，没有，就走一遍上一部分的流程重新登录，如果有token.就会把这个token 返给后端去拉取userinfo，保证用户信息是最新的。当然如果是做了单点登录功能的话，用户信息存储在本地也是可以的。当你一台电脑登录时，另一台会被提下线，所以总会重新登录获取最新的内容。</p>
<p>权限控制的主体思路：</p>
<p>前端会有一份路由表，它表示了每一个路由可访问的权限。当用户登录之后，通过 token 获取用户的role，动态根据用户的role 算出其对应有权限的路由，再通过router.addroutes动态挂载路由。但这些控制都只是页面级的，说白了前端再怎么做权限控制都不是绝对安全的，后端的权限验证是逃不掉的。</p>
<p>我司现在就是前端来控制页面级的权限，不同权限的用户显示不同的侧边栏和限制其所能进入的页面(也做了少许按钮级别的权限控制)，后端则会验证每一个涉及请求的操作，验证其是否有该操作的权限，每一个后台的请求不管是get还是post 都会让前端在请求 header里面携带用户的 token，后端会根据该 token 来验证用户是否有权限执行该操作。若没有权限则抛出一个对应的状态码，前端检测到该状态码，做出相对应的操作。</p>
<p>使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。</p>
<p>具体实现:</p>
<p>创建vue实例的时候将vue-router挂载，但这个时候vue-router挂载一些登录或者不用权限的公用的页面。</p>
<p>当用户登录后，获取用role，将role和路由表每个页面的需要的权限作比较，生成最终用户可访问的路由表。</p>
<p>调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由。</p>
<p>使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>Promise是ES6异步编程的一种解决方案，async和await是基于Promise的解决方案， Promise是一个对象或者说是构造函数，用来封装异步操作并可以获取其成功或失败的结果。</p>
<h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><p>ajax和axios请求。由于网速的不同，可能得到返回值的时间也是不同的，但是下一步要执行的代码依赖于上一次请求返回值，这个时候就需要等待，结果出来了之后才知道怎么样继续下去。</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>1.可以避免多层异步调用嵌套问题(回调地狱)</p>
<p>2.Promise 对象提供了简洁的API，使得控制异步操作更加容易</p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol>
<li>promise一旦新建就会立即执行，无法中途取消</li>
<li>当处于pending状态时，无法得知当前处于哪一个状态</li>
<li>如果不设置回调函数，promise内部的错误就无法反映到外部</li>
<li>promise封装ajax时，由于promise是异步任务，发送请求的三步会被延后到整个脚本同步代码执行完，并且将响应回调函数延迟到现有队列的最后，如果大量使用会大大降低了请求效率。</li>
</ol>
<h3 id="三种状态："><a href="#三种状态：" class="headerlink" title="三种状态："></a>三种状态：</h3><ol>
<li>pending：等待中，或者进行中，表示还没有得到结果</li>
<li>resolved(Fulfilled)：已经完成，表示得到了我们想要的结果，可以继续往下执行</li>
<li>rejected：也表示得到结果，但是由于结果并非我们所愿，因此拒绝执行</li>
</ol>
<p>这三种状态不受外界影响，而且状态只能从pending改变为resolved或者rejected，不可逆。</p>
<h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><p>1.promise的实例方法</p>
<ol>
<li><p>then()得到异步任务的正确结果；</p>
</li>
<li><p>catch()获取异常信息；</p>
</li>
<li><p>finally()成功与否都会执行(尚且不是正式标准)。</p>
</li>
</ol>
<p>注意：then方法可以接受两个函数，第一个函数为promise状态为成功的回调函数，第二个函数为promise状态为失败的回调函数(可以不写，一般用catch方法捕获promise状态为失败的异常信息)</p>
<p>2.promise的对象方法(p1,p2,p3为promise的实例对象)</p>
<ul>
<li>Promise.all()并发处理多个异步任务，所有任务都执行完成才能得到结果</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2, p3]) .<span class="hljs-property">then</span> ( <span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span> (result)<br>&#125;)<br></code></pre></td></tr></table></figure>

<ul>
<li>Promise.race()并发处理多个异步任务，只要有一个任务完成就能得到结果</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">race</span> ([p1, p2, p3]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>. <span class="hljs-title function_">log</span> (result)<br>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="Promise的特点"><a href="#Promise的特点" class="headerlink" title="Promise的特点"></a>Promise的特点</h3><ol>
<li><p>在Promise对象的构造函数中，将一个函数作为第一个参数。</p>
<ol>
<li>而Promise对象的构造函数的第一个参数中的这个函数，就是用来处理Promise的状态变化，这个函数的第一个参数表示promise的状态为成功，第二个参数表示promise的状态为失败，这两个参数(名字可以自己命名)都为一个函数，他们的作用分别是将promise状态修改为resolved(成功)和rejected(失败)。</li>
</ol>
</li>
<li><p>Promise对象中的then方法，可以接收构造函数中处理的状态变化，并分别对应执行。then方法有2个函数参数，第一个函数接收resolved(promise状态为成功)的执行，第二个函数接收reject(promise状态为失败)的执行。</p>
</li>
<li><p>promise的状态只能从 未完成-&gt;完成, 未完成-&gt;失败 且状态不可逆转。</p>
<ol>
<li>promise的异步结果，只能在完成状态时才能返回，而且我们在开发中是根据结果来选择状态的，然后根据状态来选择是否执行then()。</li>
<li>实例化的Promise内部会立即执行，then方法中的异步回调函数会在脚本中所有同步任务完成时才会执行。因此，promise的异步回调结果最后输出。</li>
</ol>
</li>
<li><p>Promise.then()方法</p>
<ol>
<li>then()函数返回的实际也是一个Promise对象(无论函数内部返回什么类型的数据，函数都会进行加工返回一个promise对象)</li>
<li>then()函数内部返回为普通值(非Promise类型的属性)，返回的普通值会直接传递给下一个then，通过then参数中函数的参数接收该值。这时then()函数返回的Promise对象状态为成功(resloved)，then()函数的返回值为对象的成功值，如return 123，返回的Promise对象值为123，如果没有返回值，是undefined。</li>
<li>当then()函数内部返回的是Promise类型的对象时，then()函数的返回的Promise对象的状态值为这个Promise对象的状态值，成功值也是如此，返回的该promise对象会调用下一个then方法。</li>
</ol>
</li>
<li><p>Promise.catch()方法</p>
<ol>
<li>catch()函数只有一个回调函数，意味着如果Promise对象状态为失败就会调用catch()方法并且调用回调</li>
</ol>
</li>
</ol>
<h3 id="async和await的区别"><a href="#async和await的区别" class="headerlink" title="async和await的区别"></a>async和await的区别</h3><p>async是来定义函数的，定义异步函数，打印函数名可以得到一个promise对象，言外之意可以通过这个函数名称调用.then这个方法</p>
<p>await后面跟的是任意表达式，一般使用promise的表达式</p>
<p>async内部实现，又返回值成功返回promise.resolve()，出错返回promise.reject()返回值用catch捕获</p>
<p>await等待后面的promise对象执行完毕，拿到了promise.resolve()的值之后，执行后面的代码。await后面的表达式，能是promise.reject()，所以建议await放在try….catch语句中</p>
<p>优点：async和await编写方便，提高程序效率，避免了回调地狱</p>
<p>补充：promise和async和await的区别</p>
<p>promise es6语法，promise中包含catch，async需要自己定义catch</p>
<p>promise提供的方法会多一些，all、race等方法，async中是没有的。</p>
<h2 id="Promise面试题以下代码的执行结果是？"><a href="#Promise面试题以下代码的执行结果是？" class="headerlink" title="Promise面试题以下代码的执行结果是？"></a>Promise面试题以下代码的执行结果是？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">//同步</span><br>    <span class="hljs-title function_">resolve</span>() <span class="hljs-comment">//执行.then()回调函数打印3</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">//同步</span><br>&#125;)<br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123; <span class="hljs-comment">//微任务</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>) <span class="hljs-comment">//同步</span><br><span class="hljs-comment">// 1 2 4 3</span><br></code></pre></td></tr></table></figure>

<p>解释：以上考察的是关于promise的原理，promise的构造函数本身是同步执行的，当newPromise的一瞬间，1,2就立刻被执行，而.then方法是异步执行的，当执行完1和2之后，会执行输出4，最后执行输出3</p>
<h2 id="一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么"><a href="#一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么" class="headerlink" title="一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么?"></a>一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么?</h2><ol>
<li>浏览器查找域名对应的IP地址(DNS查询:浏览器缓存-系统缓存路由器缓存-ISPDNS缓存-&gt;根域名服务器)</li>
<li>浏览器向Web 服务器发送一个HTTP请求(TCP三次握手)</li>
<li>服务器301 重定向 (从<a href="http://example.com/">http://example.com</a> 重定向到 <a target="_blank" rel="noopener" href="http://www.example.com/">http://www.example.com</a>)</li>
<li>浏览器跟踪重定向地址，请求另一个带www的网址</li>
<li>服务器处理请求(通过路由读取资源)</li>
<li>服务器返回一个HTTP 响应(报头中把 Content-type设置为text&#x2F;html)</li>
<li>浏览器进DOM 树构建</li>
<li>浏览器发送请求获取嵌在HTML中的资源(如图片、音频、视频、CSSJS等)</li>
<li>浏览器显示完成页面</li>
<li>浏览器发送异步请求</li>
</ol>
<h2 id="跨域是什么-如何解决跨域问题"><a href="#跨域是什么-如何解决跨域问题" class="headerlink" title="跨域是什么? 如何解决跨域问题?"></a>跨域是什么? 如何解决跨域问题?</h2><p>跨域:当前页面中的某个接口请求的地址和当前页面的地址如果协议、域名、端口其中有一项不同，就说该接口跨域了。</p>
<p>跨域限制的原因:浏览器为了保证网页的安全，出的同源协议策略。</p>
<p>跨域解决方案: </p>
<ol>
<li><p>cors：目前最常用的一种解决办法，通过设置后端允许跨域实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>,*);<br>res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span> <span class="hljs-string">&quot;GET,PUT,OPTIONS,POST&quot;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>jsonp：浏览器端通过script标签的src属性，请求服务器端的数据，同时服务器端返回一个函数的调用。</p>
<p>特点：</p>
<p>(1)不属于真正的Ajax请求，因为没有使用XMLHttpRequest这个对象</p>
<p>(2)只支持get请求。</p>
</li>
<li><p>node中间件、nginx反向代理：</p>
<p>跨域限制的时候浏览器不能跨域访问服务器，node中间件和nginx反向代理，都是让请求发给代理服务器，静态页面和代理服务器是同源的，然后代理服务器再向后端服务器发请求，服务器和服务器之间不存在同源限制。</p>
</li>
<li><p>postmessage：</p>
<p>H5新增API，通过发送和接收API实现跨域通信。</p>
<p>跨域场景:前后端分离式开发、调用第三方接口</p>
</li>
</ol>
<h2 id="项目性能优化方案"><a href="#项目性能优化方案" class="headerlink" title="项目性能优化方案"></a>项目性能优化方案</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">减少http请求<br>减少<span class="hljs-variable constant_">DNS</span>查询<br>使用<span class="hljs-variable constant_">CDN</span>加载静态资源文件和<span class="hljs-variable constant_">JS</span>库<br>避免重定向<br>图片懒加载<br>路由懒加载(<br>目的：为了让第一个页面，加载的app.<span class="hljs-property">js</span>小一点，打开网页快一点<br>思路：把组件对应js分成若干个.<span class="hljs-property">js</span> 路由切换到哪个页面再加载对应的.<span class="hljs-property">js</span>文件<br>原因：webpack分析入口时，发现router上来就<span class="hljs-keyword">import</span>所有页面，所有直接打包app.<span class="hljs-property">js</span>很大<br>解决：当路由路径匹配规则时，才去<span class="hljs-keyword">import</span>引入对应的组件js文件)<br>减少<span class="hljs-variable constant_">DOM</span>元素操作<br>使用外部js和css<br>压缩js、css、字体、图片等<br>使用iconfont字体图标、雪碧图(sprit精灵图)等<br>避免图片的src为空<br>把样式表放在link中<br>把js放在页面的底部<br></code></pre></td></tr></table></figure>

<h2 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h2><p>问题：</p>
<p>大型网站如常用的淘宝，京东等页面，需要展示大量的商品图片信息，如果打开网页时让所有图片一次性加载完成，需要处理很多次网络请求，等待加载时间比较长，用户体验感很差。</p>
<p>解决方式：</p>
<p>随着滚动动态加载，即图片的惰性加载。视图之外的图片默认不加载，随着页面的滚动，图片进入了显示的范围，则触发图片的加载显示。</p>
<p>优点：页面加载速度快，用户体验感更好且节省流量</p>
<p>原理方法：</p>
<p>初始化时，图片标签的src不能是真实的图片地址，也不可以是空地址或者坏地址(会出现图片加载失败的图标)。</p>
<ol>
<li><p>1、初始化的时候，可以设置图片的src是某一个小型图片。例如一张1px*1px的透明图片。由于所有图片都使用这一张图片，只会发送一次请求，不会增加性能负担。</p>
</li>
<li><p>2、将图片的真实路径绑定给一个自定义属性，例如data-url。注意：页面的img元素，如果没有src属性，浏览器就不会发出请求去下载图片。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;1px.gif&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>定义滚动事件，当元素进入视口，则将src替换为真正的url地址。利用js提取data-url的真实图片地址赋值给src属性。</p>
</li>
</ol>
<p>实现方法：</p>
<p>图片懒加载的关键在于获取元素的位置，并判断其是否出现在视口。故有以下两种方式</p>
<p>滚动监听+scrollTop+offsetTop+innerHeight</p>
<p>jquery插件库EasyLazyload</p>
<p>3.1 滚动监听+scrollTop+offsetTop+innerHeight</p>
<p>scrollTop：指网页元素被滚动条卷去的部分。</p>
<p>offsetTop：元素相对父元素的位置</p>
<p>innerHeight：当前浏览器窗口的大小。需要注意兼容性问题。</p>
<p>IE8及更早版本以前没有提供取得浏览器窗口大小的属性，不过提供了API：document.documentElement.clientHeight&#x2F;clientWidth：返回元素内容及其内边距所占据的空间大小。</p>
<p>当scrollTop+innerHeight &gt; offsetTop，即图片在视口内，否则图片在可视区域外。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">scrollTop：指网页元素被滚动条卷去的头部。<br>scrollLeft：指网页元素被滚动条卷去的左边。<br>offsetTop：元素相对父元素上边界的距离<br>offsetWidth：元素相对父元素左边界的距离<br><span class="hljs-attr">clientLeft</span>: 该元素对象左边框的宽度<br><span class="hljs-attr">clientWidth</span>: 该元素对象左内边框到右内边框的宽度<br><span class="hljs-attr">offsetLeft</span>: 该左边框到窗口左边界的距离<br><span class="hljs-attr">offsetWidth</span>: 该元素对象左外边框到右外边框的宽度<br>clientX/clientY：当事件触发时鼠标指针相对于可视区域左边界的x,y坐标<br>pageX/pageY：当事件触发时鼠标指针相对于可视区域左边界的x,y坐标<br>screenX/screenY：点击位置距离电脑屏幕的x,y坐标<br>offsetX/offsetY：相对于带有定位的父盒子的x,y坐标<br></code></pre></td></tr></table></figure>

<h2 id="获取浏览器url中查询字符串的参数"><a href="#获取浏览器url中查询字符串的参数" class="headerlink" title="获取浏览器url中查询字符串的参数"></a>获取浏览器url中查询字符串的参数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">geturlpara</span>(<span class="hljs-params">sHref</span>) &#123;<br>    <span class="hljs-comment">//获取向号</span><br>    <span class="hljs-keyword">var</span> args = shref.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;?&quot;</span>);<br>    <span class="hljs-comment">//无传入参数</span><br>    <span class="hljs-keyword">if</span>(args[<span class="hljs-number">0</span>] == sHref) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-comment">//对?后的参数进行处理</span><br>    <span class="hljs-keyword">var</span> arr = args[<span class="hljs-number">1</span>].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&amp;&quot;</span>);<br>    <span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;arr.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">var</span> arg = arr[i].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;=&quot;</span>);<br>        obj[arg[<span class="hljs-number">0</span>]] =arg[<span class="hljs-number">1</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Set和Map"><a href="#Set和Map" class="headerlink" title="Set和Map"></a>Set和Map</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值（对象或者基本类型）都可以作为一个键或一个值。Map 对象是一个构造函数，所以我们在初始化的时候可以传入默认数据的，只不过我们需要注意传入默认数据的格式，它默认接收一个二维数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> defaultMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;zs&#x27;</span>],[<span class="hljs-string">&#x27;age&#x27;</span>,<span class="hljs-number">20</span>]])<br><span class="hljs-comment">// Map(2) &#123; &#x27;name&#x27; =&gt; &#x27;zs&#x27;, &#x27;age&#x27; =&gt; 20 &#125;</span><br><span class="hljs-comment">// 0: &#123; &#x27;name&#x27; =&gt; &#x27;zs&#x27; &#125; key:&#x27;name&#x27;, value:&#x27;zs&#x27;</span><br><span class="hljs-comment">// 1: &#123; &#x27;age&#x27; =&gt; 20 &#125; key:&#x27;age&#x27;, value: 20</span><br></code></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>Map 对象这种数据结构和和对象类型，都已键值对的形式存储数据，即 key-value 形式。</li>
<li>Map 对象存储的数据是有序的，而我们平常使用的对象是无序的，所以通常当我们需要使用对象形式（键值对）存储数据且需要有序时，采用 Map 对象进行存储。</li>
<li>Map 对象的键值可以是任意类型，我们平时使用的对象只能使用字符串作为键。</li>
</ol>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set对象是值的集合，你可以按照插入的顺序迭代它的元素。Set 中的元素只会出现一次，即 Set 中的元素是唯一的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> defaultSet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-number">12</span>,<span class="hljs-literal">true</span>])<br><span class="hljs-title class_">Set</span>(<span class="hljs-number">3</span>) &#123;<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-number">12</span>, <span class="hljs-literal">true</span>&#125;<br><span class="hljs-comment">// [[Entries]]</span><br><span class="hljs-comment">// 0: &quot;name&quot;</span><br><span class="hljs-comment">// 1: 12</span><br><span class="hljs-comment">// 2: true</span><br><span class="hljs-comment">// size: 3</span><br></code></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>Set 对象是一个伪数组对象。</li>
<li>Set 对象存储的值是不重复的，所以我们通常使用它来实现数组去重。</li>
<li>Set 对象存储的数据不是键值对的形式，而且它可以存储任何类型的数据。</li>
</ol>
<h3 id="Map和Set区别："><a href="#Map和Set区别：" class="headerlink" title="Map和Set区别："></a>Map和Set区别：</h3><ol>
<li><p>Map和Set查找速度都非常快，时间复杂度为O(1)，而数组查找的时间复杂度为O(n)。</p>
<p>(Map和Set存储的所有元素都是以节点的方式来进行存储的，这种节点结构和链表有点类似。我们都知道链表的特点是插入和删除都非常快，时间复杂度为O(1)，两个节点通过指针相连，删除或者增加元素时，我们只是重新更改了指针的指向，不想数组那样，掺入或删除之后需要重新排序)</p>
</li>
<li><p>Map对象初始化的值为一个二维数组，Set对象初始化的值为一维数组。</p>
</li>
<li><p>Map对象和Set对象都不允许键重复（可以将Set对象的键想象成值）。</p>
</li>
<li><p>Map对象的键是不能改的，但是值能改，Set对象只能通过迭代器来更改值。</p>
</li>
</ol>
<p>使用场景：</p>
<p>Set：使用Set对象的唯一性值特性给数组去重，需要注意的是Set对象是一个类数组，使用…扩展运算符将一个类数组转化为了一个真正的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)]) <span class="hljs-comment">// [1,2,3,4,5]</span><br></code></pre></td></tr></table></figure>

<p>Map：使用Map对象建立一个请求状态码对象字典，因为状态码是数字类型，所以使用Map对象很合适。除了该场景外，如果需要保证对象的顺序，那么也是可以使用Map对象的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> errors=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>    [<span class="hljs-number">400</span>, <span class="hljs-string">&#x27;InvaildParameter&#x27;</span>],<br>    [<span class="hljs-number">404</span>, <span class="hljs-string">&#x27;Not found&#x27;</span>],<br>    [<span class="hljs-number">500</span>, <span class="hljs-string">&#x27;InternalError&#x27;</span>]<br>])<br><span class="hljs-comment">// 0: &#123; 400 =&gt; &#x27;InvaildParameter&#x27; &#125;</span><br><span class="hljs-comment">// 1: &#123; 404 =&gt; &#x27;Not found&#x27; &#125;</span><br><span class="hljs-comment">// 2: &#123; 500 =&gt; &#x27;InternalError&#x27; &#125;</span><br></code></pre></td></tr></table></figure>

<h2 id="JS获取DOM元素的方法"><a href="#JS获取DOM元素的方法" class="headerlink" title="JS获取DOM元素的方法"></a>JS获取DOM元素的方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">返回的<span class="hljs-title class_">NodeList</span>对象都属于伪数组，也称为类数组<br>getElementsByName 获取符合name属性的元素结合<br>getElementsByClassName 获取符合<span class="hljs-keyword">class</span>属性的元素结合<br>querySelectorAll 获取符合选择器要求的元素结合<br>getElementsByTagName 获取符合标签名的元素结合<br><br>获取到的是单个元素<br>getElementById 获取符合id要求的元素<br>querySelector 获取符合选择器要求的第一个元素<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span> 获取body元素对象<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span> 获取html元素对象<br></code></pre></td></tr></table></figure>

<h2 id="HTML5自定义属性"><a href="#HTML5自定义属性" class="headerlink" title="HTML5自定义属性"></a>HTML5自定义属性</h2><p>设置自定义属性 element.setAttribute(‘data-属性’，值)</p>
<p>获取自定义属性 element.getAttribute(‘data-属性’)&#x2F;element.dataset.属性&#x2F; element.dataset[‘属性’]</p>
<p>dataset是一个存放了所有以data-开头的自定义属性的集合</p>
<h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><p>节点Node至少拥有nodetype，nodeName，nodeValue三个基本属性</p>
<p>元素节点 nodetype 1</p>
<p>属性节点 nodetype 2</p>
<p>文本节点 nodetype 3</p>
<p>节点操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js">获取父节点：node.<span class="hljs-property">parentNode</span> 得到的是离元素最近的父级节点。注意：如果找不到父节点就返回为<span class="hljs-literal">null</span>。<br><br>子节点操作<br>node.<span class="hljs-property">childNodes</span> (获取所有的子节点 包含 元素节点 文本节点等等)<br>node.<span class="hljs-property">childNode</span>[i] (获取第i-<span class="hljs-number">1</span>个子节点)<br>node.<span class="hljs-property">children</span> (获取所有的子元素节点)（常用）<br>node.<span class="hljs-property">children</span>[i] (获取第i-<span class="hljs-number">1</span>个子元素节点)（常用，没有兼用性问题）<br>node.<span class="hljs-property">firstChild</span>（第一个子节点 不管是文本节点还是元素节点）<br>node.<span class="hljs-property">lastChild</span>（最后一个子节点 不管是文本节点还是元素节点）<br>node.<span class="hljs-property">firstElementChild</span>（第一个子元素节点，ie9才支持）<br>node.<span class="hljs-property">lastElementChild</span>（最后一个子元素节点，ie9才支持）<br><br>兄弟节点操作<br>node.<span class="hljs-property">nextSibling</span> (下一个兄弟节点 包含元素节点或者 文本节点等等)<br>node.<span class="hljs-property">previousSibling</span> (上一个兄弟节点 包含元素节点或者 文本节点等等)<br>node.<span class="hljs-property">nextElementSibling</span> （得到下一个兄弟元素节点）<br>node.<span class="hljs-property">previousElementSibling</span> （得到上一个兄弟元素节点,如果不存在，则返回<span class="hljs-literal">null</span>）<br><br>创建节点：<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(‘tagName’)<br><br>添加节点：<br>(<span class="hljs-number">1</span>)node.<span class="hljs-title function_">appendChild</span>(child) 其中node父级，child是子级 后面追加元素，此操作类似数组中的push；<br>(<span class="hljs-number">2</span>)node.<span class="hljs-title function_">insertBefore</span>(child, 指定元素) 该方法是将节点添加到指定元素的前面。<br><br>删除节点操作：<br>删除节点：node.<span class="hljs-title function_">removeChild</span>(child)<br><br>复制节点操作：<br>浅拷贝：node.<span class="hljs-title function_">cloneNode</span>() 浅拷贝的意思是只复制标签不复制里面的内容<br>深拷贝：node.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>) 深拷贝的意思是复制标签以及里面的内容<br></code></pre></td></tr></table></figure>



<h2 id="websocket和http"><a href="#websocket和http" class="headerlink" title="websocket和http"></a>websocket和http</h2><p>相同点</p>
<p>1、都是一样基于TCP的，都是可靠性传输协议。</p>
<p>2、都是应用层协议。</p>
<p>区别：</p>
<p>1、WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息，而HTTP是单向的；</p>
<p>2、WebSocket是需要浏览器和服务器握手进行建立连接的，而http是浏览器发起向服务器的连接。</p>
<h2 id="JavaScript的全局函数"><a href="#JavaScript的全局函数" class="headerlink" title="JavaScript的全局函数"></a>JavaScript的全局函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">编码相关：<br><span class="hljs-built_in">escape</span>()、<span class="hljs-built_in">unescape</span>()、<span class="hljs-built_in">encodeURI</span>()、<span class="hljs-built_in">decodeURI</span>()、<br><span class="hljs-built_in">encodeURIComponent</span>()、<span class="hljs-built_in">decodeURIComponent</span>()<br><br>数据处理：  <br><span class="hljs-title class_">Number</span>()、<span class="hljs-title class_">String</span>()<br><br>数字相关：<br><span class="hljs-built_in">isFinite</span>()、<span class="hljs-built_in">isNaN</span>()、<span class="hljs-built_in">parseFloat</span>()、<span class="hljs-built_in">parseInt</span>()<br><br>特殊：<br><span class="hljs-built_in">eval</span>()<br></code></pre></td></tr></table></figure>

<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="MVC和MVVM的区别"><a href="#MVC和MVVM的区别" class="headerlink" title="MVC和MVVM的区别"></a>MVC和MVVM的区别</h2><p>MVC是Model-View- Controller的简写，即模型-视图-控制器。</p>
<p>Model：模型，指的是后端传递的数据。</p>
<p>View：视图层，用户所看到的页面。</p>
<p>Controller：控制器，页面业务逻辑。</p>
<p>View传送指令到Controller，Controller完成业务逻辑后，要求Model改变状态，Model将新的数据发送到View，用户得到反馈。</p>
<p>MVC是单向通信。</p>
<p>MVC的优点：</p>
<p>1耦合度低，视图层和业务层分离</p>
<p>2重用度高</p>
<p>3生命周期成本低</p>
<p>4可维护性高</p>
<p>5部署快</p>
<p>MVC的缺点：</p>
<p>1前后端无法独立开发，必须等后端接口做好了才可以往下走；前端没有自己的数据中心，太过依赖后台。（视图与控制器间的过于紧密的连接：视图和业务逻辑没有完全分离）</p>
<p>2 View更新的时候，必须要通过Controller去更新一遍Model；同样的Model更新的时候，也要去更新一遍视图。此时开发者是在同时维护View层和Model层。当页面复杂的时候，开发者不得不做许多繁琐的工作来保证数据的状态、页面的展示都是正确的。（频繁手动操作dom）</p>
<p>MVC的应用：主要用于中大型项目的分层开发。</p>
<p>MVVM：</p>
<p>Model：模型，指的是后端传递的数据。</p>
<p>View：视图，指的是所看到的页面。</p>
<p>ViewModel：视图模型，mvvm模式的核心，它是连接view和model的桥梁。主要用来处理业务逻辑</p>
<p>MVVM的特点： </p>
<p>MVVM框架下，视图和模型是不能直接通信的，它们通过ViewModal来通信。</p>
<p>当数据源发生变化时，会被VM监听到，VM根据最新的数据源自动更新页面结构；</p>
<p>当表单元素的值发生变化时，也会被VM监听到，VM会把变化后最新的值自动同步到Model数据源中。</p>
<p>MVVM的优点：</p>
<p>MVVM模式的主要目的是分离视图（View）和模型（Model），有几大优点：</p>
<p>1低耦合，视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</p>
<p>2可重用性，可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</p>
<p>3可测试，界面向来是比较难于测试的，而现在测试可以针对ViewModel来写</p>
<p>4双向数据绑定，它实现了View和Model的自动同步，当Model的属性改变时，不需要手动操作Dom元素，来改变View的显示，而是改变属性后该属性对应View层显示会自动改变。</p>
<p>MVVM适用场景： </p>
<p>适合数据驱动的场景，数据操作比较多的场景</p>
<p>MVVM与MVC区别：</p>
<p>1 MVVM实现了View和Model的自动同步（双向数据绑定），也就是当Model的属性改变时，我们不用再自己手动操作Dom元素，来改变View的显示，而是改变属性后该属性对应View层显示会自动改变(自动更新 dom)。</p>
<p>2 MVVM并不是VM完全取代了C，只是在MVC的基础上增加了一层VM，只不过是弱化了C的概念，ViewModel存在目的在于抽离Controller中展示的业务逻辑，而不是替代Controller，其它视图操作业务等还是应该放在Controller中实现。也就是说MVVM实现的是业务逻辑组件的复用，使开发更高效，结构更清晰，增加代码的复用性。</p>
<h2 id="Vue2-0-响应式原理与缺陷"><a href="#Vue2-0-响应式原理与缺陷" class="headerlink" title="Vue2.0 响应式原理与缺陷?"></a>Vue2.0 响应式原理与缺陷?</h2><p>Vue响应式指的是: 组件的data发生变化立刻触发视图的更新</p>
<p>原理：Vue采用数据劫持结合发布者-订阅者模式的方式来实现数据的响应式，通过Object.defineProperty来劫持数据的setter，getter，在数据变动时发布消息给订阅者，订阅者收到消息后进行相应的处理。 通过原生js提供的监听数据的API，当数据发生变化的时候，在回调函数中修改dom。</p>
<p>核心API: </p>
<p>Object.defineProperty (操作的对象，属性，{get(){} set(){} })</p>
<p>Object.definePropertyAPI的使用</p>
<p>作用:用来定义对象属性</p>
<p>特点:默认情况下定义的数据的属性不能修改描述属性和存取属性不能同时使用，使用会报错</p>
<p>响应式原理: 获取属性值会触发getter方法，设置属性值会触发setter方法，在setter方法中调用修改dom的方法。</p>
<p>Object.defineProperty的缺点（也是为熊数据变了，视图没变的原因） </p>
<p>1.深度监听需要一次性递归，一次性递归到底开销很大，如果数据很大，大量的递归导致调用栈溢出</p>
<p>2.不能监听对象的新增属性和删除属性，</p>
<p>3.无法监控到数组下标的变化，通过数组下标修改元素，无法实时响应</p>
<p>4.无法正确的监听数组的方法。</p>
<h2 id="Vue双向数据绑定原理"><a href="#Vue双向数据绑定原理" class="headerlink" title="Vue双向数据绑定原理"></a>Vue双向数据绑定原理</h2><p>v-model指令和.sync修饰符可以实现数据的双向绑定</p>
<p><strong>v-model****本质：</strong>给所在标签绑定:value&#x3D;“Vue变量” @input&#x3D;“val &#x3D;&gt; Vue变量 &#x3D; val”</p>
<p>&lt;标签 v-model&#x3D;“Vue变量” &gt;&lt;&#x2F;标签&gt;</p>
<p>运行时</p>
<p>&lt;标签 :value&#x3D;“Vue变量” @input&#x3D;“val &#x3D;&gt; Vue变量&#x3D;val”&gt;&lt;&#x2F;标签&gt;</p>
<p>子组件内子传父的时候 this.$emit(‘input’, 值)</p>
<p>Vue2中里面一个标签上v-model只能用一次，Vue3里可以用多次.sync修饰符</p>
<p><strong>.sync****本质</strong>：给所在标签绑定:props属性名&#x3D;“Vue变量” @update:props属性名&#x3D;“val &#x3D;&gt; Vue变量 &#x3D; val”</p>
<p>&lt;标签 :visible.sync&#x3D;“Vue变量” &gt;&lt;&#x2F;标签&gt;</p>
<p>运行时</p>
<p>&lt;标签 :visible&#x3D;“Vue变量” @update:visible&#x3D;“val &#x3D;&gt; Vue变量&#x3D;val”&gt;&lt;&#x2F;标签&gt;</p>
<p>子组件内子传父的时候 this.$emit(‘update:visible’, 值)</p>
<h2 id="Vue中为什么数据变了，视图没变？"><a href="#Vue中为什么数据变了，视图没变？" class="headerlink" title="Vue中为什么数据变了，视图没变？"></a>Vue中为什么数据变了，视图没变？</h2><p>(1) 我们在开发过程中会碰到数据更新，但是视图并未改变的情况，情况如下：</p>
<p>第一种:动态给对象新增属性或者删除属性是不会触发视图刷新的,Vue识别不到；</p>
<p>第二种:通过数组下标修改数组中的元素或者手动修改数组的长度或者使用了不改变原数组的方数组法,Vue识别不到；</p>
<p>(2) 如何解决？</p>
<p>解决方法1：静默刷新(使用v-if的特性)</p>
<p>在修改值之后将元素销毁，然后在修改后的下一次DOM渲染完成时再显示出来，这样就会触发组件重新加载data的数据进行渲染,data中被修改的数据才是最新的。</p>
<p>解决方法2：Vue. $set(官方推荐)</p>
<p>使用这个api修改的数据会为其添加响应式getter和setter让其拥有数据响应的特性</p>
<p>Vue.$set (要操作的对象或者数组，要增加或者修改的数组或对象key，对应的值)</p>
<p>解决方法3：Vue.$forceUpdate()手动强制更新视图</p>
<p>因为Vue修改数据是异步执行的,所以视图不会立即更新,会等到下一次dom更新循环结束后统一更新发生在这一次循环中修改的数据,然后同步视图更新,所以我们可以修改后自己手动强制更新视图。</p>
<p>解决方法4：Object.assign(使用修改栈能触发视图更新的特性)</p>
<p>我们都知道Object.assign能拷贝合成一个新对象,所以我们只需要将要修改的值合并成一个新对象然后赋值给data中的对象或数组,这样栈的指向被修改了，触发视图更新</p>
<p>解决方法5:对于数组还可以使用splice方法</p>
<p>(Vue对于数组的操作能识别变化的方法包括push(), pop(), shift(), unshift(), splice(), sort(), reverse()这些都可被vue监测到)</p>
<p>​                                 </p>
<h2 id="vue中的data为什么是一个函数？（面试常问）"><a href="#vue中的data为什么是一个函数？（面试常问）" class="headerlink" title="vue中的data为什么是一个函数？（面试常问）"></a>vue中的data为什么是一个函数？（面试常问）</h2><p>Vue中的data必须是个函数，因为当data是函数时，组件实例化的时候这个函数将会被调用，返回一个对象，计算机会给这个对象分配一个内存地址，实例化几次就分配几个内存地址，他们的地址都不一样，所以每个组件中的数据不会相互干扰，改变其中一个组件的状态，其它组件不变。</p>
<p>简单来说，就是为了保证组件的独立性和可复用性，如果data是个函数的话，每复用一次组件就会返回新的data，类似于给每个组件实例创建一个私有的数据空间，保护各自的数据互不影响</p>
<h2 id="Vuex是什么，每个属性是干嘛的"><a href="#Vuex是什么，每个属性是干嘛的" class="headerlink" title="Vuex是什么，每个属性是干嘛的"></a>Vuex是什么，每个属性是干嘛的</h2><p>定义：专门为Vue.js应用程序开发的状态管理模式，它采用集中式存储管理数据，以相应的规则保证状态，以一种可预测的方式发生变化。</p>
<p>vuex各个属性概念：（Vuex是集中管理项目公共数据的）</p>
<p>为什么要学？</p>
<p>非父子组件之间的通信</p>
<p>数据同步、集中管理、数据有迹可循、数据状态可追踪</p>
<p>Vuex中存的什么？</p>
<p>多个组件共享状态</p>
<p>Vue属性：</p>
<p>state属性：用来存储公共管理的数据。 </p>
<p>mutations 属性：定义改变state中数据的方法，注意:不要在mutation中的方法中写异步方法ajax，那样数据就不可跟踪了。</p>
<p>getters 属性：定义 store 的计算属性。就像计算属性一样，getter的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 </p>
<p>actions属性：类似于mutations，不同点：Actions提交的是mutations，而不是直接变更状态。actions可以包含任意异步操作。</p>
<p>moudle属性：将store分割成模块。每个模块拥有自己的state、mutation、action、getter、甚至是嵌套子模块从上至下进行同样方式的分割。</p>
<p>直接使用方法: </p>
<p>state：直接以对象方式添加属性this.$store.state.变量名</p>
<p>mutations：通过this.$store.commit(“mutations里函数名”, 具体值)调用</p>
<p>actions：通过this.$store.dispatch(“actions里函数名”)触发</p>
<p>getters：直接通过this.$store.getters.计算属性名调用</p>
<p>映射使用方法：</p>
<p>state: …mapState(“state里变量名”), 写在computed里面, 原地留下一个计算属性</p>
<p>mutations: …mapMutations([“mutations里函数名”]), 写在methods里面，原地留下一个方法</p>
<p>actions: …mapAction([“actions里函数名”]), 写在methods里面，原地留下一个方法</p>
<p>getters: …mapGetters([“变量名”]), 写在computed里面, 原地留下一个计算属性</p>
<h2 id="生命周期-袋鼠云笔试"><a href="#生命周期-袋鼠云笔试" class="headerlink" title="生命周期(袋鼠云笔试)"></a>生命周期(袋鼠云笔试)</h2><h3 id="beforeCreate（创建前）"><a href="#beforeCreate（创建前）" class="headerlink" title="beforeCreate（创建前）"></a>beforeCreate（创建前）</h3><p>这个时候，在实例被完成创建出来，el和data都没有初始化，不能访问data、method，一般在这个阶段不进行操作。</p>
<h3 id="created（创建后）"><a href="#created（创建后）" class="headerlink" title="created（创建后）"></a>created（创建后）</h3><p>这个时候，vue实例中的data、method已被初始化，属性也被绑定，但是此时还是虚拟dom，真实dom还没生成，$el还不可用。这个时候可以调用data和method的数据及方法，created钩子函数是最早可以调用data和method的，故一般在此对数据进行初始化。</p>
<h3 id="beforeMount（挂载前）"><a href="#beforeMount（挂载前）" class="headerlink" title="beforeMount（挂载前）"></a>beforeMount（挂载前）</h3><p>此时模板已经编译完成，但还没有被渲染至页面中（即为虚拟dom加载为真实dom），此时el存在则会显示el。在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取。</p>
<p>当vue实例中，el为挂载目标，未对el进行定义，则this.el显示undefined，但页面中存在template也能识别挂载目标，因为template可以被看成占位符。如果对其进行定义则显示<div id="app"></div>，故所以，beforeMount读取不了真实的el，在mounted才能读取到真实的el，因为el只有渲染完成后才会存在。这里讲的el是真实的el。在真实的el之前存在前，在beforeMount中的其实是页面中的#app，是挂载的目标。</p>
<h3 id="mounted（挂载后）"><a href="#mounted（挂载后）" class="headerlink" title="mounted（挂载后）"></a>mounted（挂载后）</h3><p>此时模板已经被渲染成真实DOM，用户已经可以看到渲染完成的页面，页面的数据也是通过双向绑定显示data中的数据。 这实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时，如果没有其它操作的话，这个实例，就静静的躺在我们的内存中，一动不动。</p>
<h3 id="beforeUpdate（更新前）"><a href="#beforeUpdate（更新前）" class="headerlink" title="beforeUpdate（更新前）"></a>beforeUpdate（更新前）</h3><p>更新前状态（view层的数据变化前，不是data中的数据改变前），重新渲染之前触发，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染。只有view上面的数据变化才会触发beforeUpdate和updated，仅属于data中的数据改变是并不能触发。</p>
<h3 id="updated（更新后）"><a href="#updated（更新后）" class="headerlink" title="updated（更新后）"></a>updated（更新后）</h3><p>数据已经更改完成，dom也重新render完成。</p>
<h3 id="beforeDestroy（销毁前）"><a href="#beforeDestroy（销毁前）" class="headerlink" title="beforeDestroy（销毁前）"></a>beforeDestroy（销毁前）</h3><p>销毁前执行（$destroy方法被调用的时候就会执行）,一般在这里善后:清除计时器、清除非指令绑定的事件等等…’)</p>
<h3 id="destroyed（销毁后）"><a href="#destroyed（销毁后）" class="headerlink" title="destroyed（销毁后）"></a>destroyed（销毁后）</h3><p>销毁后(Dom元素存在，只是不再受vue控制), 卸载watcher，事件监听，子组件</p>
<h2 id="v-if和v-show的区别"><a href="#v-if和v-show的区别" class="headerlink" title="v-if和v-show的区别"></a>v-if和v-show的区别</h2><p>v-if是通过添加和删除元素来进行显示或者隐藏</p>
<p>v-show是通过操作DOM修改display样式来修改元素的显示和隐藏</p>
<p>如果需要频繁的进行元素的显示和隐藏使用v-show性能更好</p>
<h2 id="scoped相关知识"><a href="#scoped相关知识" class="headerlink" title="scoped相关知识"></a>scoped相关知识</h2><p>scoped属性作用：让style里的选择器，只能选中当前组件的标签（为了保证样式的独立性，不影响别的组件）或者vue组件中，在style标签上添加scoped属性，表示它的样式只对当前组件生效，不会影响全局的样式，很好的实现了样式私有化的目的。</p>
<p>scoped原理：webpack打包的时候，会给组件标签上添加相同data-v-hash值，然后也会给所有选择器后面加上一个[data-v-hash]值的属性选择器（即：多加了一个data-v的属性选择器）</p>
<p>也就是比如：&lt;标签 data-v-822711 class&#x3D;”my_a”&gt;&lt;&#x2F;标签&gt;</p>
<p>运行时选择器会变成 .my_a[data-v-822711]</p>
<p>重要注意事项：scoped只会给当前组件所有原生标签添加data-v-hash值属性，还会给组件标签内根标签添加data-v-hash值属性，组件内的标签不会添加</p>
<p>一、为什么需要穿透scoped？</p>
<p>引用了第三方组件后，需要在组件中局部修改第三方组件的样式，而又不想去除scoped属性造成组件之间的样式污染。此时只能通过特殊的方式，穿透scoped。</p>
<p>二、样式穿透的方法</p>
<p>样式穿透的写法有三种：&gt;&gt;&gt;、&#x2F;deep&#x2F;、::v-deep</p>
<p>1、&gt;&gt;&gt;</p>
<p>如果项目使用的是css原生样式，那么可以直接使用 &gt;&gt;&gt; 穿透修改</p>
<p>2、&#x2F;deep&#x2F;</p>
<p>项目中用到了预处理器 scss 、sass、less 操作符 &gt;&gt;&gt; 可能会因为无法编译而报错 。可以使用 &#x2F;deep&#x2F;</p>
<p>注意：vue-cli3以上版本不可以</p>
<p>3、::v-deep</p>
<h2 id="v-for更新监测"><a href="#v-for更新监测" class="headerlink" title="v-for更新监测"></a>v-for更新监测</h2><p>真实dom和虚拟dom</p>
<p>真实DOM就是在document对象上面渲染到浏览器上显示的标签</p>
<p>虚拟DOM本质是保存节点信息，属性和内容的一个JS对象。</p>
<p>虚拟DOM更新时会在内存中比较变化部分，然后给真实DOM打补丁</p>
<p>diff算法</p>
<p>虚拟DOM中采用的算法，把树形结构按照层级分解，只比较同级元素，不同层级的节点只有创建和删除操作。</p>
<p>diff算法采用同级比较，如果根元素变化直接删除重新建立整个的DOM树，如果根元素没变，DOM复用，只更新属性</p>
<p>v-for中key的作用</p>
<p>无key时会最大限度尝试就地修改&#x2F;复用相同类型元素</p>
<p>有key，值为索引时，先产生新旧虚拟DOM，然后根据key比较，还是就地更新</p>
<p>有key，值为唯一不重复的字符串或数字时，先产生新旧虚拟DOM，然后根据key比较</p>
<p>​        </p>
<h2 id="打包后dist目录过大，解决办法？"><a href="#打包后dist目录过大，解决办法？" class="headerlink" title="打包后dist目录过大，解决办法？"></a>打包后dist目录过大，解决办法？</h2><p>1.dist打包生成的文件中有.map文件，可以删除。在vue.config.js文件中配置：productionSourceMap: false</p>
<p>2.组件和路由使用懒加载、按需引入等</p>
<p>3.对于文件和图片进行压缩。安装压缩组件：compression-webpack-plugin</p>
<p>安装后进行导入配置：</p>
<p>最小化代码minisize:true</p>
<p>分割代码：splitChunksl</p>
<p>超过限定值的文件进行压缩，threshold:文件大小（字节为单位）</p>
<h2 id="watch和computed的区别"><a href="#watch和computed的区别" class="headerlink" title="watch和computed的区别"></a>watch和computed的区别</h2><p>computed：计算属性，它具有缓存特性。</p>
<p>watch：侦听器，是Vue实例的一个属性，是用来响应数据的变化，需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。它可以监控一个变量，也可以是一个对象，一般用于监控路由、input输入框的值特殊处理等等，适用场景是一个数据影响多个数据，它不具有缓存性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-attr">computed</span>: &#123;<br>    计算属性名: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> xxx<br>    &#125;<br>  &#125;<br><span class="hljs-attr">watch</span>:&#123;<br>    被监听的数据:&#123;<br>        <span class="hljs-title function_">handler</span>(<span class="hljs-params">数据改变后的新值, 数据改变前的旧值</span>)&#123;<br>            逻辑代码<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>区别：</p>
<ul>
<li><p>功能上：computed是计算属性，watch是监听一个值的变化，然后执行对应的回调。</p>
</li>
<li><p>是否调用缓存：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调。</p>
</li>
<li><p>是否调用return：computed中的函数必须要用return返回，watch中的函数不是必须要用return。</p>
</li>
<li><p>computed默认第一次加载的时候就开始监听；watch默认第一次加载不做监听，如果需要第一次加载做监听，添加immediate属性，设置为true（immediate:true）</p>
</li>
</ul>
<h2 id="vue组件之间的数据传递"><a href="#vue组件之间的数据传递" class="headerlink" title="vue组件之间的数据传递"></a>vue组件之间的数据传递</h2><h3 id="父组件给子组件传递数据"><a href="#父组件给子组件传递数据" class="headerlink" title="父组件给子组件传递数据"></a>父组件给子组件传递数据</h3><p>通过给父组件身上绑定自定义属性，然后在子组件里使用props属性来接收即可 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 父组件：<br>&lt;Son :msg=&quot;message&quot;&gt;&lt;/Son&gt;<br>&lt;script&gt;<br>export default&#123;<br>    data()&#123;<br>        return &#123; message:&#x27;hello vuejs&#x27; &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br><br>// 子组件<br>&lt;template&gt;<br>	&lt;div&gt;<br>        &lt;p&gt;父组件传递过来的msg值是：&#123;&#123; msg &#125;&#125;&lt;/p&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default&#123;<br>&lt;script&gt;<br>export default&#123;<br>    props: [&#x27;msg&#x27;]<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h3 id="子组件给父组件传递数据"><a href="#子组件给父组件传递数据" class="headerlink" title="子组件给父组件传递数据"></a>子组件给父组件传递数据</h3><p>通过父组件给子组件绑定一个自定义事件实现：子组件通过this.$emit给父组件传递数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 子组件<br>&lt;script&gt;<br>export default&#123;<br>    data()&#123;<br>        return &#123; count: 0 &#125;<br>    &#125;,<br>    methods:&#123;<br>        add()&#123;<br>            this.count += 1<br>            this.$emit(&#x27;numChangeEV&#x27;,this.count)<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br>// 父组件<br>&lt;Son @numChangeEV=&quot;getNewCount&quot;&gt;&lt;/Son&gt;<br><br>&lt;script&gt;<br>export default&#123;<br>    data()&#123;<br>        return &#123; countFromSon: 0 &#125;<br>    &#125;,<br>    methods:&#123;<br>        getNewCount()&#123;<br>            this,countFromSon = val<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h3 id="子组件需要调用父组件的方法"><a href="#子组件需要调用父组件的方法" class="headerlink" title="子组件需要调用父组件的方法"></a>子组件需要调用父组件的方法</h3><p>1.父组件中把方法作为属性传入子组件，在子组件里直接调用这个方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 父组件中<br>&lt;Son :setBillDetailEV=&quot;setBillDetail&quot;&gt;&lt;/Son&gt;<br><br>// 子组件中<br>&lt;span @click=&quot;setBillDetail(null)&quot;&gt;返回&lt;/span&gt;<br>&lt;script&gt;<br>export default&#123;<br>    props:&#123;<br>        setBillDetail:&#123;<br>            type: Function,<br>            default: null<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>2.直接在子组件中通过this.$parent.event来调用父组件的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 父组件中<br>&lt;Son :setBillDetailEV=&quot;setBillDetail&quot;&gt;&lt;/Son&gt;<br>&lt;script&gt;<br>export default&#123;<br>    methods:&#123;<br>        setBillDetail()&#123;&#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br>// 子组件中<br>&lt;span @click=&quot;setBill&quot;&gt;返回&lt;/span&gt;<br>&lt;script&gt;<br>export default&#123;<br>    methods:&#123;<br>        setBill()&#123;<br>            this.$parent.setBillDetail()<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>3.在子组件里用$emit向父组件触发一个事件，父组件监听这个事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 父组件中<br>&lt;Son :setBillDetailEV=&quot;setBillDetail&quot;&gt;&lt;/Son&gt;<br>&lt;script&gt;<br>export default&#123;<br>    methods:&#123;<br>        setBillDetail()&#123;&#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br>// 子组件中<br>&lt;span @click=&quot;setBill&quot;&gt;返回&lt;/span&gt;<br>&lt;script&gt;<br>export default&#123;<br>    methods:&#123;<br>        setBill()&#123;<br>            this.$emit(&#x27;setBillDetailEV&#x27;)<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h3 id="父组件调用子组件方法"><a href="#父组件调用子组件方法" class="headerlink" title="父组件调用子组件方法"></a>父组件调用子组件方法</h3><h4 id="emit、-on方式"><a href="#emit、-on方式" class="headerlink" title="$emit、$on方式"></a>$emit、$on方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 父组件中<br>&lt;template&gt;<br>	&lt;div&gt;<br>        &lt;button @click=&quot;handleClick&quot;&gt;点击调用子组件方法&lt;/button&gt;<br>    	&lt;Child ref=&quot;child&quot;&gt;&lt;/Child&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default&#123;<br>    methods:&#123;<br>        handleClick()&#123;<br>            this.$ref.child.$emit(&#x27;childmethods&#x27;)<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br><br>// 子组件中<br>&lt;template&gt;<br>&lt;div&gt;我是子组件&lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default&#123;<br>    mounted:&#123;<br>        this.$nextTick(function()&#123;<br>		    this.$on(&#x27;childmethods&#x27;,function()&#123;<br>        		console.log(&#x27;我是子组件方法&#x27;)<br>    		&#125;)<br>		&#125;)<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h4 id="通过ref直接调用子组件方法"><a href="#通过ref直接调用子组件方法" class="headerlink" title="通过ref直接调用子组件方法"></a>通过ref直接调用子组件方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 父组件中<br>&lt;template&gt;<br>	&lt;div&gt;<br>        &lt;button @click=&quot;handleClick&quot;&gt;点击调用子组件方法&lt;/button&gt;<br>    	&lt;Child ref=&quot;child&quot;&gt;&lt;/Child&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default&#123;<br>    methods:&#123;<br>        handleClick()&#123;<br>            this.$ref.child.sing()<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br><br>// 子组件中<br>&lt;template&gt;<br>	&lt;div&gt;我是子组件&lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default&#123;<br>    methods:&#123;<br>        sing()&#123;<br>            console.log(&#x27;唱歌&#x27;)<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h2 id="管理准备（项目代码版本管理工具：git-svn）"><a href="#管理准备（项目代码版本管理工具：git-svn）" class="headerlink" title="管理准备（项目代码版本管理工具：git&#x2F;svn）"></a>管理准备（项目代码版本管理工具：git&#x2F;svn）</h2><h3 id="问题1：新旧项目，确保有什么文件夹？"><a href="#问题1：新旧项目，确保有什么文件夹？" class="headerlink" title="问题1：新旧项目，确保有什么文件夹？"></a>问题1：新旧项目，确保有什么文件夹？</h3><ol>
<li>项目文件夹下，有隐藏.git文件夹（它里面记录了你所有的版本提交，远程仓库相关配置）如果没有则运行git init命令，初始化一个</li>
<li>别人的&#x2F;克隆的项目，我们需要git init吗？不需要，因为项目已经拥有了git本地仓库</li>
</ol>
<h3 id="拿到项目"><a href="#拿到项目" class="headerlink" title="拿到项目"></a>拿到项目</h3><h4 id="问题2：如果旧项目（进公司第一件事）如何得到别人的项目代码？"><a href="#问题2：如果旧项目（进公司第一件事）如何得到别人的项目代码？" class="headerlink" title="问题2：如果旧项目（进公司第一件事）如何得到别人的项目代码？"></a>问题2：如果旧项目（进公司第一件事）如何得到别人的项目代码？</h4><ol>
<li><p>先知道git远程仓库的地址</p>
</li>
<li><p>本机创建空白的文件夹，敲击如下命令，第一次克隆</p>
<p>git clone 远程仓库git地址</p>
</li>
</ol>
<h4 id="问题3：克隆命令是做什么的呢？"><a href="#问题3：克隆命令是做什么的呢？" class="headerlink" title="问题3：克隆命令是做什么的呢？"></a>问题3：克隆命令是做什么的呢？</h4><p>把远程仓库git地址位置对应的代码＋它里面所有之前提交记录，都下载到本地</p>
<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ol>
<li><p>https开头的地址，如果是公开的仓库，可以直接克隆</p>
</li>
<li><p>https开头的地址，如果是私有的仓库，你必须要在git仓库网站注册账号，让管理员拉你进组，才能克隆</p>
</li>
<li><p>git@开头的地址，如果是公开的仓库，你必须要在git仓库网站注册账号，并把本机电脑和远程网站账号配置ssh密钥，才能克隆</p>
</li>
<li><p>git@开头的地址，如果是私有的仓库，你必须要在git仓库网站注册账号，并把本机电脑和远程网站账号配置ssh密钥，并且还要让管理员拉你进组，才能克隆</p>
</li>
</ol>
<h4 id="问题4：如果远程仓库有更新，如何拿到更新以后的内容到本地？"><a href="#问题4：如果远程仓库有更新，如何拿到更新以后的内容到本地？" class="headerlink" title="问题4：如果远程仓库有更新，如何拿到更新以后的内容到本地？"></a>问题4：如果远程仓库有更新，如何拿到更新以后的内容到本地？</h4><ol>
<li><p>如果本地无变更：git pull</p>
</li>
<li><p>如果本地有变更：</p>
<ol>
<li><code>git add .</code>  ：<strong>将工作区更改过的文件提交到暂存区</strong></li>
<li><code>git commit -m &quot;提交提示信息&quot;</code>：<strong>将暂存区内容添加到本地仓库</strong>。Ps:提交一次就会在本地git仓库里出现一次提交保存的记录（本时间节点的代码记录一次快照）。</li>
<li><code>git pull</code>  Ps: git pull以后会把远程更新和本地的更新合并到一个项目内，所以冲突很可能发生在这个命令后</li>
</ol>
</li>
</ol>
<h3 id="推送项目"><a href="#推送项目" class="headerlink" title="推送项目"></a>推送项目</h3><h4 id="问题6：本地git记录有很多次，一次性保存到远程仓库上？"><a href="#问题6：本地git记录有很多次，一次性保存到远程仓库上？" class="headerlink" title="问题6：本地git记录有很多次，一次性保存到远程仓库上？"></a>问题6：本地git记录有很多次，一次性保存到远程仓库上？</h4><ol>
<li><p>本地仓库第一次新建的，无远程仓库配置：</p>
<ol>
<li><p>git remote add origin 远程仓库git地址</p>
</li>
<li><p>git push -u origin master（即把本地master主分支所有提交记录，推送到远程仓库的master主分支上；-u配置一条通道以后直接本地在master分支时，可以直接git push）</p>
</li>
</ol>
</li>
<li><p>之前本地仓库已经配置好了，远程仓库的地址：git push</p>
</li>
</ol>
<h2 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">git init 初始化git仓库(mac中<span class="hljs-title class_">Command</span>+<span class="hljs-title class_">Shift</span>+.可以显示隐藏文件)<br>git remote add origin 远程仓库git地址<br>git status 查看文件状态<br>git add 文件列表 追踪文件<br>git commit -m 提交信息 向仓库中提交代码<br>git log 查看提交记录<br>git push -u origin master（即把本地master主分支所有提交记录，推送到远程仓库的master主分支上；-u配置一条通道,以后直接本地在master分支时，可以直接git push）<br></code></pre></td></tr></table></figure>

<h3 id="1-分支明细"><a href="#1-分支明细" class="headerlink" title="1.分支明细"></a>1.分支明细</h3><p>（1）主分支（master）：第一次向git仓库中提交更新记录时自动产生一个分支。</p>
<p>（2）开发分支（develop）：作为开发的分支，基于master分支创建。</p>
<p>（3）功能分支（feature）：作为开发具体功能的分支，基于开发分支创建</p>
<h3 id="2-分支命令"><a href="#2-分支命令" class="headerlink" title="2.分支命令"></a>2.分支命令</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">git branch查看分支<br>git branch分支名称 创建分支<br>git checkout分支名称 切换分支<br>git merge来源分支 合并分支(备注：必须在master分支上才能合并develop分支)<br>git branch -d分支名称删除分支（分支被合并后才允许删除）（-D强制删除）<br></code></pre></td></tr></table></figure>

<h3 id="3-暂时保存更改"><a href="#3-暂时保存更改" class="headerlink" title="3.暂时保存更改"></a>3.暂时保存更改</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">存储临时改动：git stash<br>恢复改动：git stash pop<br></code></pre></td></tr></table></figure>

<h2 id="Vue修饰符"><a href="#Vue修饰符" class="headerlink" title="Vue修饰符"></a>Vue修饰符</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">stop：阻止事件冒泡，顺序是执行顺序是div&gt;body&gt;<span class="hljs-variable language_">document</span>，<br>js默认开启事件冒泡。e.<span class="hljs-title function_">stopPropagation</span>()、e.<span class="hljs-title function_">stopImmediatePropagation</span>() 阻止改dom所有该类型事件的冒泡。<br><br>self：阻止事件冒泡&amp;&amp;阻止事件捕获,div&gt;body&gt;<span class="hljs-variable language_">document</span>,<span class="hljs-variable language_">document</span>&gt;body&gt;div,默认是冒泡。<br><br>capture：开启事件捕获，写在需要捕获的元素上，他会捕获内部元素的同类型事件 <span class="hljs-variable language_">document</span>&gt;body&gt;div <br><span class="hljs-comment">// 默认关闭事件捕获，开启事件冒泡。addEventListener(&quot;click&quot;, this.Parent, &#123;capture:true&#125;); capture，true开启，反之关闭</span><br><br>once：事件只触发一次就会被移除。<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">Parent</span>, &#123;<span class="hljs-attr">once</span>:<span class="hljs-literal">true</span>&#125;); once，<span class="hljs-literal">true</span>开启，反之关闭<br><br>prevent： 阻止事件的默认行为 e.<span class="hljs-title function_">preventDefault</span>() e.<span class="hljs-property">defaultPrevented</span> 查看默认阻止的状态，<span class="hljs-literal">true</span>：已阻止。<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">Parent</span>, &#123;<span class="hljs-attr">passive</span>:<span class="hljs-literal">true</span>&#125;); passive，<span class="hljs-literal">true</span>：阻止preventDefault函数调用，反之不阻止<br><br>native：事件直接绑定到组件的原生节点上，&lt;el-input @click.<span class="hljs-property">native</span>/&gt; click事件直接绑定在input元素上。<br><br>lazy： vue v-model 修饰符。修改语法糖的input事件为change。<br><br>number： vue 修饰符。把值转换为number类型。<br><br>trim： vue修饰符。去除数值前后空格。 <br></code></pre></td></tr></table></figure>

<h2 id="this-nextTick"><a href="#this-nextTick" class="headerlink" title="this.$nextTick()"></a>this.$nextTick()</h2><p>定义：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p>
<p>所以就衍生出了这个获取更新后的DOM的Vue方法。所以放在Vue.nextTick()回调函数中的执行的应该是会对DOM进行操作的 js代码；</p>
<p>理解：nextTick()，是将回调函数延迟在下一次dom更新数据后调用，简单的理解是：当数据更新了，在dom中渲染后，自动执行该函数</p>
<h3 id="使用原理："><a href="#使用原理：" class="headerlink" title="使用原理："></a>使用原理：</h3><p>Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要计算和DOM操作。而在下一个事件循环时，Vue会清空队列，并进行DOM更新。</p>
<p>当你设置 改变了一个新数据data，DOM 并不会马上更新，而是在异步队列被清空，也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中，原因是在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的DOM挂载已完成。</p>
<p>当项目中你想在改变DOM元素的数据后基于新的dom做点什么，对新DOM一系列的js操作都需要放进Vue.nextTick()的回调函数中；通俗的理解是：更改数据后当你想立即使用js操作新的视图的时候需要使用它</p>
<h2 id="route和-router"><a href="#route和-router" class="headerlink" title="$route和$router"></a>$route和$router</h2><h3 id="route"><a href="#route" class="headerlink" title="$route"></a>$route</h3><p>$route对象表示当前的路由信息，包含了当前 URL 解析得到的信息。包含当前的路径，参数，query对象等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">$route.<span class="hljs-property">path</span> 字符串，对应当前路由的路径，总是解析为绝对路径，如<span class="hljs-string">&quot;/foo/bar&quot;</span>。<br>$route.<span class="hljs-property">params</span> 一个 key/value 对象，包含了 动态片段 和 全匹配片段，如果没有路由参数，就是一个空对象。<br>$route.<span class="hljs-property">query</span>一个 key/value 对象，表示 <span class="hljs-variable constant_">URL</span> 查询参数。例如，对于路径 /foo?user=<span class="hljs-number">1</span>，则有$route.<span class="hljs-property">query</span>.<span class="hljs-property">user</span> == <span class="hljs-number">1</span>，如果没有查询参数，则是个空对象。<br>$route.<span class="hljs-property">hash</span> 当前路由的hash值(不带#) ，如果没有 hash 值，则为空字符串。锚点*<br>$route.<span class="hljs-property">fullPath</span> 完成解析后的 <span class="hljs-variable constant_">URL</span>，包含查询参数和hash的完整路径。<br>$route.<span class="hljs-property">matched</span> 数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。<br>$route.<span class="hljs-property">name</span> 当前路径名字<br>$route.<span class="hljs-property">meta</span> 路由元信息<br></code></pre></td></tr></table></figure>

<h3 id="router"><a href="#router" class="headerlink" title="$router"></a>$router</h3><p>$router对象是全局路由的实例，是router构造方法的实例。有push、go、replace方法实现路由跳转。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">导航钩子的参数：<br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span>, next</span>)=&gt;</span>&#123;<span class="hljs-comment">//to 和from都是 路由信息对象,后面使用路由的钩子函数就容易理解了&#125;)</span><br></code></pre></td></tr></table></figure>

<h2 id="Vue中hash和history的区别"><a href="#Vue中hash和history的区别" class="headerlink" title="Vue中hash和history的区别"></a>Vue中hash和history的区别</h2><ul>
<li>hash路由在地址栏URL上有#，用<code>window.location.hash</code> 读取。而history路由没有会好看一点</li>
<li>我们进行回车刷新操作，hash路由会加载到地址栏对应的页面，而history路由一般就404报错了（刷新是网络请求，没有后端准备时会报错）。</li>
<li>hash路由支持低版本的浏览器IE8，而history路由是HTML5新增的API，只能兼容到IE10。</li>
<li>hash的特点在于它虽然出现在了URL中，但是不包括在http请求中，所以对于后端是没有一点影响的，所以改变hash不会重新加载页面，所以这也是单页面应用的必备。</li>
<li>history运用了浏览器的历史记录栈，之前有back, forward, go方法，之后在HTML5中新增了pushState()和replaceState()方法，它们提供了对历史记录进行修改的功能，不过在进行修改时，虽然改变了当前的URL，但是浏览器不会马上向后端发送请求。</li>
<li>history的这种模式需要后台配置支持。比如：当我们进行项目的主页的时候，一切正常，可以访问，但是当我们刷新页面或者直接访问路径的时候就会返回404，那是因为在history模式下，只是动态的通过js操作window.history来改变浏览器地址栏里的路径，并没有发起http请求，但是当我直接在浏览器里输入这个地址的时候，就一定要对服务器发起http请求，但是这个目标在服务器上又不存在，所以会返回404</li>
<li>原理不同<ul>
<li>hash：通过监听浏览器的onhashchange()事件变化，查找对应的路由规则</li>
<li>history： 利用H5的 history中新增的两个API pushState() 和 replaceState() 和一个事件onpopstate监听URL变化</li>
</ul>
</li>
</ul>
<h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><p>大部分情况下应该遵循<strong>单向数据流</strong>原则，禁止子组件直接修改props，否则复杂环境下的数据流将变得混乱，极易出现bug且难排查</p>
<h2 id="Vue中父子组件生命周期"><a href="#Vue中父子组件生命周期" class="headerlink" title="Vue中父子组件生命周期"></a>Vue中父子组件生命周期</h2><p>父子组件的生命周期是一个嵌套的过程<br>渲染的过程<br><code>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</code><br>子组件更新过程<br><code>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</code><br>父组件更新过程<br><code>父beforeUpdate-&gt;父updated</code><br>销毁过程<br><code>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</code></p>
<h1 id="Vue面试题"><a href="#Vue面试题" class="headerlink" title="Vue面试题"></a>Vue面试题</h1><h2 id="vue中keep-alive组件的作用"><a href="#vue中keep-alive组件的作用" class="headerlink" title="vue中keep-alive组件的作用"></a>vue中keep-alive组件的作用</h2><p>keep-alive：主要是用于保留组件状态和避免组件重新渲染。</p>
<p>其是一个抽象组件（或称为功能性组件），实际上不会被渲染在DOM树中。它的作用是在内存中缓存组件（不让组件销毁），等到下次在渲染的时候，还会保持其中的所有状态，并且会触发 activated钩子函数。</p>
<p>属性：（属性表示要缓存的组件名，即组件定义时的name属性）</p>
<ul>
<li>include：字符串或正则表达式，只有匹配的组件会被缓存</li>
<li>exclude：字符串或正则表达式，任何匹配的组件都不会被缓存</li>
</ul>
<p>被包含在 keep-alive中创建的组件，会多出两个生命周期的钩子： activated与 decativated。</p>
<ul>
<li>activated：在组件被激活时调用，在组件第一次渲染时也会被调用，之后每次 keep-alive激活时被调用</li>
<li>decativated：在组件被停用时调用。</li>
</ul>
<p>注意：只有组件被 keep-alive 包裹时，这两个生命周期才会被调用，如果作为正常组件使用，是不会被调用，以及在 2.1.0 版本之后，使用 exclude 排除之后，就算被包裹在 keep-alive中，这两个钩子依然不会被调用！另外在服务端渲染时此钩子也不会被调用的。</p>
<p>在App.vue中修改为如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;keep-alive&gt;<br>    &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;<br>&lt;/keep-alive&gt;<br><br>&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;<br></code></pre></td></tr></table></figure>

<p>在router&#x2F;index.js中为每一个路由添加：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">meta</span>:&#123;<br>    <span class="hljs-attr">keepAlive</span>:<span class="hljs-literal">true</span>/<span class="hljs-literal">false</span> <span class="hljs-comment">//true代表这个页面（组件）需要缓存，false代表不需要</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="实际应用：（下面的写法是将组件在内存中进行缓存）"><a href="#实际应用：（下面的写法是将组件在内存中进行缓存）" class="headerlink" title="实际应用：（下面的写法是将组件在内存中进行缓存）"></a>实际应用：（下面的写法是将组件在内存中进行缓存）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 基本 --&gt;<br>&lt;keep-alive&gt;<br>    &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;<br>&lt;/keep-alive&gt;<br><br>&lt;!-- 多个条件判断的子组件 --&gt;<br>&lt;keep-alive&gt;<br>    &lt;comp-a v-if=&quot;a &gt; 1&quot;&gt;&lt;/comp-a&gt;<br>    &lt;comp-b v-else&gt;&lt;/comp-b&gt;<br>&lt;/keep-alive&gt;<br><br>&lt;!-- 和 `&lt;transition&gt;` 一起使用 --&gt;<br>&lt;transition&gt;<br>    &lt;keep-alive&gt;<br>        &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;<br>    &lt;/keep-alive&gt;<br>&lt;/transition&gt;<br></code></pre></td></tr></table></figure>

<p>注意：<code>&lt;keep-alive&gt;</code>是用在其一个直属的子组件被开关的情形。如果你在其中有 v-for 则不会工作。如果有上述的多个条件性的子元素，<code>&lt;keep-alive&gt; </code>要求同时只有一个子元素被渲染。</p>
<h3 id="include-和-exclude-属性的使用"><a href="#include-和-exclude-属性的使用" class="headerlink" title="include 和 exclude 属性的使用"></a>include 和 exclude 属性的使用</h3><p>include 和 exclude 属性允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">  &lt;!-- 逗号分隔字符串 --&gt;<br>&lt;keep-alive include=&quot;a,b&quot;&gt;<br>    &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;<br>&lt;/keep-alive&gt;<br><br><br>&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;<br>&lt;keep-alive :include=&quot;/a|b/&quot;&gt;<br>    &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;<br>&lt;/keep-alive&gt;<br><br><br>&lt;!-- 数组 (使用 `v-bind`) --&gt;<br>&lt;keep-alive :include=&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;&gt;<br>    &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;<br>&lt;/keep-alive&gt;<br></code></pre></td></tr></table></figure>

<p>匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件components 选项的键值)。匿名组件不能被匹配。 不会在函数式组件中正常工作，因为它们没有缓存实例。</p>
<h2 id="Vue中如何编写可复用的组件"><a href="#Vue中如何编写可复用的组件" class="headerlink" title="Vue中如何编写可复用的组件"></a>Vue中如何编写可复用的组件</h2><p>在编写组件的时候，时刻考虑组件是否可复用是有好处的。一次性组件跟其他组件紧密耦合没关系，但是可复用组件一定要定义一个清晰的公开接口。</p>
<p>Vue.js组件 API 来自 三部分：prop、事件、slot：</p>
<ul>
<li>prop 允许外部环境传递数据给组件，在vue-cli工程中也可以使用vuex等传递数据。</li>
<li>事件允许组件触发外部环境的 action。</li>
<li>slot 允许外部环境将内容插入到组件的视图结构内。</li>
</ul>
<h2 id="如何解决非工程化项目，网速慢时初始化页面闪动问题"><a href="#如何解决非工程化项目，网速慢时初始化页面闪动问题" class="headerlink" title="如何解决非工程化项目，网速慢时初始化页面闪动问题"></a>如何解决非工程化项目，网速慢时初始化页面闪动问题</h2><p>使用 v-cloak指令，v-cloak不需要表达式，它会在Vue实例结束编译时从绑定的HTML元素上移除，经常和CSS的display:none配合使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div id=&quot;app&quot; v-cloak&gt;<br>    &#123;&#123;message&#125;&#125;<br>&lt;/div&gt;<br>&lt;script&gt;<br>var app = new Vue(&#123;<br>    el:&quot;#app&quot;,<br>    data:&#123;<br>        message:&quot;这是一段文本&quot;<br>    &#125;<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>这时虽然已经加了指令v-cloak，但其实并没有起到任何作用，当网速较慢、Vue.js 文件还没加载完时，在页面上会显示的字样，直到Vue创建实例、编译模版时，DOM才会被替换，所以这个过程屏幕是有闪动的。只要加一句CSS就可以解决这个问题了：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;!--属性选择器--&gt;<br><span class="hljs-selector-attr">[v-cloak]</span>&#123;<br>    <span class="hljs-attribute">display</span>:none;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在一般情况下，v-cloak是一个解决初始化慢导致页面闪动的最佳实践，对于简单的项目很实用。</p>
<h2 id="组件之间双向绑定"><a href="#组件之间双向绑定" class="headerlink" title="组件之间双向绑定"></a>组件之间双向绑定</h2><p>大家都知道 Vue2 中组件的双向绑定采用的是 v-model 或 .snyc 修饰符，两种写法多少显得有点重复，于是在 Vue3 中合成了一种。Vue3 统一使用 v-model 进行处理，并且可以和多个数据进行绑定，如 v-model:foo、v-model:bar。</p>
<p>v-model 等价于 :model-value&#x3D;”someValue” 和 @update:model-value&#x3D;”someValue &#x3D; $event”。</p>
<p>v-model:foo 等价于 :foo&#x3D;”someValue” 和 @update:foo&#x3D;”someValue &#x3D; $event”</p>
<p>下面就是一个父子组件之间双向绑定的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 父组件 --&gt;<br>&lt;script setup&gt;<br>import ChildView from &#x27;./ChildView.vue&#x27;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const msg = ref(&#x27;hello vue3!&#x27;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;ChildView v-model=&quot;msg&quot; /&gt;<br>&lt;/template&gt;<br>&lt;!-- 子组件 --&gt;<br>&lt;script setup&gt;<br>defineProps([&#x27;modelValue&#x27;])<br>const emit = defineEmits([&#x27;update:modelValue&#x27;])<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;div @click=&quot;emit(&#x27;update:modelValue&#x27;, &#x27;hi vue3！&#x27;)&quot;&gt;&#123;&#123; modelValue &#125;&#125;&lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<p>子组件可以结合input使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 子组件 --&gt;<br>&lt;script setup&gt;<br>defineProps([&#x27;modelValue&#x27;])<br>const emit = defineEmits([&#x27;update:modelValue&#x27;])<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input :value=&quot;modelValue&quot; @input=&quot;emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot; /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<p>如果你觉得上面的模板比较繁琐，也可以结合 computed 一起使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 子组件 --&gt;<br>&lt;script setup&gt;<br>import &#123; computed &#125; from &#x27;vue&#x27;<br><br>const props = defineProps([&#x27;modelValue&#x27;])<br>const emit = defineEmits([&#x27;update:modelValue&#x27;])<br>const newValue = computed(&#123;<br>  get() &#123;<br>    return props.modelValue<br>  &#125;,<br>  set(value) &#123;<br>    emit(&#x27;update:modelValue&#x27;, value)<br>  &#125;<br>&#125;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input v-model=&quot;newValue&quot; /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<h2 id="Scoped-CSS的原理"><a href="#Scoped-CSS的原理" class="headerlink" title="Scoped CSS的原理"></a>Scoped CSS的原理</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>先带大家看一下无设置<code>Scoped</code>与设置<code>Scoped</code>的区别在哪</p>
<p><strong>「无设置<code>Scoped</code>」</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;login&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.login</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span></span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>打包之后的结果是跟我们的代码一摸一样的，没有区别。</p>
<p><strong>「设置<code>Scoped</code>」</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;login&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.login</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span></span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>打包之后的结果是跟我们的代码就有所区别了。如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-v-257dda99b</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;login&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.login</span><span class="hljs-selector-attr">[data-v-257dda99b]</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span></span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>我们通过上面的例子，不难发现多了一个data-v-hash属性，也就是说加了scoped，PostCSS给一个组件中的所有dom添加了一个独一无二的动态属性，然后，给CSS选择器额外添加一个对应的属性选择器来选择该组件中dom，这种做法使得样式只作用于含有该属性的dom——组件内部dom，可以使得组件之间的样式不互相污染。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Vue的作用域样式 Scoped CSS 的实现思路如下：</p>
<ol>
<li>为每个组件实例（注意：是组件的实例，不是组件类）生成一个能唯一标识组件实例的标识符，我称它为组件实例标识，简称实例标识，记作 InstanceID；</li>
<li>给组件模板中的每一个标签对应的Dom元素（组件标签对应的Dom元素是该组件的根元素）添加一个标签属性，格式为 <code>data-v-实例标识</code>，示例：<code>&lt;div data-v-e0f690c0=&quot;&quot; &gt;</code>；</li>
<li>给组件的作用域样式 <code>&lt;style scoped&gt;</code> 的每一个选择器的最后一个选择器单元增加一个属性选择器 <code>原选择器[data-v-实例标识]</code> ，示例：假设原选择器为 <code>.cls #id &gt; div</code>，则更改后的选择器为 <code>.cls #id &gt; div[data-v-e0f690c0]</code>；</li>
</ol>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li>将组件的样式的作用范围限制在了组件自身的标签，即：组件内部，包含子组件的根标签，但不包含子组件的除根标签之外的其它标签；所以 组件的css选择器也不能选择到子组件及后代组件的中的元素（子组件的根元素除外）；<ul>
<li>因为它给选择器的最后一个选择器单元增加了属性选择器 <code>[data-v-实例标识]</code> ，而该属性选择器只能选中当前组件模板中的标签；而对于子组件，只有根元素 即有 能代表子组件的标签属性 <code>data-v-子实例标识</code>，又有能代表当前组件（父组件）的 签属性 <code>data-v-父实例标识</code>，子组件的其它非根元素，仅有能代表子组件的标签属性 <code>data-v-子实例标识</code>；</li>
</ul>
</li>
<li>如果递归组件有后代选择器，则该选择器会打破特性1中所说的子组件限制，从而选中递归子组件的中元素；<ul>
<li>原因：假设递归组件A的作用域样式中有选择器有后代选择器 <code>div p</code> ，则在每次递归中都会为本次递归创建新的组件实例，同时也会为该实例生成对应的选择器 <code>div p[data-v-当前递归组件实例的实例标识]</code>，对于递归组件的除了第一个递归实例之外的所有递归实例来说，虽然 <code>div p[data-v-当前递归组件实例的实例标识]</code> 不会选中子组件实例（递归子组件的实例）中的 p 元素（具体原因已在特性1中讲解），但是它会选中当前组件实例中所有的 p 元素，因为 父组件实例（递归父组件的实例）中有匹配的 div 元素；</li>
</ul>
</li>
</ol>
<h3 id="、-deep-、-v-deep深度选择器的原理"><a href="#、-deep-、-v-deep深度选择器的原理" class="headerlink" title="&gt;&gt;&gt;、&#x2F;deep&#x2F;、::v-deep深度选择器的原理"></a>&gt;&gt;&gt;、&#x2F;deep&#x2F;、::v-deep深度选择器的原理</h3><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>实际开发中遇到的例子：当我们开发一个页面使用了子组件的时候，如果这时候需要改子组件的样式，但是又不影响其他页面使用这个子组件的样式的时候。比如：</p>
<p><strong>「父组件：Parent.vue」</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;parent&quot; id=&quot;app&quot;&gt;<br>    &lt;h1&gt;我是父组件&lt;/h1&gt;<br>    &lt;div class=&quot;gby&quot;&gt;<br>      &lt;p&gt;我是一个段落&lt;/p&gt;<br>    &lt;/div&gt;<br><br>    &lt;child&gt;&lt;/child&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>  .parent &#123;<br>    background-color: green;<br>  &#125;<br><br>  .gby p &#123;<br>    background-color: red;<br>  &#125;<br>  // 把子组件的背景变成红色，原组件不变<br>  .child .dyx p &#123;<br>    background-color: red;<br>  &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure>

<p><strong>「子组件：Child.vue」</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div class=&quot;child&quot;&gt;<br>        &lt;h1&gt;我是子组件&lt;/h1&gt;<br>        &lt;div class=&quot;dyx&quot;&gt;<br>            &lt;p&gt;我是子组件的段落&lt;/p&gt;<br>        &lt;/div&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>    .child .dyx p &#123;<br>        background-color: blue;<br>    &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure>

<p>这时候我们就会发现没有效果。但是如果我们使用<code>&gt;&gt;&gt;</code>、<code>/deep/</code>、<code>::v-deep</code>三个深度选择器其中一个就能实现了。看代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;parent&quot; id=&quot;app&quot;&gt;<br>    &lt;h1&gt;我是父组件&lt;/h1&gt;<br>    &lt;div class=&quot;gby&quot;&gt;<br>      &lt;p&gt;我是一个段落&lt;/p&gt;<br>    &lt;/div&gt;<br><br>    &lt;child&gt;&lt;/child&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>  .parent &#123;<br>    background-color: green;<br>  &#125;<br><br>  .gby p &#123;<br>    background-color: red;<br>  &#125;<br>  // 把子组件的背景变成红色，原组件不变<br>  ::v-deep .child .dyx p &#123;<br>    background-color: red;<br>  &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure>

<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>如果你希望 scoped 样式中的一个选择器能够选择到子组 或 后代组件中的元素，我们可以使用 <code>深度作用选择器</code>，它有三种写法：</p>
<ul>
<li><code>&gt;&gt;&gt;</code>，示例： <code>.gby div &gt;&gt;&gt; #dyx p</code></li>
<li><code>/deep/</code>，示例： <code>.gby div /deep/ #dyx p</code> 或 <code>.gby div/deep/ #dyx p</code></li>
<li><code>::v-deep</code>，示例： <code>.gby div::v-deep #dyx p</code> 或 <code>.gby div::v-deep #dyx p</code></li>
</ul>
<p>它的原理与 Scoped CSS 的原理基本一样，只是第3步有些不同（前2步一样），具体如下：</p>
<ol>
<li>为每个组件实例（注意：是组件的实例，不是组件类）生成一个能唯一标识组件的标识符，我称它为实例标识，记作 InstanceID；</li>
<li>给组件模板中的每一个标签对应的Dom元素（组件标签对应的Dom元素是该组件的根元素）添加一个标签属性，格式为 <code>data-v-实例标识</code>，示例：<code>&lt;div data-v-e0f690c0=&quot;&quot; &gt;</code>；</li>
<li>给组件的作用域样式 <code>&lt;style scoped&gt;</code> 的每一个深度作用选择器前面的一个选择器单元增加一个属性选择器<code>[data-v-实例标识]</code> ，示例：假设原选择器为 <code>.cls #id &gt;&gt;&gt; div</code>，则更改后的选择器为 <code>.cls #id[data-v-e0f690c0] div</code>；</li>
</ol>
<p>因为Vue不会为深度作用选择器后面的选择器单元增加 属性选择器<code>[data-v-实例标识]</code>，所以，后面的选择器单元能够选择到子组件及后代组件中的元素；</p>
<h1 id="中标慧安"><a href="#中标慧安" class="headerlink" title="中标慧安"></a>中标慧安</h1><h2 id="怎么设置6px大小？"><a href="#怎么设置6px大小？" class="headerlink" title="怎么设置6px大小？"></a>怎么设置6px大小？</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box1</span>&#123;<br>	<span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;<br>	-webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.50</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种方法是利用了CSS3的缩放属性，即：将文字大小整体缩小为原来的0.5倍，但是有一个硬伤，他只是缩小了文字的大小，并不能将文字所占的区域大小缩小，即无法缩小元素的width和height。</p>
<h2 id="文字溢出显示省略号"><a href="#文字溢出显示省略号" class="headerlink" title="文字溢出显示省略号"></a>文字溢出显示省略号</h2><h3 id="单行文本溢出"><a href="#单行文本溢出" class="headerlink" title="单行文本溢出"></a>单行文本溢出</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>: hidden;（文字长度超出限定宽度，则隐藏超出的内容）<br><span class="hljs-attribute">white-space</span>: nowrap;（设置文字在一行显示，不能换行）<br><span class="hljs-attribute">text-overflow</span>: ellipsis;（规定当文本溢出时，显示省略符号来代表被修剪的文本）<br></code></pre></td></tr></table></figure>

<h3 id="多行文本溢出"><a href="#多行文本溢出" class="headerlink" title="多行文本溢出"></a>多行文本溢出</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">display</span>: -webkit-box; //元素转换为弹性容器,在一行排列<br>-webkit-<span class="hljs-attribute">box-orient</span>: vertical; //表示盒子对象的子元素的排列方式<br>-webkit-<span class="hljs-selector-tag">line</span>-clamp: <span class="hljs-number">3</span>; //限制文本的行数，表示文本第多少行省略<br><span class="hljs-attribute">text-overflow</span>: ellipsis;//打点展示<br><span class="hljs-attribute">overflow</span>: hidden;//超出部分进行隐藏 <br></code></pre></td></tr></table></figure>

<h2 id="css实现三角形"><a href="#css实现三角形" class="headerlink" title="css实现三角形"></a>css实现三角形</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css">// 等腰三角形<br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">20px</span> solid transparent;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">20px</span> solid red;<br>  <span class="hljs-attribute">border-left</span>: <span class="hljs-number">20px</span> solid transparent;<br>  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">20px</span> solid transparent;<br>&#125;<br><br>// 直角三角形<br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">0px</span> solid transparent;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">20px</span> solid red;<br>  <span class="hljs-attribute">border-left</span>: <span class="hljs-number">10px</span> solid transparent;<br>  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">0px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><ol>
<li><p>父级div定义overflow: hidden</p>
</li>
<li><p>额外标签法：在父元素最后一个浮动子元素后面添加一个空标签div设置样式clear: both</p>
</li>
<li><p>给父元素添加after伪元素</p>
</li>
<li><p>给父元素添加before和after双伪元素</p>
</li>
</ol>
<h2 id="html5新增了什么"><a href="#html5新增了什么" class="headerlink" title="html5新增了什么"></a>html5新增了什么</h2><h3 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h3><p>header footer nav aside section menu template article audio video canvas 等</p>
<h3 id="webStorage-储存机制-sessionStorage-和-localStorage"><a href="#webStorage-储存机制-sessionStorage-和-localStorage" class="headerlink" title="webStorage 储存机制 sessionStorage 和 localStorage"></a>webStorage 储存机制 sessionStorage 和 localStorage</h3><p>webStorage: 使用HTML5可以在本地存储用户的浏览数据。早些时候,本地存储使用的是 cookie。但是Web 存储需要更加的安全与快速，这些数据不会被保存在服务器上，但是这些数据只用于用户请求网站数据上。它也可以存储大量的数据，而不影响网站的性能。数据以 键&#x2F;值对存在, web网页的数据只允许该网页访问使用。</p>
<p>Web Storage又分为两种： sessionStorage 和localStorage ，即这两个是Storage的一个实例。其API提供的方法有以下几种：</p>
<p>setItem (key, value) —— 保存数据，以键值对的方式储存信息。</p>
<p>getItem (key) —— 获取数据，将键值传入，即可获取到对应的value值。</p>
<p>removeItem (key) —— 删除单个数据，根据键值移除对应的信息。</p>
<p>clear () —— 删除所有的数据</p>
<p>key (index) —— 获取某个索引的key</p>
<p>localStorage：没有时间限制的数据存储</p>
<p>localStorage的生命周期是永久性的。假若使用localStorage存储数据，即使关闭浏览器，也不会让数据消失，除非主动的去删除数据，使用的方法如上所示。</p>
<p>sessionStorage：针对一个 session 的数据存储</p>
<p>sessionStorage 的生命周期是在浏览器关闭前。也就是说，在整个浏览器未关闭前，其数据一直都是存在的。sessionStorage也有length属性，其基本的判断和使用方法和localStorage的使用是一致的。需要注意的有以下几点：</p>
<p>(1) 页面刷新不会消除数据;</p>
<p>(2) 只有在当前页面打开的链接，才可以访sessionStorage的数据；</p>
<p>(3) 使用window.open打开页面和改变localtion.href方式都可以获取到sessionStorage内部的数据;</p>
<h3 id="history-对象"><a href="#history-对象" class="headerlink" title="history 对象"></a>history 对象</h3><p>history 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。</p>
<p>history.go( ) 方法可以在用户的历史记录中任意跳转，可以向后，也可以向前。</p>
<p>history.back() &#x2F;&#x2F; 后退一页</p>
<p>history.forward() &#x2F;&#x2F; 前进一页</p>
<h3 id="表单元素input新增的属性"><a href="#表单元素input新增的属性" class="headerlink" title="表单元素input新增的属性"></a>表单元素input新增的属性</h3><p>placeholder(输入框的占位文字)multiple(多个值)autofocus(最多输入的内容)；新增type值：datalist datetime date month week time color number email address range tel url search 等</p>
<h3 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h3><p>用于回放的 video 和 audio 元素</p>
<h3 id="用于绘画的-canvas"><a href="#用于绘画的-canvas" class="headerlink" title="用于绘画的 canvas"></a>用于绘画的 canvas</h3><h2 id="css隐藏元素的方法"><a href="#css隐藏元素的方法" class="headerlink" title="css隐藏元素的方法"></a>css隐藏元素的方法</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">display</span>: none;<br><span class="hljs-attribute">visibility</span>: hidden/collapse<br>opacity: <span class="hljs-number">0</span><br>transform: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>color: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>transform: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0</span>)<br>transform: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">9999px</span>, <span class="hljs-number">0px</span>)<br>position: absolute; <span class="hljs-attribute">left</span>: -<span class="hljs-number">9999px</span>;<br><span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>; <span class="hljs-attribute">border</span>:<span class="hljs-number">0</span>; <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>; <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>; <span class="hljs-attribute">width</span>:<span class="hljs-number">0</span>; <span class="hljs-attribute">overflow</span>: hidden;<br></code></pre></td></tr></table></figure>

<h2 id="webpack热更新"><a href="#webpack热更新" class="headerlink" title="webpack热更新"></a>webpack热更新</h2><p>Hot Module Replacement，简称HMR，在不需要刷新整个页面的同时更新模块，能够提升开发的效率和体验。热更新时只会局部刷新页面上发生了变化的模块，同时可以保留当前页面的状态，比如复选框的选中状态等。</p>
<p>webpack热更新开启</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">devServer</span>: &#123;<br>	<span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,<br>&#125;,<br></code></pre></td></tr></table></figure>

<p>通过webpack-dev-server，在我们修改了项目代码之后，webpack 会监听到文件内容的变化，并且重新进行编译等工作，然后会把新的代码通过 websocket 发送给浏览器。</p>
<p>浏览器获取到新的代码之后会重新执行模块代码，并且替换模块的内容</p>
<p>在 vue-cli 工程中，webpack 默认是自动启动热更新。</p>
<h2 id="用到的webpack属性"><a href="#用到的webpack属性" class="headerlink" title="用到的webpack属性"></a>用到的webpack属性</h2><p>css-loader、less-loader、babel-loader(ES6-ES5)、eslint-loader(格式检查)</p>
<p>proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器，在devServer中配置proxy解决跨域问题</p>
<p>当请求地址是以api开头是会命中这里进行代理转发，从而解决跨域问题</p>
<h2 id="原型和原型链-1"><a href="#原型和原型链-1" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><p>原型对象是函数的一个属性prototype，叫做原型，这个属性的值是个对象，也叫原型对象。</p>
<p>对象原型每个对象都有<code>__proto__</code>属性，指向它构造函数的原型对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span>  <span class="hljs-title function_">A</span>()<br>a.<span class="hljs-property">__proto__</span> = A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>原型链是 js 对象一种查找机制，遵循就近原则。当我们访问一个对象中的成员的时候，会优先访问自己的，如果自己没有就访问<code>__proto__</code>属性，也就是构造函数的原型对象，查看是否有该属性，如果也没有就会访问<code>__proto__</code>属性，直到原型链的终点 null. 如果还没有，此时属性就会获取 undefined，方法就会报错 xxx is not a function。</p>
<h2 id="vue组件通信"><a href="#vue组件通信" class="headerlink" title="vue组件通信"></a>vue组件通信</h2><p>父传子：</p>
<p>父组件绑定动态属性，接收要传递的变量，子组件使用props接收这个动态属性</p>
<p>子传父：</p>
<p>子组件调用this.$emit(“自定义事件”, 值)，父组件绑定自定义事件，触发回调函数</p>
<p>vuex：非父子组件通信</p>
<p>this.$refs可以直接在父组件修改子组件值</p>
<p>在子组件中通过this.$parent来调用父组件的方法</p>
<h2 id="常用git命令"><a href="#常用git命令" class="headerlink" title="常用git命令"></a>常用git命令</h2><p>git init 初始化本地git仓库</p>
<p>git clone 地址 克隆远程仓库</p>
<p>git add . 将所有文件放到暂存区</p>
<p>git commit -m “说明” 将暂存区文件提交到仓库</p>
<p>git log 查看提交记录</p>
<p>git remote add origin 地址 添加远程仓库地址</p>
<p>git push -u origin master 第一次向远程仓库推送代码</p>
<p>git branch 查看本地分支</p>
<p>git branch 分支名 新建分支</p>
<p>git branch -b 分支名 新建并切换到对应分支</p>
<p>git checkout分支名 切换到该分支</p>
<p>git branch -d 分支名 删除分支</p>
<p>git pull 拉取远程仓库最新代码</p>
<h3 id="将代码推送至master主分支"><a href="#将代码推送至master主分支" class="headerlink" title="将代码推送至master主分支"></a>将代码推送至master主分支</h3><ul>
<li><p>先切换到分支次分支：git checkout xxx (要合并到主分支上的次分支)</p>
</li>
<li><p>使用git pull 拉这条分支的最新的代码下来：git pull</p>
</li>
<li><p>切换到主分支：git checkout master</p>
</li>
<li><p>把次分支的代码推送到marster主分支：git merge xxx </p>
</li>
<li><p>拉取主分支最新代码下来，防止冲突：git pull</p>
</li>
<li><p>git push推送上去：git push</p>
</li>
</ul>
<h3 id="git-把master分支代码合并到自己的分支"><a href="#git-把master分支代码合并到自己的分支" class="headerlink" title="git 把master分支代码合并到自己的分支"></a>git 把master分支代码合并到自己的分支</h3><ul>
<li>首先切换到主分支：git checkout master</li>
<li>使用git pull 把领先的主分支代码pull下来：git pull</li>
<li>切换到自己的分支：git checkout xxx(自己的分支)</li>
<li>把主分支的代码merge到自己的分支：git merge master</li>
<li>拉取主分支最新代码下来，防止冲突：git pull</li>
<li>git push推上去ok完成,现在你自己分支的代码就和主分支的代码一样了</li>
</ul>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域一般可以理解为<strong>函数或变量的生效范围</strong>,我们一般把作用域分成全局作用域,函数(局部)作用域,块级作用域。</p>
<p><strong>全局作用域</strong>：任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问。</p>
<p>函数作用域也叫<strong>局部作用域</strong>，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问。</p>
<p><strong>块级作用域</strong>：ES6 引入了let和const关键字,和var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量</p>
<h2 id="for和forEach如何中断循环"><a href="#for和forEach如何中断循环" class="headerlink" title="for和forEach如何中断循环"></a>for和forEach如何中断循环</h2><p><strong>for循环</strong></p>
<ul>
<li>通过continue会跳过当前循环</li>
<li>使用break会中断循环</li>
<li>return只能用在函数体里</li>
</ul>
<p><strong>forEach循环</strong></p>
<ul>
<li>通过try+catch和throw new Error()中断循环</li>
<li>使用continue和break会报错</li>
<li>使用return会跳过当前循环</li>
</ul>
<h2 id="vue中watch和computed的区别"><a href="#vue中watch和computed的区别" class="headerlink" title="vue中watch和computed的区别"></a>vue中watch和computed的区别</h2><p>computed：计算属性，它具有缓存特性。</p>
<p>watch：侦听器，是Vue实例的一个属性，是用来响应数据的变化，需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。它可以监控一个变量，也可以是一个对象，一般用于监控路由、input输入框的值特殊处理等等，适用场景是一个数据影响多个数据，它不具有缓存性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-attr">computed</span>: &#123;<br>    计算属性名: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> xxx<br>    &#125;<br>  &#125;<br><span class="hljs-attr">watch</span>:&#123;<br>    被监听的数据:&#123;<br>        <span class="hljs-title function_">handler</span>(<span class="hljs-params">数据改变后的新值, 数据改变前的旧值</span>)&#123;<br>            逻辑代码<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>区别：</p>
<p>watch：监控vue实例的变化，它监控的变量必须在data里面声明才可以；监控的是属性值，只要属性值发生变化，其都会触发执行回调函数来执行一系列操作，它不具有缓存性。</p>
<p>computed：用来监控自己定义的变量，该变量不在data里面定义，直接在computed里面定义；监测的是依赖值，依赖值不变的情况下其会直接读取缓存进行复用，变化的情况下才会重新计算，具有缓存特性。</p>
<h2 id="RBAC权限设计"><a href="#RBAC权限设计" class="headerlink" title="RBAC权限设计"></a>RBAC权限设计</h2><p>先将权限分配给角色，再将角色分配给员工</p>
<p>项目是基于vue-admin-template模板进行二次开发的，侧边栏是通过根据路由表进行渲染的。在全局路由前置守卫中获取当前登录用户的信息，里面有一个包含权限点标识的数组，预先定义好的动态路由对象调用filter方法，拿到路由对象中权限标识对应的字符，如果当前用户拥有的权限标识包含的路由对象定义好的字符，然后使用router.addRoutes()添加到路由表里面。这个路由表会存到vuex中一份，渲染侧边栏时将vuex中的路由对象通过计算属性自动获取到然后渲染侧边栏</p>
<h2 id="Promise-1"><a href="#Promise-1" class="headerlink" title="Promise"></a>Promise</h2><p>Promise 是异步编程的一种解决方案，Promise是一个对象或者说是构造函数，用来封装异步操作并可以获取其成功或失败的结果，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。</p>
<h3 id="三种状态：-1"><a href="#三种状态：-1" class="headerlink" title="三种状态："></a>三种状态：</h3><ol>
<li>pending: 等待中，或者进行中，表示还没有得到结果</li>
<li>resolved(Fulfilled): 已经完成，表示得到了我们想要的结果，可以继续往下执行</li>
<li>rejected: 也表示得到结果，但是由于结果并非我们所愿，因此拒绝执行</li>
</ol>
<p>这三种状态不受外界影响，而且状态只能从pending改变为resolved或者rejected，不可逆。</p>
<h3 id="用法：-1"><a href="#用法：-1" class="headerlink" title="用法："></a>用法：</h3><p>promise的实例方法</p>
<ol>
<li>then()得到异步任务的正确结果；</li>
<li>catch()获取异常信息；</li>
<li>finally()成功与否都会执行(尚且不是正式标准)。</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ul>
<li>可以避免多层异步调用嵌套问题(回调地狱)</li>
<li>Promise 对象提供了简洁的API，使得控制异步操作更加容易</li>
</ul>
<p>缺点：</p>
<ul>
<li>promise一旦新建就会立即执行，无法中途取消</li>
<li>当处于pending状态时，无法得知当前处于哪一个状态</li>
<li>如果不设置回调函数，promise内部的错误就无法反映到外部</li>
<li>promise封装ajax时，由于promise是异步任务，发送请求的三步会被延后到整个脚本同步代码执行完，并且将响应回调函数延迟到现有队列的最后，如果大量使用会大大降低了请求效率。</li>
</ul>
<h2 id="ES6新增"><a href="#ES6新增" class="headerlink" title="ES6新增"></a>ES6新增</h2><p>Symbol、let和const、解构赋值、新对象Map和Set、扩展运算符…、Object.assign()&#x2F;Object.is()、Array.of()&#x2F;Array.from()、箭头函数、import模块导入、export default默认导出、export const 命名导出、Promise</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是一个可以访问其他函数内部变量的函数</p>
<p>主要作用</p>
<ul>
<li>解决变量污染问题</li>
<li>延长局部变量的生命周期。</li>
</ul>
<h1 id="小沩科技"><a href="#小沩科技" class="headerlink" title="小沩科技"></a>小沩科技</h1><h2 id="http请求报文-1"><a href="#http请求报文-1" class="headerlink" title="http请求报文"></a>http请求报文</h2><p>http请求包括请求行、请求头、空行和请求体组成。</p>
<p>请求行包括请求方法、URL地址和协议版本，用空格隔开。</p>
<p>请求头用于指定服务器要使用的附加信息。请求头包括：</p>
<p>Accept：向服务器申明客户端可以接收的媒体类型（MIME）的资源</p>
<p>Accept-Encoding：客户端所能够支持的压缩格式</p>
<p>Accept-Language：指定http请求返回信息时优先选择的语言</p>
<p>Connection：是否需要持久连接</p>
<p>Content-Length：是请求体内容的长度</p>
<p>Content-Type：表示http请求提交的内容类型，只有在POST方法提交时才需要设置此属性</p>
<p>Cookie：存放用户身份的数据</p>
<p>Host：请求地址</p>
<p>User-Agent：记录客户端的详细信息</p>
<p>空行就是用于分割POST请求的请求头和请求体。</p>
<p>请求体主要封装的是POST请求消息的请求参数。</p>
<h2 id="http响应报文-1"><a href="#http响应报文-1" class="headerlink" title="http响应报文"></a>http响应报文</h2><p>http请求包括状态行、响应头、空行和响应体组成。</p>
<p>状态行包括报文协议及版本、状态码以及状态描述。</p>
<p>响应头用于描述服务器的基本信息。</p>
<p>空行就是用于分割POST请求的响应头和响应体。</p>
<p>响应体主要存放服务器响应给客户端的资源内容。</p>
<h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>https：是以安全为目标的http通道，简单讲是http的安全版，即http下加入SSL层，https的安全基础是SSL，因此加密的详细内容就需要SSL。</p>
<p>https的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p>
<h3 id="https设计目标："><a href="#https设计目标：" class="headerlink" title="https设计目标："></a>https设计目标：</h3><p>(1)数据保密性：保证数据内容在传输的过程中不会被第三方查看</p>
<p>(2)数据完整性：及时发现被第三方篡改的传输内容。</p>
<p>(3)身份校验安全性：保证数据到达用户期望的目的地。</p>
<h3 id="https优点："><a href="#https优点：" class="headerlink" title="https优点："></a>https优点：</h3><ul>
<li>使用https可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>
<li>https是由SSL+http构建的可进行加密传输、身份认证的网络协议，要比http安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li>
<li>https是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li>
<li>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等http网站，采用https加密的网站在搜索结果中的排名将会更高”。</li>
</ul>
<h3 id="https缺点："><a href="#https缺点：" class="headerlink" title="https缺点："></a>https缺点：</h3><ul>
<li>https握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</li>
<li>https连接缓存不如http高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</li>
<li>SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</li>
<li>SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</li>
<li>https的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</li>
</ul>
<h3 id="http和https区别"><a href="#http和https区别" class="headerlink" title="http和https区别"></a>http和https区别</h3><p>http：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从www服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p>
<p>https：是以安全为目标的http通道，简单讲是http的安全版，即http下加入SSL层，https的安全基础是SSL，因此加密的详细内容就需要SSL。</p>
<p>https的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p>
<p>https设计目标：</p>
<p>(1)数据保密性：保证数据内容在传输的过程中不会被第三方查看</p>
<p>(2)数据完整性：及时发现被第三方篡改的传输内容。</p>
<p>(3)身份校验安全性：保证数据到达用户期望的目的地。</p>
<p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p>
<p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p>
<p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>4、http的连接很简单，是无状态的。https协议是由SSL+http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息)</p>
<p>5、https由于需要设计加密以及多次握手，性能方面不如http</p>
<h2 id="http请求"><a href="#http请求" class="headerlink" title="http请求"></a>http请求</h2><p>get：用来获取数据的，只是用来查询数据，不对服务器的数据做任何的修改，新增，删除等操作，对应select操作</p>
<p>post：数据发送到服务器以创建或更新资源，侧重于更新数据，对应update操作</p>
<p>put：数据发送到服务器以创建或更新资源，侧重于创建数据，对应insert操作</p>
<p>delete：用来删除指定的资源，它会删除URI给出的目标资源的所有当前内容，对应delete操作</p>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>操作系统中最核心的概念是进程，<strong>进程</strong>是对正在运行中的程序的一个抽象，是系统进行资源分配和调度的基本单位</p>
<p>操作系统的其他所有内容都是围绕着进程展开的，负责执行这些任务的是CPU</p>
<p><strong>线程</strong>（thread）是操作系统能够进行运算调度的最小单位，其是进程中的一个执行任务（控制单元），负责当前进程中程序的执行</p>
<p> 一个进程至少有一个线程，一个进程可以运行多个线程，这些线程共享同一块内存，线程之间可以共享对象、资源，如果有冲突或需要协同，还可以随时沟通以解决冲突或保持同步</p>
<p> <strong>本质区别</strong>：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</p>
<p><strong>在开销方面</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小</p>
<p> <strong>所处环境</strong>：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p>
<p> <strong>内存分配方面</strong>：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源</p>
<p> <strong>包含关系</strong>：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程</p>
<h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>概念：系统进程不再用到的内存，没有及时释放，就叫做<strong>内存泄漏</strong>（memory leak）。当内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p>
<h3 id="引起内存泄漏的原因："><a href="#引起内存泄漏的原因：" class="headerlink" title="引起内存泄漏的原因："></a>引起内存泄漏的原因：</h3><h4 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h4><p>由于 js 对未声明变量的处理方式是在全局对象上创建该变量的引用。如果在浏览器中，全局对象就是 window 对象。变量在窗口关闭或重新刷新页面之前都不会被释放，如果未声明的变量缓存大量的数据，就会导致内存泄露。</p>
<ul>
<li>未声明变量</li>
<li>使用 this 创建的变量(this 的指向是 window)。</li>
</ul>
<p>解决方法：</p>
<ul>
<li>避免创建全局变量</li>
<li>使用严格模式,在 JavaScript 文件头部或者函数的顶部加上 use strict</li>
</ul>
<h4 id="闭包引起的内存泄漏"><a href="#闭包引起的内存泄漏" class="headerlink" title="闭包引起的内存泄漏"></a>闭包引起的内存泄漏</h4><p>由于闭包可以读取函数内部的变量，然后让这些变量始终保存在内存中。如果在使用结束后没有将局部变量清除，就可能导致内存泄露。</p>
<p>解决方法：将事件处理函数定义在外部，解除闭包，或者在定义事件处理函数的外部函数中。</p>
<p>比如：在循环中的函数表达式，能复用最好放到循环外面。</p>
<h4 id="没有清理的DOM元素引用"><a href="#没有清理的DOM元素引用" class="headerlink" title="没有清理的DOM元素引用"></a>没有清理的DOM元素引用</h4><p>虽然在某个地方删除了元素，但是对象中还存在对dom的引用。</p>
<p>解决方法：手动删除，elements.btn &#x3D; null</p>
<h4 id="被遗忘的定时器或者回调"><a href="#被遗忘的定时器或者回调" class="headerlink" title="被遗忘的定时器或者回调"></a>被遗忘的定时器或者回调</h4><p>定时器中有 dom 的引用，即使 dom 删除了，但是定时器还在，所以内存中还是有这个 dom。</p>
<p>解决方法：</p>
<p>手动删除定时器和 dom</p>
<p>removeEventListener 移除事件监听</p>
<h3 id="vue中容易出现内存泄漏的几种情况"><a href="#vue中容易出现内存泄漏的几种情况" class="headerlink" title="vue中容易出现内存泄漏的几种情况"></a>vue中容易出现内存泄漏的几种情况</h3><p>在 Vue单页面开发应用，那么就更要当心内存泄漏的问题。因为在 SPA 的设计中，用户使用它是不需要刷新浏览器的，所以JavaScript应用需要自行清理组件来确保垃圾回收以预期的方式生效。因此开发过程中，需要时刻警惕内存泄漏的问题。</p>
<h4 id="全局变量造成的内存泄露"><a href="#全局变量造成的内存泄露" class="headerlink" title="全局变量造成的内存泄露"></a>全局变量造成的内存泄露</h4><p>声明的全局变量在切换页面的时候没有清空</p>
<h4 id="监听在-window-body-等事件没有解绑"><a href="#监听在-window-body-等事件没有解绑" class="headerlink" title="监听在 window&#x2F;body 等事件没有解绑"></a>监听在 window&#x2F;body 等事件没有解绑</h4><p>特别注意 window.addEventListener 之类的时间监听</p>
<p>解决：在页面销毁的时候将全局变量设置为null、移除事件绑定</p>
<h1 id="连帆科技"><a href="#连帆科技" class="headerlink" title="连帆科技"></a>连帆科技</h1><h2 id="匿名函数和箭头函数的区别"><a href="#匿名函数和箭头函数的区别" class="headerlink" title="匿名函数和箭头函数的区别"></a>匿名函数和箭头函数的区别</h2><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>匿名函数也叫函数表达式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> fun = <span class="hljs-keyword">function</span>(<span class="hljs-params">x,y</span>)&#123;<br>    <span class="hljs-keyword">return</span> x + y<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="箭头函数-1"><a href="#箭头函数-1" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>当函数体只有一条语句时，可以省略return</p>
<p>当参数只有一个时，可以省略()</p>
<p>缺点：IE11 或更早的版本不支持箭头函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fun</span> = (<span class="hljs-params">x,y</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> x+y<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-title function_">fun</span> = (<span class="hljs-params">x,y</span>) =&gt; x + y<br><span class="hljs-keyword">let</span> <span class="hljs-title function_">fun</span> = x =&gt; <span class="hljs-keyword">return</span> x * x<br></code></pre></td></tr></table></figure>

<h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a><strong>区别：</strong></h3><p>匿名函数的this指向全局对象window</p>
<p>箭头函数的this指向所在作用域的this</p>
<h2 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h2><ol>
<li>以函数的形式（包括普通函数、定时器函数、立即执行函数）调用时，this的指向永远都是window。比如fun();相当于window.fun();匿名函数具有全局性，匿名函数的this指向window对象</li>
<li>以方法的形式调用时，this指向调用方法的那个对象</li>
<li>以构造函数的形式调用时，this指向实例对象</li>
<li>以事件绑定函数的形式调用时，this指向绑定事件的对象</li>
<li>使用call、apply和bind调用时，this指向指定的那个对象</li>
<li>箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象)，此处指父级作用域</li>
<li>严格模式下变量必须用关键字声明后才能使用<ul>
<li>严格模式下，普通函数的this指向undefined</li>
<li>严格模式下，立即执行函数的this指向undefined</li>
<li>严格模式下，setTimeout中函数的this指向的window（与普通函数不同）</li>
<li>严格模式下，构造函数的this指向undefined，但是构造函数实例化对象的this指向的是实例化对象本身</li>
</ul>
</li>
</ol>
<h2 id="改变this的指向"><a href="#改变this的指向" class="headerlink" title="改变this的指向"></a>改变this的指向</h2><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> person = &#123;<br>  <span class="hljs-attr">fullName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">city, country</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> + <span class="hljs-string">&quot;,&quot;</span> + city + <span class="hljs-string">&quot;,&quot;</span> + country;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> person1 = &#123;<br>  <span class="hljs-attr">firstName</span>:<span class="hljs-string">&quot;Bill&quot;</span>,<br>  <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Gates&quot;</span><br>&#125;<br>person.<span class="hljs-property">fullName</span>.<span class="hljs-title function_">call</span>(person1, <span class="hljs-string">&quot;Oslo&quot;</span>, <span class="hljs-string">&quot;Norway&quot;</span>);<br></code></pre></td></tr></table></figure>

<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> person = &#123;<br>  <span class="hljs-attr">fullName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">city, country</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> + <span class="hljs-string">&quot;,&quot;</span> + city + <span class="hljs-string">&quot;,&quot;</span> + country;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> person1 = &#123;<br>  <span class="hljs-attr">firstName</span>:<span class="hljs-string">&quot;Bill&quot;</span>,<br>  <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Gates&quot;</span><br>&#125;<br>person.<span class="hljs-property">fullName</span>.<span class="hljs-title function_">apply</span>(person1, [<span class="hljs-string">&quot;Oslo&quot;</span>, <span class="hljs-string">&quot;Norway&quot;</span>]);<br></code></pre></td></tr></table></figure>

<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>	<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;WuXiaoDi&#x27;</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printName</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>&#125;<br><span class="hljs-keyword">var</span> wuXiaoDi = printName.<span class="hljs-title function_">bind</span>(obj)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(wuXiaoDi)	<span class="hljs-comment">//function()&#123;...&#125;</span><br><span class="hljs-title function_">wuXiaoDi</span>()	<span class="hljs-comment">//WuXiaoDi</span><br><br></code></pre></td></tr></table></figure>

<h3 id="区别：-1"><a href="#区别：-1" class="headerlink" title="区别："></a>区别：</h3><p><strong>call和apply接收的参数不同</strong><br>apply()方法接收俩个参数，一个是函数运行的作用域（this），另一个是参数数组。<br>call()方法第一个参数和apply()方法的一样，但是传递给函数的参数必须一 一列举出来。</p>
<p><strong>返回值区别</strong></p>
<p>bind的返回值是一个函数，而call和apply是立即调用。</p>
<h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><p><strong><code>链表</code></strong> 是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> reversePrint = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-comment">// 方法一：使用循环读取对于内容</span><br>    <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> []<br>    <span class="hljs-keyword">let</span> result = []<br>    <span class="hljs-keyword">while</span>(head) &#123;<br>        result.<span class="hljs-title function_">push</span>(head.<span class="hljs-property">val</span>)<br>        head = head.<span class="hljs-property">next</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> result.<span class="hljs-title function_">reverse</span>()<br>&#125;;<br><br><span class="hljs-keyword">var</span> reversePrint = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-comment">// 方法二： 使用递归读取内容</span><br>    <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> []<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-title function_">reversePrint</span>(head.<span class="hljs-property">next</span>)<br>    result.<span class="hljs-title function_">push</span>(head.<span class="hljs-property">val</span>)<br>    <span class="hljs-keyword">return</span> result<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h2 id="补全sum函数"><a href="#补全sum函数" class="headerlink" title="补全sum函数"></a>补全sum函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// sum(2,3)    // 5</span><br><span class="hljs-comment">// sum(2)(3)   // 5</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">...arg</span>) &#123;<br>    <span class="hljs-keyword">var</span> tmp = [...arg];<span class="hljs-comment">//第一个括号传入的参数</span><br>    <span class="hljs-keyword">var</span> _add = <span class="hljs-keyword">function</span> (<span class="hljs-params">...innerArg</span>) &#123;<br>        <span class="hljs-keyword">if</span> (innerArg.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> tmp.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123; <span class="hljs-keyword">return</span> a + b &#125;)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            [].<span class="hljs-property">push</span>.<span class="hljs-title function_">apply</span>(tmp, innerArg)<br>            <span class="hljs-comment">//Array.prototype.push.apply(arr1,arr2): 在原型上连接数组，将arr2连接在arr1的尾部，参数只能为2个，</span><br>            <span class="hljs-keyword">return</span> _add;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> _add<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)())    <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure>

<h2 id="实现一个按钮"><a href="#实现一个按钮" class="headerlink" title="实现一个按钮"></a>实现一个按钮</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.button</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">20px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">line-height</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: white;</span><br><span class="language-css">            <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">            <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.5s</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.button</span><span class="hljs-selector-pseudo">:hover</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: yellow;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="language-css">            <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0px</span> <span class="hljs-number">3px</span> <span class="hljs-number">5px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.8</span>);</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.button&#x27;</span>)</span><br><span class="language-javascript">    btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        btn.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;按钮被点击了&#x27;</span>;</span><br><span class="language-javascript">        btn.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = <span class="hljs-string">&quot;20px&quot;</span>;</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">    btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mouseleave&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        btn.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;鼠标离开按钮了&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">    btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mouseover&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        btn.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;鼠标在按钮上面了&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="ES6新增了什么"><a href="#ES6新增了什么" class="headerlink" title="ES6新增了什么"></a>ES6新增了什么</h2><p>Symbol、let和const、解构赋值、Map和Set、扩展运算符…、Object.assign()&#x2F;Object.is()、Array.of()&#x2F;Array.from()、箭头函数、import模块导入、export default默认导出、export const 命名导出、Promise</p>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它属于 JavaScript 语言的原生数据类型之一，其他数据类型是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、大整数（BigInt）、对象（Object）。</p>
<p>Symbol 值通过<code>Symbol()</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 没有参数的情况</span><br><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>();<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>();<br><br>s1 === s2 <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 有参数的情况</span><br><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><br>s1 === s2 <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<h3 id="var、let和const"><a href="#var、let和const" class="headerlink" title="var、let和const"></a>var、let和const</h3><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">1</span>;<br>&#125;<br><br>a <span class="hljs-comment">// ReferenceError: a is not defined.</span><br>b <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>

<p><code>var</code>命令会发生“变量提升”现象，即变量可以在声明之前使用，值为<code>undefined</code>。</p>
<p><code>let</code>命令所声明的变量一定要在声明后使用，否则报错。</p>
<p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p>
<p><code>let</code>实际上为 JavaScript 新增了块级作用域。</p>
<p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<p><code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。</p>
<p><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。</p>
<p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p>
<p>如果解构不成功，变量的值就等于<code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [foo, [[bar], baz]] = [<span class="hljs-number">1</span>, [[<span class="hljs-number">2</span>], <span class="hljs-number">3</span>]];<br>foo <span class="hljs-comment">// 1</span><br>bar <span class="hljs-comment">// 2</span><br>baz <span class="hljs-comment">// 3</span><br><br><span class="hljs-keyword">let</span> [ , , third] = [<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-string">&quot;baz&quot;</span>];<br>third <span class="hljs-comment">// &quot;baz&quot;</span><br><br><span class="hljs-keyword">let</span> [x, , y] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>x <span class="hljs-comment">// 1</span><br>y <span class="hljs-comment">// 3</span><br><br><span class="hljs-keyword">let</span> [head, ...tail] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>head <span class="hljs-comment">// 1</span><br>tail <span class="hljs-comment">// [2, 3, 4]</span><br><br><span class="hljs-keyword">let</span> [x, y, ...z] = [<span class="hljs-string">&#x27;a&#x27;</span>];<br>x <span class="hljs-comment">// &quot;a&quot;</span><br>y <span class="hljs-comment">// undefined</span><br>z <span class="hljs-comment">// []</span><br></code></pre></td></tr></table></figure>

<h3 id="Set和Map-1"><a href="#Set和Map-1" class="headerlink" title="Set和Map"></a>Set和Map</h3><h4 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h4><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> defaultSet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-number">12</span>,<span class="hljs-literal">true</span>])<br><span class="hljs-title class_">Set</span>(<span class="hljs-number">3</span>) &#123;<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-number">12</span>, <span class="hljs-literal">true</span>&#125;<br><span class="hljs-comment">// [[Entries]]</span><br><span class="hljs-comment">// 0: &quot;name&quot;</span><br><span class="hljs-comment">// 1: 12</span><br><span class="hljs-comment">// 2: true</span><br><span class="hljs-comment">// size: 3</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br>[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> s.<span class="hljs-title function_">add</span>(x));<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> s) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>&#125;<br><span class="hljs-comment">// 2 3 5 4</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li>
<li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li>
<li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">s.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 注意2被加入了两次</span><br><br>s.<span class="hljs-property">size</span> <span class="hljs-comment">// 2</span><br><br>s.<span class="hljs-title function_">has</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// true</span><br>s.<span class="hljs-title function_">has</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// true</span><br>s.<span class="hljs-title function_">has</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// false</span><br><br>s.<span class="hljs-title function_">delete</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// true</span><br>s.<span class="hljs-title function_">has</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<h4 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h4><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> defaultMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;zs&#x27;</span>],[<span class="hljs-string">&#x27;age&#x27;</span>,<span class="hljs-number">20</span>]])<br><span class="hljs-comment">// Map(2) &#123; &#x27;name&#x27; =&gt; &#x27;zs&#x27;, &#x27;age&#x27; =&gt; 20 &#125;</span><br><span class="hljs-comment">// 0: &#123; &#x27;name&#x27; =&gt; &#x27;zs&#x27; &#125; key:&#x27;name&#x27;, value:&#x27;zs&#x27;</span><br><span class="hljs-comment">// 1: &#123; &#x27;age&#x27; =&gt; 20 &#125; key:&#x27;age&#x27;, value: 20</span><br></code></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> data = &#123;&#125;;<br><span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myDiv&#x27;</span>);<br><br>data[element] = <span class="hljs-string">&#x27;metadata&#x27;</span>;<br>data[<span class="hljs-string">&#x27;[object HTMLDivElement]&#x27;</span>] <span class="hljs-comment">// &quot;metadata&quot;</span><br></code></pre></td></tr></table></figure>

<p>Map 结构的实例有以下属性和操作方法。</p>
<ul>
<li><strong>size 属性</strong>：<code>size</code>属性返回 Map 结构的成员总数。</li>
<li>**Map.prototype.set(key, value)**：<code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</li>
<li>**Map.prototype.get(key)**：<code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</li>
<li>**Map.prototype.has(key)**：<code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</li>
<li>**Map.prototype.delete(key)**：<code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</li>
<li>**Map.prototype.clear()**：<code>clear</code>方法清除所有成员，没有返回值</li>
</ul>
<h2 id="Promise-2"><a href="#Promise-2" class="headerlink" title="Promise"></a>Promise</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p><code>Promise</code>对象有以下两个特点。</p>
<p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</p>
<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。</p>
<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p>
<p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<h1 id="笛佛软件笔试"><a href="#笛佛软件笔试" class="headerlink" title="笛佛软件笔试"></a>笛佛软件笔试</h1><h2 id="哪些数据结构不能被for…of…遍历"><a href="#哪些数据结构不能被for…of…遍历" class="headerlink" title="哪些数据结构不能被for…of…遍历"></a>哪些数据结构不能被for…of…遍历</h2><p>ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被<code>for...of</code>循环遍历。原因在于，这些数据结构原生部署了<code>Symbol.iterator</code>属性（详见下文），另外一些数据结构没有（比如对象）。凡是部署了<code>Symbol.iterator</code>属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p>
<p>原生具备 Iterator 接口的数据结构如下。</p>
<p>Array、Map、Set、String、TypedArray、函数的 arguments 对象、NodeList 对象</p>
<h2 id="CSS属性书写顺序"><a href="#CSS属性书写顺序" class="headerlink" title="CSS属性书写顺序"></a>CSS属性书写顺序</h2><ol>
<li>布局定位属性：display &#x2F; position &#x2F; float &#x2F; clear &#x2F; visibility &#x2F; overflow（建议 display 第一个写，毕竟关系到模式）</li>
<li>自身属性：width &#x2F; height &#x2F; margin &#x2F; padding &#x2F; border &#x2F; background</li>
<li>文本属性：color &#x2F; font &#x2F; text-decoration &#x2F; text-align &#x2F; vertical-align &#x2F; white- space &#x2F; break-word</li>
<li>其他属性（CSS3）：content &#x2F; cursor &#x2F; border-radius &#x2F; box-shadow &#x2F; text-shadow &#x2F; background:linear-gradient …</li>
</ol>
<h2 id="JS获取对象属性key的方法"><a href="#JS获取对象属性key的方法" class="headerlink" title="JS获取对象属性key的方法"></a>JS获取对象属性key的方法</h2><p>for in：遍历自身的和继承的全部可枚举属性。不包括不可枚举属性和Symbol属性</p>
<p>Object.keys()：返回一个数组；获取自身（不含继承）可枚举属性。不包括不可枚举属性、Symbol属性</p>
<p>Object.getOwnPropertyNames：返回一个数组；获取自身全部（不含继承）属性名称，包括不可枚举属性，不包括Symbol属性</p>
<p>Object.getOwnPropertySymbols：返回一个数组，遍历了对象自身的所有Symbol属性</p>
<p>Reflect.ownKeys：返回一个数组；获取自身（不含继承）全部属性名称，包括不可枚举属性、Symbol。其实就是Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和</p>
<p>只有for in 包含继承的可枚举属性；</p>
<p>只有Object.getOwnPropertySymbols和Reflect.ownKeys可以包含Symbol属性；</p>
<p>只有Object.getOwnPropertyNames和Reflect.ownKeys包含不可枚举属性；</p>
<h2 id="JS全局函数"><a href="#JS全局函数" class="headerlink" title="JS全局函数"></a>JS全局函数</h2><p>decodeURI()	解码某个编码的 URI。<br>decodeURIComponent()	解码一个编码的 URI 组件。<br>encodeURI()	把字符串编码为 URI。<br>encodeURIComponent()	把字符串编码为 URI 组件。<br>escape()	对字符串进行编码。<br>eval()	计算 JavaScript 字符串，并把它作为脚本代码来执行。<br>isFinite()	检查某个值是否为有穷大的数。<br>isNaN()	检查某个值是否是数字。<br>Number()	把对象的值转换为数字。<br>parseFloat()	解析一个字符串并返回一个浮点数。<br>parseInt()	解析一个字符串并返回一个整数。<br>String()	把对象的值转换为字符串。<br>unescape()	对由 escape() 编码的字符串进行解码。</p>
<h1 id="笛佛软件面试"><a href="#笛佛软件面试" class="headerlink" title="笛佛软件面试"></a>笛佛软件面试</h1><h2 id="window的onload事件"><a href="#window的onload事件" class="headerlink" title="window的onload事件"></a>window的onload事件</h2><ol>
<li><p>onload事件会在整个页面加载完成后才会触发</p>
</li>
<li><p>window绑定一个onload事件</p>
<p>该事件对应的响应函数将会在页面加载完成之后执行</p>
<p>这样可以确保代码执行时所有的DOM对象已经加载完毕</p>
<p>html执行顺序从上到下（js代码在body前面，会导致先执行js代码，再加载dom对象），window.onload()可以解决这个问题</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.οnlοad=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>---函数中放js代码<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="window对象常见事件"><a href="#window对象常见事件" class="headerlink" title="window对象常见事件"></a>window对象常见事件</h3><h4 id="窗口加载事件"><a href="#窗口加载事件" class="headerlink" title="窗口加载事件"></a>窗口加载事件</h4><p>(1)window.onload<br><code>window.onload = function()&#123;&#125; ; </code><br>当页面内容完全加载完成之后会触发该事件(含图像,脚本文件,css,文件等),就调用的处理函数<br>传统注册事件方式,只能写一次,若有多个,以最后一个 window.onload 为准,前边的都会被覆盖<br>(2)addEventListener<br><code>window.addEventListener(&quot;load&quot;,function()&#123;&#125;); </code><br>不会被覆盖,多个也可生效,无限制<br>(3)DOMContentLoaded<br><code>document.addEventListener(&#39;DOMContentLoaded&#39;,function()&#123;&#125;); </code><br>事件触发时,仅当DOM加载完成,不包括样式表,图片,flash等. Ie9以上才支持<br>若页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间, 交互效果就不能实现，必然影响用户的体验，此时用 DOMContentLoaded 事件比较合适</p>
<h4 id="调整窗口大小事件"><a href="#调整窗口大小事件" class="headerlink" title="调整窗口大小事件"></a>调整窗口大小事件</h4><p>(1)window.onresize<br><code>window.onresize = function()&#123;&#125;</code>                                                                                                                                                        调整窗口大小加载事件,当触发时就调用的处理函数<br>只要窗口大小发生像素变化,就会触发这事件<br>响应式布局,  window.innerWidth 当前屏幕的宽度;  window.innerHeight 当前屏幕的高度<br>(2)resize<br><code>window.addEventListener(&quot;resize&quot;,function()&#123;&#125;);</code></p>
<h2 id="BOM和DOM"><a href="#BOM和DOM" class="headerlink" title="BOM和DOM"></a>BOM和DOM</h2><p>DOM（Document Object Model）即文档对象模型，用于操作页面元素，其核心对象是 document</p>
<p>BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。BOM包含DOM</p>
<p>BOM包含document、location、navigation、screen、history等对象。</p>
<h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><p>定义：用于获取或设置窗体的 URL,并且可以用于解析 URL</p>
<p>URL：统一资源定位符 (Uniform Resource Locator, URL) 是互联网上标准资源的地址<br>互联网上的每个文件都有一个唯一的 URL,包含的信息指出文件的位置以及浏览器应该怎么处理它<br>URL 的一般语法格式为：  protocol:&#x2F;&#x2F;host[:port]&#x2F;path&#x2F;[?query]#fragment   e.g: <a target="_blank" rel="noopener" href="http://www.itcast.cn/index.html?name=andy&age=18#link">http://www.itcast.cn/index.html?name=andy&amp;age=18#link</a></p>
<p>protocol：通信协议，http、ftp、maito等</p>
<p>host：主机（域名）</p>
<p>port：端口号，省略时使用方案的默认端口</p>
<p>path：路径，有零或多个”&#x2F;“符号隔开的字符串，一般用于表示主机上的一个目录或文件地址</p>
<p>query：参数，以键值对形式，通过&amp;符号分隔开</p>
<p>fragment：片段，#后面内容，常见于链接锚点</p>
<h4 id="location对象属性"><a href="#location对象属性" class="headerlink" title="location对象属性"></a>location对象属性</h4><p>location.href：获取或设置整个URL</p>
<p>location.host：返回主机（域名）</p>
<p>location.port：返回端口号，如果未写返回空字符串</p>
<p>location.pathname：返回路径</p>
<p>location.search：返回参数</p>
<p>location.hash：返回片段，#后面内容，常见于链接锚点</p>
<h3 id="navigation对象"><a href="#navigation对象" class="headerlink" title="navigation对象"></a>navigation对象</h3><p>包含有关浏览器的信息,它有很多属性, 最常用userAgent,该属性可以返回由客户机发送服务器的 user-agent 头部的值</p>
<h3 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h3><p>与浏览器历史记录进行交互（模拟前进后退按钮），该对象包含用户（在浏览器窗口中）访问过的URL。</p>
<h2 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h2><p>computed：计算属性，它具有缓存特性。</p>
<p>watch：侦听器，是Vue实例的一个属性，是用来响应数据的变化，需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。它可以监控一个变量，也可以是一个对象，一般用于监控路由、input输入框的值特殊处理等等，适用场景是一个数据影响多个数据，它不具有缓存性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-attr">computed</span>: &#123;<br>    计算属性名: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> xxx<br>    &#125;<br>  &#125;<br><span class="hljs-attr">watch</span>:&#123;<br>    被监听的数据:&#123;<br>        <span class="hljs-title function_">handler</span>(<span class="hljs-params">数据改变后的新值, 数据改变前的旧值</span>)&#123;<br>            逻辑代码<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>区别：</p>
<ul>
<li><p>功能上：computed是计算属性，watch是监听一个值的变化，然后执行对应的回调。</p>
</li>
<li><p>是否调用缓存：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调。</p>
</li>
<li><p>是否调用return：computed中的函数必须要用return返回，watch中的函数不是必须要用return。</p>
</li>
<li><p>computed默认第一次加载的时候就开始监听；watch默认第一次加载不做监听，如果需要第一次加载做监听，添加immediate属性，设置为true（immediate:true）</p>
</li>
</ul>
<h2 id="js事件委托的原理"><a href="#js事件委托的原理" class="headerlink" title="js事件委托的原理"></a>js事件委托的原理</h2><p><strong>事件委托</strong>也称为事件代理。就是利用<strong>事件冒泡</strong>，把子元素的事件都绑定到父元素上。如果子元素阻止了事件冒泡，那么委托就无法实现。</p>
<p><strong>事件冒泡</strong>：即一个元素的事件触发后，会依次一级一级往上调用父级元素的同名事件，直到window(注：IE8和之前的浏览器只到document)</p>
<p><strong>作用</strong>：</p>
<ol>
<li>节约内存</li>
<li>能为之后新增的DOM元素依然添加事件</li>
</ol>
<h2 id="节流和防抖"><a href="#节流和防抖" class="headerlink" title="节流和防抖"></a>节流和防抖</h2><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p><strong>定义</strong>：触发事件后，在n秒内，事件只执行一次，如果在n秒内又触发了事件，则会重新计算函数的执行时间。(注意，下面代码let timer&#x3D;null只执行一次)</p>
<p>比如点击按钮，2秒后调用函数，结果在1.5秒的时候又点了，则会重新计算2秒后在调用函数。</p>
<p><strong>应用场景</strong>：</p>
<ol>
<li><p>调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖；</p>
</li>
<li><p>文本编辑器实时保存，当无任何更改操作一秒后进行保存。</p>
</li>
<li><p>搜索框输入时，n秒后再请求后台数据，如果不到n秒又输入就重新等待n秒</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn,delay</span>)&#123;<br>    <span class="hljs-keyword">let</span> timer=<span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">let</span> arg=<span class="hljs-variable language_">arguments</span><br>        <span class="hljs-keyword">if</span>(timer) <span class="hljs-title function_">clearTimerout</span>(timer)<br>        timer=<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,arg)<br>        &#125;,delay)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p><strong>定义</strong>：连续发生的事件在n秒内，只执行为一次</p>
<p><strong>应用场景</strong>：</p>
<ol>
<li><p>鼠标连续不断地触发某事件（如点击），单位时间内只触发一次；</p>
</li>
<li><p>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断。例如：懒加载；</p>
</li>
<li><p>浏览器播放事件，每个一秒计算一次进度信息等。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn,delay</span>)&#123;<br>    <span class="hljs-keyword">let</span> timer=<span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">let</span> arg=<span class="hljs-variable language_">arguments</span><br>        <span class="hljs-keyword">if</span>(!timer) &#123;<br>            timer=<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,arg)<br>                timer=<span class="hljs-literal">null</span><br>            &#125;,delay)     <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="路由导航守卫"><a href="#路由导航守卫" class="headerlink" title="路由导航守卫"></a>路由导航守卫</h2><p>当路由发生跳转的时候，会触发一个钩子函数，在函数中可以通过跳转或取消或强制切换跳转地址来守卫导航，路由守卫里面必须要有一个next()调用作为出口，让路由页面跳转。</p>
<h3 id="路由前置守卫"><a href="#路由前置守卫" class="headerlink" title="路由前置守卫"></a>路由前置守卫</h3><ol>
<li>开启进度条</li>
<li>判断本地或vuex中有没有token<ol>
<li>有token，如果要去的页面是登录页，不放行，跳转首页，关闭进度条；否则放行，执行下面的逻辑代码；</li>
<li>没有token，如果要去的页面在白名单数组里面，放行；否则跳转登录页面，关闭进度条。</li>
</ol>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-title function_">async</span>(to, <span class="hljs-keyword">from</span>, next) =&gt; &#123;<br>  <span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">start</span>()<br>  <span class="hljs-comment">// 进入路由前置守卫就打开进度条 如果中断导航要关闭进度条，正常跳转后会走路由后置守卫关闭进度条</span><br>  <span class="hljs-keyword">const</span> token = store.<span class="hljs-property">getters</span>.<span class="hljs-property">token</span><br>  <span class="hljs-comment">// 登录了不能去的登录页</span><br>  <span class="hljs-comment">// 不登录只能去登录页</span><br>  <span class="hljs-keyword">if</span> (token) &#123; <span class="hljs-comment">// 登录了</span><br>    <span class="hljs-keyword">if</span> (to.<span class="hljs-property">path</span> === <span class="hljs-string">&#x27;/login&#x27;</span>) &#123; <span class="hljs-comment">// 去登录页</span><br>      <span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;/&#x27;</span>) <span class="hljs-comment">// 跳转首页</span><br>      <span class="hljs-comment">// 如果中断导航，需要自己关闭正常流程进度条</span><br>      <span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">done</span>()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">next</span>()<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果没有登录</span><br>    <span class="hljs-keyword">if</span> (whiteList.<span class="hljs-title function_">includes</span>(to.<span class="hljs-property">path</span>)) &#123; <span class="hljs-comment">// 要去的路由地址字符串是否在白名单数组里出现</span><br>      <span class="hljs-comment">// 如果出现过放行</span><br>      <span class="hljs-title function_">next</span>()<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 去别的页面不放行，并跳转登录页</span><br>      <span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;/login&#x27;</span>)<br>      <span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">done</span>()<br>    &#125;<br>  &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure>

<h3 id="路由后置守卫"><a href="#路由后置守卫" class="headerlink" title="路由后置守卫"></a>路由后置守卫</h3><p>正常next()放行跳转了，才会走后置守卫，关闭正常流程进度条</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><br>router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-title function_">getPageTitle</span>(to.<span class="hljs-property">meta</span>.<span class="hljs-property">title</span>)<br>  <span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">done</span>()<br>&#125;)<br></code></pre></td></tr></table></figure>

<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="请求拦截器"><a href="#请求拦截器" class="headerlink" title="请求拦截器"></a>请求拦截器</h3><p>目的：在发起请求时统一携带token值</p>
<p>实现：判断本地localStorage或vuex中是否有token值，如果有值就将token携带在请求头中发送给后台</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">service.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> token = store.<span class="hljs-property">getters</span>.<span class="hljs-property">token</span> || <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;token&#x27;</span>)<br>    <span class="hljs-keyword">if</span> (token) &#123;<br>      config.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;Authorization&#x27;</span>] = <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;token&#125;</span>`</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> config<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>  &#125;<br>)<br></code></pre></td></tr></table></figure>

<h3 id="响应拦截器"><a href="#响应拦截器" class="headerlink" title="响应拦截器"></a>响应拦截器</h3><p>目的：对请求回来的数据进行判断</p>
<p>实现：</p>
<ul>
<li>状态码2xx和3xx时执行第一个回调函数，如果成功success就返回响应的数据response，否则提示错误信息message并返回Promise的reject状态</li>
<li>状态码4xx和5xx时执行第二个回调函数，如果状态码为401或code逻辑码为10002，证明当前身份验证失败，token过期，然后需要清除本地token和vuex中数据，然后跳转登录页面，并返回Promise的reject状态</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js">service.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 2xx和3xx的响应状态进入这里</span><br>    <span class="hljs-comment">// response参数是axios响应对象(里面config/header/status/data)</span><br>    <span class="hljs-comment">// data字段里对应的才是后台返回的全部的数据 也是一个对象</span><br>    <span class="hljs-comment">// 第一个data是axios自带的</span><br>    <span class="hljs-comment">// console.log(response)</span><br>    <span class="hljs-keyword">const</span> &#123; success, message &#125; = response.<span class="hljs-property">data</span><br>    <span class="hljs-keyword">if</span> (success) &#123;<br>      <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 逻辑失败 把后台返回message提示文字返回到逻辑页面</span><br>      <span class="hljs-comment">// 返回Promise的reject拒绝状态 await无法接收 如果有try+catch进catch里</span><br>      <span class="hljs-title class_">Message</span>.<span class="hljs-title function_">error</span>(message)<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(message)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// console.dir(error)</span><br>    <span class="hljs-comment">// 4xx和5xx的响应状态进入这里</span><br>    <span class="hljs-comment">// &amp;&amp; 为了防止null.data报错</span><br>    <span class="hljs-title class_">Message</span>.<span class="hljs-title function_">error</span>((error.<span class="hljs-property">response</span> &amp;&amp; error.<span class="hljs-property">response</span>.<span class="hljs-property">data</span> &amp;&amp; error.<span class="hljs-property">response</span>.<span class="hljs-property">data</span>.<span class="hljs-property">message</span>) || error.<span class="hljs-property">message</span>)<br>    <span class="hljs-comment">// 上面是报错就提示，下面是具体分析</span><br>    <span class="hljs-comment">// 可以用http状态码老判断 error.response.status === 401</span><br>    <span class="hljs-comment">// 或者可以用code逻辑码判断</span><br>    <span class="hljs-keyword">if</span> (error?.<span class="hljs-property">response</span>?.<span class="hljs-property">data</span>?.<span class="hljs-property">code</span> === <span class="hljs-number">10002</span>) &#123;<br>      <span class="hljs-comment">// token过期：</span><br>      <span class="hljs-comment">// 1.清除本地token，</span><br>      <span class="hljs-comment">// 2.清除vuex，</span><br>      store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;user/logoutActions&#x27;</span>)<br>      <span class="hljs-comment">// 3.强制跳转登录页（也要把被动退出时 所在页面路由地址字符串传递给登录页）</span><br>      router.<span class="hljs-title function_">replace</span>(<span class="hljs-string">`/login?redirect=<span class="hljs-subst">$&#123;router.currentRoute.fullPath&#125;</span>`</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>  &#125;<br>)<br></code></pre></td></tr></table></figure>

<h2 id="按钮的权限管理"><a href="#按钮的权限管理" class="headerlink" title="按钮的权限管理"></a>按钮的权限管理</h2><p>前提：用户登录时返回的数据中有一个权限标识数组，包含当前用户拥有的权限</p>
<p>实现：封装自定义指令绑定到按钮标签上，传入权限点标识，如果标签要传入的标识，在当前登录的用户权限标识数组中没有找到，就移除当前标签</p>
<p>inserted()是被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)，el是指令所绑定的标签，binding.value是指令绑定的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// @/dirctives/power.js</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/store&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; <span class="hljs-comment">// 自定义指令规则对象</span><br>  <span class="hljs-title function_">inserted</span>(<span class="hljs-params">el, binding</span>) &#123; <span class="hljs-comment">// 自定义指令固定名字配置项inserted(指令所在标签，第一次被插入到真实DOM网页上的时候，此函数自动执行)</span><br>    <span class="hljs-comment">// 参数1：指令所在的标签(原生)</span><br>    <span class="hljs-comment">// 参数2：指令关联的信息对象(包含给指令传入的值)</span><br>    <span class="hljs-keyword">const</span> points = store.<span class="hljs-property">state</span>.<span class="hljs-property">user</span>.<span class="hljs-property">userInfo</span>.<span class="hljs-property">roles</span>.<span class="hljs-property">points</span> <span class="hljs-comment">// 按钮权限点英文字符串数组</span><br>    <span class="hljs-keyword">if</span> (!points.<span class="hljs-title function_">includes</span>(binding.<span class="hljs-property">value</span>)) &#123;<br>      <span class="hljs-comment">// 如果标签要传入的标识，在当前登录的用户按钮权限点数组没有找到</span><br>      <span class="hljs-comment">// 就要把这个标签移出掉</span><br>      el.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(el)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// mian.js</span><br><span class="hljs-comment">// 注册全局指令</span><br><span class="hljs-keyword">import</span> powerObj <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/dirctives/power&#x27;</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;power&#x27;</span>, powerObj)<br><br>&lt;page-tools&gt;<br>  &lt;!-- 自定义左侧内容 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">slot-left</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>共 19 条记录<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br>  &lt;!-- 自定义右侧内容 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">slot-right</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">v-power</span>=<span class="hljs-string">&quot;&#x27;import&#x27;&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;danger&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;uploadBtnFn&quot;</span>&gt;</span>导入excel<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">v-power</span>=<span class="hljs-string">&quot;&#x27;export&#x27;&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;success&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;exportBtnFn&quot;</span>&gt;</span>导出excel<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addEmpBtnFn&quot;</span>&gt;</span>新增员工<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br>&lt;/page-tools&gt;<br></code></pre></td></tr></table></figure>

<h2 id="路由模式区别"><a href="#路由模式区别" class="headerlink" title="路由模式区别"></a>路由模式区别</h2><p>hash和history模式的实现原理</p>
<ul>
<li>hash：基于锚点，以及 onhashchange 事件，通过锚点的值作为路由地址，地址发生变化出发 onhashchange 事件，在根据路径决定页面上呈现的内容</li>
<li>history： 利用H5的 history中新增的两个API <code>history.pushState()</code> 和 <code>history.replaceState()</code>，允许开发者直接更改前端路由，即更新浏览器 URL 地址而不重新发起请求(将url替换并且不刷新页面)。</li>
</ul>
<p><code>history.pushState</code> 和 <code>history.push</code> 区别</p>
<ul>
<li><code>history.pushState()</code> 不会向服务器发送请求，只会改变浏览器地址栏中的地址，并且把地址记录到历史记录中，所以可以实现客户端路由，另外IE10 以后才支持</li>
<li><code>history.push()</code> 路径发生变化，需要向服务器发送请求</li>
</ul>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理可以有效、高速地处理从很小到非常大的项目版本管理。</p>
<h3 id="集中式和分布式是什么意思"><a href="#集中式和分布式是什么意思" class="headerlink" title="集中式和分布式是什么意思"></a>集中式和分布式是什么意思</h3><p><strong>集中式版本控制</strong></p>
<p>实际上是<strong>版本库集中存放在中央服务器中，个人电脑不包含版本库的修改记录</strong>（即只包含当前的修改，没有任何历史版本）；这样，工作的时候需要从版本库中获取最新的代码；工作工作结束后，需要将本地代码推送到中央服务器；</p>
<p>缺点： </p>
<ol>
<li>安全系数低：因为版本是集中存放的，所以一旦中央服务器出现问题，那么所有的历史版本将会丢失；</li>
<li>因为本地没有历史版本，所以集中式版本控制必须联网才能工作；就是需要经常地从中央服务器拉取代码或者推送到中央服务器，如果网速很慢，就很浪费时间；</li>
</ol>
<p><strong>分布式版本控制</strong></p>
<p>分布式版本控制的特点是没有中央服务器，<strong>每一台电脑都包含所有的历史版本</strong>；当两个人或者多个人合作的时候，只需要将自己的修改推送给对方就可以；</p>
<p>优势：</p>
<ol>
<li>不需要联网：自己的电脑就有所有的历史版本，当自己修改结束以后，直接修改自己本地的版本库即可；当多人合作的时候，隔一段时间相互推送即可；</li>
<li>不必担心历史版本丢失：因为每个人电脑中都包含所有的历史版本，因此，只要不是所有人的历史版本都丢失了，其他人只要从未丢失的人那里复制一份即可；</li>
</ol>
<h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p>应用场景：</p>
<ol>
<li>当正在dev分支上开发某个项目，这时项目中出现一个bug，需要紧急修复，但是正在开发的内容只是完成一半，还不想提交，这时可以用git stash命令将修改的内容保存至堆栈区，然后顺利切换到hotfix分支进行bug修复，修复完成后，再次切回到dev分支，从堆栈中恢复刚刚保存的内容。</li>
<li>由于疏忽，本应该在dev分支开发的内容，却在master上进行了开发，需要重新切回到dev分支上进行开发，可以用git stash将内容保存至堆栈中，切回到dev分支后，再次恢复内容即可。</li>
<li>总的来说，git stash命令的作用就是将目前还不想提交的但是已经修改的内容进行保存至堆栈中，后续可以在某个分支上恢复出堆栈中的内容。stash中的内容不仅仅可以恢复到原先开发的分支，也可以恢复到其他任意指定的分支上。git stash作用的范围包括工作区和暂存区中的内容，也就是说没有提交的内容都会保存至堆栈中。</li>
</ol>
<p>git stash：能够将所有未提交的修改（工作区和暂存区）保存至堆栈中，用于后续恢复当前工作目录。</p>
<p>git stash list：查看当前stash中的内容</p>
<p>git stash pop：将当前stash中的内容弹出，并应用到当前分支对应的工作目录上。注：该命令将堆栈中最近保存的内容删除（栈是先进后出）。如果从stash中恢复的内容和当前目录中的内容发生了冲突，也就是说，恢复的内容和当前目录修改了同一行的数据，那么会提示报错，需要解决冲突，可以通过创建新的分支来解决冲突。</p>
<h1 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h1><h2 id="移动端项目"><a href="#移动端项目" class="headerlink" title="移动端项目"></a>移动端项目</h2><h3 id="组件缓存"><a href="#组件缓存" class="headerlink" title="组件缓存"></a>组件缓存</h3><p>问题：首页和个人中心页来回切换时，首页重复请求数据</p>
<p>需求：防止组件频繁创建和销毁；防止网络请求重复无用执行。</p>
<p>解决：使用keep-alive包裹一级路由挂载点和二级路由挂载点</p>
<p>bug：但发现<strong>搜索页面</strong>和<strong>详情页面</strong>多被缓存起来了 (多次进入不同的文章, 发现都是同一个文章详情)</p>
<p>原因：因为使用组件缓存，created里方法就不会重新执行请求数据</p>
<p>解决：对router-view使用exclude属性来区别, 哪些页面组件可以缓存(exclude里是组件的name名字)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">exclude</span>=<span class="hljs-string">&quot;Search,SearchResult,ArticleDetail,UserEdit&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 一级路由挂载点 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<h3 id="头像和姓名优化"><a href="#头像和姓名优化" class="headerlink" title="头像和姓名优化"></a>头像和姓名优化</h3><p>使用keep-alive缓存组件后，出现一个问题，在User&#x2F;UserEdit.vue页面修改名称和头像回到User&#x2F;index.vue中头像名称还是原先的，因为页面组件缓存后，created()内的代码不会重新执行，不会再调用接口方法请求数据。</p>
<p>解决：当更改名称和头像后，将数据保存到vuex中，然后在页面标签上直接从vuex中拿到头像和名称，不在created里面请求接口</p>
<h3 id="登录未遂页面-刷新token"><a href="#登录未遂页面-刷新token" class="headerlink" title="登录未遂页面&#x2F;刷新token"></a>登录未遂页面&#x2F;刷新token</h3><p>当在某个页面时突然401，重新登录后回到之前的页面。</p>
<p>解决：当页面401时，通过router.currentPath拿到当前路径拼接到登录页面后面，然后跳转登录页，重新登录成功后，在Login&#x2F;index.vue中通过this.$router.query.path再跳转到该页面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">request.<span class="hljs-property">js</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>  <span class="hljs-keyword">return</span> response<br>&#125;, <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>  <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">401</span>) &#123;<br>    <span class="hljs-title function_">removeToken</span>()<br>    router.<span class="hljs-title function_">replace</span>(<span class="hljs-string">`/login?path=<span class="hljs-subst">$&#123;router.currentRoute.fullPath&#125;</span>`</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>&#125;)<br><span class="hljs-title class_">Login</span>/index.<span class="hljs-property">vue</span>中<br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">onSubmit</span> () &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">isLoading</span> = <span class="hljs-literal">true</span><br>      <span class="hljs-keyword">try</span> &#123;<br>	    ......<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">replace</span>(&#123;<br>          <span class="hljs-attr">path</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">query</span>.<span class="hljs-property">path</span> || <span class="hljs-string">&#x27;/layout&#x27;</span><br>        &#125;)<br>      &#125; <br>        ......<br>    &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">request.<span class="hljs-property">js</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>  <span class="hljs-keyword">return</span> response<br>&#125;, <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>  <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">401</span>) &#123;<br>    <span class="hljs-comment">// 使用refresh_token换回新的token再继续使用，JS代码实现，用户无感知(效果好)</span><br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getNewTokenAPI</span>()<br>    <span class="hljs-title function_">setToken</span>(res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">token</span>)<br>    <span class="hljs-comment">// error.config就是上一次请求的配置对象</span><br>    error.<span class="hljs-property">config</span>.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;res.data.data.token&#125;</span>`</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">axios</span>(error.<span class="hljs-property">config</span>)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">500</span> &amp;&amp; error.<span class="hljs-property">config</span>.<span class="hljs-property">url</span> === <span class="hljs-string">&#x27;/v1_0/authorizations&#x27;</span> &amp;&amp; error.<span class="hljs-property">config</span>.<span class="hljs-property">method</span> === <span class="hljs-string">&#x27;put&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 刷新的refresh_token也过期了，</span><br>    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">clear</span>() <span class="hljs-comment">// 清除localStorage所有的token</span><br>    <span class="hljs-title class_">Notify</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;warning&#x27;</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;身份已过期，请重新登录&#x27;</span> &#125;)<br>    router.<span class="hljs-title function_">replace</span>(<span class="hljs-string">`/login?path=<span class="hljs-subst">$&#123;router.currentRoute.fullPath&#125;</span>`</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="首页-保存滚动条位置"><a href="#首页-保存滚动条位置" class="headerlink" title="首页-保存滚动条位置"></a>首页-保存滚动条位置</h3><p>在这保存了首页和我的页面切换滚动条位置</p>
<p>问题：首页滚动一些 点击我的再点击回来为何滚动条回到了顶部</p>
<p>疑惑：组件缓存keep-alive保存组件标签+样式+js变量，不会保存滚动位置</p>
<p>原因：切换到我的页面，页面不够高，没有滚动条(此滚动条是整个网页的滚动条)滚动位置会回到顶部 所以切换回首页只是内容改变了,滚动条还在顶部</p>
<p>解决1：在首页失去焦点(被切走的时候)，在它的路由对象meta中保存滚动位置（发现不能保存下来scrollTop）</p>
<ul>
<li>activated和deactivated是keep-alive特有的两个生命周期函数</li>
<li>window和document 监听网页滚动的事件</li>
<li>html标签获取scrollTop滚动的距离和设置滚动的位置</li>
</ul>
<p>解决2：当在首页时，在activated方法里面监听window滚动事件，调用scrollFn方法将当前html页面被卷去头部保存到路由对象meta中</p>
<p>当切换到我的页面，触发deactivated方法，当页面滚动时调用滚动方法scrollFn保存当前html网页被卷去的头部</p>
<p>再切换回首页时，再将路由对象中meta的scrollTop赋值给当前html页面被卷去头部</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">scrollFn</span> () &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">scrollT</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span><br>    &#125;<br>&#125;,<br>  <span class="hljs-title function_">activated</span> () &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">scrollFn</span>)<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">scrollT</span><br>  &#125;,<br>  <span class="hljs-title function_">deactivated</span> () &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">scrollFn</span>)<br>  &#125;<br></code></pre></td></tr></table></figure>

<h3 id="频道切换滚动位置保存"><a href="#频道切换滚动位置保存" class="headerlink" title="频道切换滚动位置保存"></a>频道切换滚动位置保存</h3><p>问题：频道切换(tab栏切换)没有进行路由切换，不走activated生命周期函数，滚动的位置保存不下来</p>
<p>解决：</p>
<ul>
<li><p>定义<code>channelScrollTObj</code>对象保存每个tab栏id和对应的滚动距离。</p>
</li>
<li><p>然后再滚动事件的函数中将当前页面滚动距离存到数组里面</p>
</li>
</ul>
<p>问题：但是首页tab栏切换时，滚动条位置还是不能保存，在tab栏切换的一瞬间<code>this.channelScrollTObj[this.channelId]=0</code></p>
<p>解决：当tab栏切换时，在van-tabs组件标签上绑定change事件，当tab栏切换时将<code>this.channelScrollTObj[this.channelId]</code>赋值给当前页面的滚动距离。</p>
<p>问题：但是tab栏切换时，会把切走的容器height设置为0，滚动条每页高度回到顶部，切回来的一瞬间没有高度，滚动事件从底下上来也被触发了，所以才把数据设置为0。</p>
<p>原因：</p>
<ul>
<li>切换的一瞬间先执行tab栏切换事件，再触发scrollFn方法。</li>
<li>但是在切换的一瞬间高度为0，将设置scrollTop不生效。</li>
</ul>
<p>解决：要代码慢点执行，当dom异步更新完成后再去执行这句代码，使用<code>this.$nextTick(()=&gt;&#123;&#125;)</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">data</span> () &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    ......<br>    <span class="hljs-attr">channelScrollTObj</span>: &#123;&#125; <span class="hljs-comment">// 保存每个频道的滚动位置 &#123;每个频道id：对应滚动距离&#125;</span><br>  &#125;<br>&#125;,<br><br>  <span class="hljs-title function_">scrollFn</span> () &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">scrollT</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span><br>    <span class="hljs-comment">// 同时保存当前频道的滚动距离</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">channelScrollTObj</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">channelId</span>] = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span><br>  &#125;<br>    <br>    &lt;van-tabs<br>      v-model=<span class="hljs-string">&quot;channelId&quot;</span><br>      @change=<span class="hljs-string">&quot;channelChangeFn&quot;</span><br>      animated<br>      sticky<br>      offset-top=<span class="hljs-string">&quot;1.226667rem&quot;</span><br>    &gt;<br>          <br><span class="hljs-title function_">activated</span> () &#123;<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">scrollFn</span>)<br>  <span class="hljs-comment">// 为了兼容不同手机</span><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">scrollT</span><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollTop</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">scrollT</span><br>&#125;,<br>    <br>  <span class="hljs-title function_">channelChangeFn</span> () &#123;<br>  <span class="hljs-comment">// tab切换时，这个组件内部会把切走的容器height设置为0，滚动条因为没有高度回到了顶部</span><br>  <span class="hljs-comment">// 切回来的一瞬间，没有高度，滚动事件从底下上来也被触发了，所以才把数据设置为0</span><br>  <span class="hljs-comment">// 切回来的一瞬间，没有高度，设置滚动位置也没有</span><br>    <span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">channelScrollTObj</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">channelId</span>]<br>    &#125;)<br>  &#125;,            <br></code></pre></td></tr></table></figure>

<h2 id="人资项目"><a href="#人资项目" class="headerlink" title="人资项目"></a>人资项目</h2><h3 id="页面访问权限控制"><a href="#页面访问权限控制" class="headerlink" title="页面访问权限控制"></a>页面访问权限控制</h3><p>实现思路：先将权限分配给角色，再将角色分配给员工</p>
<p>知识点：本项目中左侧侧边栏是通过路由对象渲染出来的</p>
<p>解决：当前登录用户的页面访问权限英文数组<code>userObj.roles.menus</code>动态添加到路由表中来渲染左侧侧边栏导航</p>
<ul>
<li>知识点：路由切换要匹配的路由规则对象数组存在于内存中</li>
<li>new Router时，有一些初始的路由规则对象</li>
<li>addRoutes会给路由表再额外增加一个路由规则</li>
<li>在Vuex中user.js模块中获取用户信息时，返回<code>userObj.roles.menus</code>(页面权限点英文字符串数组)</li>
<li>在路由前置守卫中用menus接收页面权限点数组</li>
<li>使用filter数组进行过滤动态路由表asyncRoutes(8个动态路由对象)</li>
<li>拿到每个路由对象的二级路由的name属性，<code>return menus.includes(routeName)</code></li>
<li>返回给filterList权限点数组中menus包含的routeName(即当前登录者拥有的权限列表，要渲染的侧边栏导航)</li>
<li>然后使用<code>router.addRoutes(filterList)</code>给路由表额外添加路由规则</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-title function_">async</span>(to, <span class="hljs-keyword">from</span>, next) =&gt; &#123;<br>  <span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">start</span>()<br>  <span class="hljs-keyword">const</span> token = store.<span class="hljs-property">getters</span>.<span class="hljs-property">token</span><br>  <span class="hljs-keyword">if</span> (token) &#123;<br>    <span class="hljs-keyword">if</span> (to.<span class="hljs-property">path</span> === <span class="hljs-string">&#x27;/login&#x27;</span>) &#123;<br>      <span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;/&#x27;</span>)<br>      <span class="hljs-comment">// 如果中断导航，需要自己关闭正常流程进度条</span><br>      <span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">done</span>()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">next</span>()<br>      <span class="hljs-keyword">if</span> (!store.<span class="hljs-property">getters</span>.<span class="hljs-property">name</span>) &#123;<br>        <span class="hljs-keyword">const</span> menus = <span class="hljs-keyword">await</span> store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;user/getUserInfoActions&#x27;</span>)<br>        <span class="hljs-comment">// 用menus权限点英文字符串和路由规则对象name匹配</span><br>        <span class="hljs-comment">// 把所有准备好的8个路由对象，取出，看看名字和menus里是否匹配，匹配就证明此登录的用户有这个页面的访问权限，就让filter收集此路由规则对象到新数组里</span><br>        <span class="hljs-keyword">const</span> filterList = asyncRoutes.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">routeObj</span> =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> routeName = routeObj.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>.<span class="hljs-title function_">toLowerCase</span>()<br>          <span class="hljs-keyword">return</span> menus.<span class="hljs-title function_">includes</span>(routeName)<br>        &#125;)<br>        filterList.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/404&#x27;</span>, <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span> &#125;)<br>        router.<span class="hljs-title function_">addRoutes</span>(filterList)<br>        store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;permission/setRoutes&#x27;</span>, filterList)<br>        <span class="hljs-title function_">next</span>(&#123;<br>          <span class="hljs-attr">path</span>: to.<span class="hljs-property">path</span>,<br>          <span class="hljs-attr">replace</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 不让回退 类似于this.$router.replace()</span><br>        &#125;)<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果没有登录</span><br>    <span class="hljs-keyword">if</span> (whiteList.<span class="hljs-title function_">includes</span>(to.<span class="hljs-property">path</span>)) &#123; <span class="hljs-comment">// 要去的路由地址字符串是否在白名单数组里出现</span><br>      <span class="hljs-comment">// 如果出现过放行</span><br>      <span class="hljs-title function_">next</span>()<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 去别的页面不放行，并跳转登录页</span><br>      <span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;/login&#x27;</span>)<br>      <span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">done</span>()<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>bug：登录后左侧只有首页选项，没有用户拥有的其他权限页面</p>
<p>原因：layout&#x2F;components&#x2F;Sidebar&#x2F;index.vue中，computed计算属性中routes数组(动态生成左边侧边栏导航)，是获取的<code>this.$router.options.routes</code>值，但是this.$router.options.routes是一次性的，只能拿到new VueRouter时配置项里routes数组(静态路由数组)，后续addRoutes添加的路由规则对象没有影响到这里，所以登录进入左侧侧边栏导航只有首页。</p>
<p>解决：在permission.js文件中存一份用户权限列表filterList给vuex中src&#x2F;store&#x2F;modules&#x2F;permission.js，然后在layout&#x2F;components&#x2F;Sidebar&#x2F;index.vue中routes使用this.$store.state.permission.routes从vuex中取值，又因为routes是计算属性，当依赖值发生变化时就会重新计算属性的值，然后重新渲染左侧侧边栏导航。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; constantRoutes &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/router&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">routes</span>: constantRoutes <span class="hljs-comment">// vuex中保存的静态数组</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123;<br>    <span class="hljs-title function_">setRoutes</span>(<span class="hljs-params">state, asyncRoutes</span>) &#123;<br>      state.<span class="hljs-property">routes</span> = [...constantRoutes, ...asyncRoutes]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//permission.js 路由前置守卫中</span><br>store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;permission/setRoutes&#x27;</span>, filterList)<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">layout/components/<span class="hljs-title class_">Sidebar</span>/index.<span class="hljs-property">vue</span>中 <br>  <span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-title function_">routes</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// return this.$router.options.routes</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">permission</span>.<span class="hljs-property">routes</span><br>    &#125;,<br></code></pre></td></tr></table></figure>

<p>bug：为何动态路由添加后，在动态路由地址刷新会跳转到404页面</p>
<p>原因：刷新页面时，刷新时所有代码都会重新执行，回归初始化；刷新时，路由从’&#x2F;‘跳转到当前地址栏地址，会走一次路由守卫的代码，动态路由还未添加，所以404。</p>
<p>解决：将静态路由表中的404路由对象注释，在全局路由前置守卫中，将404路由对象push到筛选后的路由对象数组中</p>
<p>bug：路由规则对象添加成功，但是登录出现白屏</p>
<p>原因：上面next()放行时，动态路由还没有加入到内存的路由表中</p>
<p>解决： 添加完动态路由后，立刻再跳转一次</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">next</span>() <span class="hljs-comment">// 注释掉静态路由表中的404页面路由对象再执行next()放行时出现白屏</span><br>   <span class="hljs-keyword">if</span> (!store.<span class="hljs-property">getters</span>.<span class="hljs-property">name</span>) &#123;<br>     <span class="hljs-keyword">const</span> menus = <span class="hljs-keyword">await</span> store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;user/getUserInfoActions&#x27;</span>)<br>     <span class="hljs-keyword">const</span> filterList = asyncRoutes.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">routeObj</span> =&gt;</span> &#123;<br>       <span class="hljs-keyword">const</span> routeName = routeObj.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>.<span class="hljs-title function_">toLowerCase</span>()<br>       <span class="hljs-keyword">return</span> menus.<span class="hljs-title function_">includes</span>(routeName)<br>     &#125;)<br>     filterList.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/404&#x27;</span>, <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span> &#125;)<br>     router.<span class="hljs-title function_">addRoutes</span>(filterList)<br>     store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;permission/setRoutes&#x27;</span>, filterList)<br>     <span class="hljs-title function_">next</span>(&#123;<br>       <span class="hljs-attr">path</span>: to.<span class="hljs-property">path</span>,<br>       <span class="hljs-attr">replace</span>: <span class="hljs-literal">true</span><br>     &#125;)<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>bug：退出登录后重新登录提示重复的路由对象定义</p>
<p>原因：</p>
<p>退出登录后重新登录页面并没刷新，完全依赖路由业务场景的切换(单页面应用好处：用户体验更好，切换业务场景更快)，内存里路由表中之前添加的筛选后路由规则对象还在</p>
<p>而退出登录时，把token和用户信息清除了，登录的时候，先获取到token保存到vuex和本地，然后才是跳转路由，才执行路由守卫，所有判断token有值，但是用户信息没有，重新请求，再重新添加一遍筛选后的路由对象，所以导致路由重复了</p>
<p>解决方案：在退出时让路由表回归初始化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">router/index.<span class="hljs-property">js</span>中<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">resetRouter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> newRouter = <span class="hljs-title function_">createRouter</span>()<br>  router.<span class="hljs-property">matcher</span> = newRouter.<span class="hljs-property">matcher</span> <span class="hljs-comment">// reset router</span><br>  <span class="hljs-comment">// 重置的是路由对象内部的match方法(匹配routes选项中的路由规则的)</span><br>  <span class="hljs-comment">// match里面会使用newRouter里routes一起代替掉</span><br>&#125;<br>在store/modules/user.<span class="hljs-property">js</span>的actions退出方法中调用<br>  <span class="hljs-title function_">logoutActions</span>(<span class="hljs-params">&#123; commit &#125;</span>) &#123;<br>    <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;REMOVE_TOKEN&#x27;</span>)<br>    <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;REMOVE_USER&#x27;</span>)<br>    <span class="hljs-title function_">resetRouter</span>()<br>  &#125;<br></code></pre></td></tr></table></figure>

<h3 id="按钮操作权限"><a href="#按钮操作权限" class="headerlink" title="按钮操作权限"></a>按钮操作权限</h3><p>判断：当前登录的用户是否拥有导入Excel和导出Excel的权限</p>
<p>思路：获取的用户基本资料中有roles数组包含按钮操作权限数组points，如果包含权限点标识’import’或’export’就渲染处导入Excel和导出Excel按钮</p>
<p>解决：</p>
<p>封装自定义指令v-power，使用inserted(el,binding)函数，拿到Vuex中存储的用户按钮权限点英文字符数组points，如果points不包含指令传入的权限点标识’import’或’export’，就将对应的el-button按钮移出。</p>
<p>参数1：el是指令所绑定的元素，可以用来直接操作DOM</p>
<p>参数2：binding是一个对象，包含着name指令名、value指令绑定的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/store&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; <span class="hljs-comment">// 自定义指令规则对象</span><br>  <span class="hljs-title function_">inserted</span>(<span class="hljs-params">el, binding</span>) &#123; <span class="hljs-comment">// 自定义指令固定名字配置项inserted(指令所在标签，第一次被插入到真实DOM网页上的时候，此函数自动执行)</span><br>    <span class="hljs-comment">// 参数1：指令所在的标签(原生)</span><br>    <span class="hljs-comment">// 参数2：指令关联的信息对象(包含给指令传入的值)</span><br>    <span class="hljs-keyword">const</span> points = store.<span class="hljs-property">state</span>.<span class="hljs-property">user</span>.<span class="hljs-property">userInfo</span>.<span class="hljs-property">roles</span>.<span class="hljs-property">points</span> <span class="hljs-comment">// 按钮权限点英文字符串数组</span><br>    <span class="hljs-keyword">if</span> (!points.<span class="hljs-title function_">includes</span>(binding.<span class="hljs-property">value</span>)) &#123;<br>      <span class="hljs-comment">// 如果标签要传入的标识，在当前登录的用户按钮权限点数组没有找到</span><br>      <span class="hljs-comment">// 就要把这个标签移出掉</span><br>      el.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(el)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;page-tools&gt;<br>  &lt;!-- 自定义左侧内容 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">slot-left</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>共 19 条记录<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br>  &lt;!-- 自定义右侧内容 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">slot-right</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">v-power</span>=<span class="hljs-string">&quot;&#x27;import&#x27;&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;danger&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;uploadBtnFn&quot;</span>&gt;</span>导入excel<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">v-power</span>=<span class="hljs-string">&quot;&#x27;export&#x27;&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;success&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;exportBtnFn&quot;</span>&gt;</span>导出excel<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addEmpBtnFn&quot;</span>&gt;</span>新增员工<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br>&lt;/page-tools&gt;<br></code></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2023/05/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/">http://example.com/2023/05/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/02/vue3%E5%92%8Cvue2%E5%8C%BA%E5%88%AB/"><img class="prev-cover" src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">vue3和vue2区别</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/13/Vue3%E5%AD%A6%E4%B9%A0/"><img class="next-cover" src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Vue3学习</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HTML-CSS"><span class="toc-number">1.</span> <span class="toc-text">HTML+CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML%E8%AF%AD%E4%B9%89%E5%8C%96"><span class="toc-number">1.1.</span> <span class="toc-text">HTML语义化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E6%A0%B7%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.2.</span> <span class="toc-text">CSS样式优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%BB%A7%E6%89%BF%E7%9A%84css%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.1.</span> <span class="toc-text">可以被继承的css属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%BB%A7%E6%89%BF%E7%9A%84css%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.2.</span> <span class="toc-text">不可以被继承的css属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E5%B0%BA%E5%AF%B8%E8%AE%BE%E7%BD%AE%E7%9A%84%E5%8D%95%E4%BD%8D"><span class="toc-number">1.3.</span> <span class="toc-text">CSS尺寸设置的单位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFC"><span class="toc-number">1.4.</span> <span class="toc-text">BFC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E5%92%8C%E5%A4%96%E8%BE%B9%E8%B7%9D%E5%A1%8C%E9%99%B7"><span class="toc-number">1.5.</span> <span class="toc-text">高度塌陷和外边距塌陷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7"><span class="toc-number">1.5.1.</span> <span class="toc-text">高度塌陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E8%BE%B9%E8%B7%9D%E5%A1%8C%E9%99%B7"><span class="toc-number">1.5.2.</span> <span class="toc-text">外边距塌陷</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E5%8A%A8"><span class="toc-number">1.6.</span> <span class="toc-text">浮动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D"><span class="toc-number">1.7.</span> <span class="toc-text">定位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="toc-number">1.8.</span> <span class="toc-text">自适应布局的实现方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%88%97%E5%9B%BA%E5%AE%9A%E5%8F%B3%E5%88%97%E8%87%AA%E9%80%82%E5%BA%94%EF%BC%9A"><span class="toc-number">1.8.1.</span> <span class="toc-text">左列固定右列自适应：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%8F%B3%E5%AE%BD%E5%BA%A6%E5%9B%BA%E5%AE%9A%EF%BC%8C%E4%B8%AD%E9%97%B4%E5%AE%BD%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94"><span class="toc-number">1.8.2.</span> <span class="toc-text">左右宽度固定，中间宽度自适应</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80"><span class="toc-number">1.9.</span> <span class="toc-text">圣杯布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%92%E5%AD%90%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-number">1.10.</span> <span class="toc-text">盒子水平垂直居中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80"><span class="toc-number">1.11.</span> <span class="toc-text">移动端布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80"><span class="toc-number">1.11.1.</span> <span class="toc-text">响应式布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80%EF%BC%88%E7%99%BE%E5%88%86%E6%AF%94%E5%B8%83%E5%B1%80%EF%BC%89"><span class="toc-number">1.11.2.</span> <span class="toc-text">流式布局（百分比布局）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rem%E5%B8%83%E5%B1%80"><span class="toc-number">1.11.3.</span> <span class="toc-text">rem布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vw-vh%E5%B8%83%E5%B1%80"><span class="toc-number">1.11.4.</span> <span class="toc-text">vw&#x2F;vh布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flex%E5%B8%83%E5%B1%80"><span class="toc-number">1.11.5.</span> <span class="toc-text">flex布局</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">1.12.</span> <span class="toc-text">CSS实现三角形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9D%97%E5%85%83%E7%B4%A0%E5%92%8C%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0"><span class="toc-number">1.13.</span> <span class="toc-text">块元素和行内元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E5%85%83%E7%B4%A0"><span class="toc-number">1.13.1.</span> <span class="toc-text">块元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0"><span class="toc-number">1.13.2.</span> <span class="toc-text">行内元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Javascript"><span class="toc-number">2.</span> <span class="toc-text">Javascript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#var-let-const%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.</span> <span class="toc-text">var let const区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-number">2.2.</span> <span class="toc-text">JS变量提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">JS数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.1.</span> <span class="toc-text">本质区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-number">2.3.2.</span> <span class="toc-text">类型判断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">数组去重方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-number">2.5.</span> <span class="toc-text">数组排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="toc-number">2.6.</span> <span class="toc-text">数组遍历方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB"><span class="toc-number">2.7.</span> <span class="toc-text">数组方法汇总</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E6%94%B9%E5%8F%98%E5%8E%9F%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">2.7.1.</span> <span class="toc-text">不改变原数组的方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%8E%9F%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">2.7.2.</span> <span class="toc-text">改变原数组的方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find%E5%92%8Cfilter%E5%8C%BA%E5%88%AB"><span class="toc-number">2.7.3.</span> <span class="toc-text">find和filter区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%AA%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">2.8.</span> <span class="toc-text">伪数组和数组?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">2.8.1.</span> <span class="toc-text">伪数组和数组区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF"><span class="toc-number">2.8.2.</span> <span class="toc-text">伪数组的常见场景:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E7%BB%84"><span class="toc-number">2.8.3.</span> <span class="toc-text">伪数组转换为数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="toc-number">2.8.4.</span> <span class="toc-text">判断变量是否为数组？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95"><span class="toc-number">2.9.</span> <span class="toc-text">字符串方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81-%E8%A2%8B%E9%BC%A0%E4%BA%91%E7%AC%94%E8%AF%95"><span class="toc-number">2.10.</span> <span class="toc-text">防抖和节流(袋鼠云笔试)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E9%97%AD%E5%8C%85"><span class="toc-number">2.11.</span> <span class="toc-text">js闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-%E8%A2%8B%E9%BC%A0%E4%BA%91%E7%AC%94%E8%AF%95"><span class="toc-number">2.12.</span> <span class="toc-text">JS垃圾回收机制(袋鼠云笔试)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E6%8C%87%E5%90%91"><span class="toc-number">2.13.</span> <span class="toc-text">this指向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">2.14.</span> <span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.15.</span> <span class="toc-text">事件循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.16.</span> <span class="toc-text">宏任务微任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">2.17.</span> <span class="toc-text">原型和原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">2.18.</span> <span class="toc-text">事件委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%89%A9%E5%B1%95%E7%AC%A6%E7%94%A8%E8%BF%87%E5%90%97-%E2%80%A6"><span class="toc-number">2.19.</span> <span class="toc-text">事件扩展符用过吗(…)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0%E5%92%8Carguments%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.19.1.</span> <span class="toc-text">剩余参数和arguments对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.20.</span> <span class="toc-text">浅拷贝和深拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">2.20.1.</span> <span class="toc-text">浅拷贝实现方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">2.20.2.</span> <span class="toc-text">深拷贝实现方法：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="toc-number">2.21.</span> <span class="toc-text">http请求？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9F"><span class="toc-number">2.22.</span> <span class="toc-text">http状态码？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="toc-number">2.23.</span> <span class="toc-text">http请求报文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="toc-number">2.24.</span> <span class="toc-text">http响应报文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E5%92%8Chttps%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.25.</span> <span class="toc-text">http和https协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie%E3%80%81localStorage%E3%80%81sessionStorage%E7%9A%84%E5%8C%BA%E5%88%AB-%E8%A2%8B%E9%BC%A0%E4%BA%91%E7%AC%94%E8%AF%95"><span class="toc-number">2.26.</span> <span class="toc-text">cookie、localStorage、sessionStorage的区别(袋鼠云笔试)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#token"><span class="toc-number">2.27.</span> <span class="toc-text">token</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">2.28.</span> <span class="toc-text">后台管理系统中的权限管理是怎么实现的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise"><span class="toc-number">2.29.</span> <span class="toc-text">Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">2.29.1.</span> <span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">2.29.2.</span> <span class="toc-text">应用场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">2.29.3.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">2.29.4.</span> <span class="toc-text">缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-number">2.29.5.</span> <span class="toc-text">三种状态：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95%EF%BC%9A"><span class="toc-number">2.29.6.</span> <span class="toc-text">用法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">2.29.7.</span> <span class="toc-text">Promise的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async%E5%92%8Cawait%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.29.8.</span> <span class="toc-text">async和await的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E6%98%AF%EF%BC%9F"><span class="toc-number">2.30.</span> <span class="toc-text">Promise面试题以下代码的执行结果是？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E6%98%BE%E7%A4%BA%E5%AE%8C%E6%88%90%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">2.31.</span> <span class="toc-text">一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">2.32.</span> <span class="toc-text">跨域是什么? 如何解决跨域问题?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-number">2.33.</span> <span class="toc-text">项目性能优化方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.34.</span> <span class="toc-text">图片懒加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8url%E4%B8%AD%E6%9F%A5%E8%AF%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">2.35.</span> <span class="toc-text">获取浏览器url中查询字符串的参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%E5%92%8CMap"><span class="toc-number">2.36.</span> <span class="toc-text">Set和Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">2.36.1.</span> <span class="toc-text">Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-number">2.36.2.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E5%92%8CSet%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">2.36.3.</span> <span class="toc-text">Map和Set区别：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E8%8E%B7%E5%8F%96DOM%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.37.</span> <span class="toc-text">JS获取DOM元素的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span class="toc-number">2.38.</span> <span class="toc-text">HTML5自定义属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="toc-number">2.39.</span> <span class="toc-text">节点操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#websocket%E5%92%8Chttp"><span class="toc-number">2.40.</span> <span class="toc-text">websocket和http</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript%E7%9A%84%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0"><span class="toc-number">2.41.</span> <span class="toc-text">JavaScript的全局函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue"><span class="toc-number">3.</span> <span class="toc-text">Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MVC%E5%92%8CMVVM%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.</span> <span class="toc-text">MVC和MVVM的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue2-0-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BC%BA%E9%99%B7"><span class="toc-number">3.2.</span> <span class="toc-text">Vue2.0 响应式原理与缺陷?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">Vue双向数据绑定原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E5%8F%98%E4%BA%86%EF%BC%8C%E8%A7%86%E5%9B%BE%E6%B2%A1%E5%8F%98%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">Vue中为什么数据变了，视图没变？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E4%B8%AD%E7%9A%84data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F%EF%BC%88%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%EF%BC%89"><span class="toc-number">3.5.</span> <span class="toc-text">vue中的data为什么是一个函数？（面试常问）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%AF%8F%E4%B8%AA%E5%B1%9E%E6%80%A7%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84"><span class="toc-number">3.6.</span> <span class="toc-text">Vuex是什么，每个属性是干嘛的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E8%A2%8B%E9%BC%A0%E4%BA%91%E7%AC%94%E8%AF%95"><span class="toc-number">3.7.</span> <span class="toc-text">生命周期(袋鼠云笔试)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#beforeCreate%EF%BC%88%E5%88%9B%E5%BB%BA%E5%89%8D%EF%BC%89"><span class="toc-number">3.7.1.</span> <span class="toc-text">beforeCreate（创建前）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#created%EF%BC%88%E5%88%9B%E5%BB%BA%E5%90%8E%EF%BC%89"><span class="toc-number">3.7.2.</span> <span class="toc-text">created（创建后）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#beforeMount%EF%BC%88%E6%8C%82%E8%BD%BD%E5%89%8D%EF%BC%89"><span class="toc-number">3.7.3.</span> <span class="toc-text">beforeMount（挂载前）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mounted%EF%BC%88%E6%8C%82%E8%BD%BD%E5%90%8E%EF%BC%89"><span class="toc-number">3.7.4.</span> <span class="toc-text">mounted（挂载后）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#beforeUpdate%EF%BC%88%E6%9B%B4%E6%96%B0%E5%89%8D%EF%BC%89"><span class="toc-number">3.7.5.</span> <span class="toc-text">beforeUpdate（更新前）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#updated%EF%BC%88%E6%9B%B4%E6%96%B0%E5%90%8E%EF%BC%89"><span class="toc-number">3.7.6.</span> <span class="toc-text">updated（更新后）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#beforeDestroy%EF%BC%88%E9%94%80%E6%AF%81%E5%89%8D%EF%BC%89"><span class="toc-number">3.7.7.</span> <span class="toc-text">beforeDestroy（销毁前）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#destroyed%EF%BC%88%E9%94%80%E6%AF%81%E5%90%8E%EF%BC%89"><span class="toc-number">3.7.8.</span> <span class="toc-text">destroyed（销毁后）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-if%E5%92%8Cv-show%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.8.</span> <span class="toc-text">v-if和v-show的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scoped%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-number">3.9.</span> <span class="toc-text">scoped相关知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-for%E6%9B%B4%E6%96%B0%E7%9B%91%E6%B5%8B"><span class="toc-number">3.10.</span> <span class="toc-text">v-for更新监测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8C%85%E5%90%8Edist%E7%9B%AE%E5%BD%95%E8%BF%87%E5%A4%A7%EF%BC%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9F"><span class="toc-number">3.11.</span> <span class="toc-text">打包后dist目录过大，解决办法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#watch%E5%92%8Ccomputed%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.12.</span> <span class="toc-text">watch和computed的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92"><span class="toc-number">3.13.</span> <span class="toc-text">vue组件之间的数据传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E7%BB%84%E4%BB%B6%E7%BB%99%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE"><span class="toc-number">3.13.1.</span> <span class="toc-text">父组件给子组件传递数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%BB%84%E4%BB%B6%E7%BB%99%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE"><span class="toc-number">3.13.2.</span> <span class="toc-text">子组件给父组件传递数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%BB%84%E4%BB%B6%E9%9C%80%E8%A6%81%E8%B0%83%E7%94%A8%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.13.3.</span> <span class="toc-text">子组件需要调用父组件的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E6%96%B9%E6%B3%95"><span class="toc-number">3.13.4.</span> <span class="toc-text">父组件调用子组件方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#emit%E3%80%81-on%E6%96%B9%E5%BC%8F"><span class="toc-number">3.13.4.1.</span> <span class="toc-text">$emit、$on方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87ref%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E6%96%B9%E6%B3%95"><span class="toc-number">3.13.4.2.</span> <span class="toc-text">通过ref直接调用子组件方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E5%87%86%E5%A4%87%EF%BC%88%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9Agit-svn%EF%BC%89"><span class="toc-number">3.14.</span> <span class="toc-text">管理准备（项目代码版本管理工具：git&#x2F;svn）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%981%EF%BC%9A%E6%96%B0%E6%97%A7%E9%A1%B9%E7%9B%AE%EF%BC%8C%E7%A1%AE%E4%BF%9D%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%9F"><span class="toc-number">3.14.1.</span> <span class="toc-text">问题1：新旧项目，确保有什么文件夹？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%BF%E5%88%B0%E9%A1%B9%E7%9B%AE"><span class="toc-number">3.14.2.</span> <span class="toc-text">拿到项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%982%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%97%A7%E9%A1%B9%E7%9B%AE%EF%BC%88%E8%BF%9B%E5%85%AC%E5%8F%B8%E7%AC%AC%E4%B8%80%E4%BB%B6%E4%BA%8B%EF%BC%89%E5%A6%82%E4%BD%95%E5%BE%97%E5%88%B0%E5%88%AB%E4%BA%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="toc-number">3.14.2.1.</span> <span class="toc-text">问题2：如果旧项目（进公司第一件事）如何得到别人的项目代码？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%983%EF%BC%9A%E5%85%8B%E9%9A%86%E5%91%BD%E4%BB%A4%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">3.14.2.2.</span> <span class="toc-text">问题3：克隆命令是做什么的呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">3.14.2.3.</span> <span class="toc-text">注意事项：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%984%EF%BC%9A%E5%A6%82%E6%9E%9C%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%9C%89%E6%9B%B4%E6%96%B0%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8B%BF%E5%88%B0%E6%9B%B4%E6%96%B0%E4%BB%A5%E5%90%8E%E7%9A%84%E5%86%85%E5%AE%B9%E5%88%B0%E6%9C%AC%E5%9C%B0%EF%BC%9F"><span class="toc-number">3.14.2.4.</span> <span class="toc-text">问题4：如果远程仓库有更新，如何拿到更新以后的内容到本地？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E9%80%81%E9%A1%B9%E7%9B%AE"><span class="toc-number">3.14.3.</span> <span class="toc-text">推送项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%986%EF%BC%9A%E6%9C%AC%E5%9C%B0git%E8%AE%B0%E5%BD%95%E6%9C%89%E5%BE%88%E5%A4%9A%E6%AC%A1%EF%BC%8C%E4%B8%80%E6%AC%A1%E6%80%A7%E4%BF%9D%E5%AD%98%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8A%EF%BC%9F"><span class="toc-number">3.14.3.1.</span> <span class="toc-text">问题6：本地git记录有很多次，一次性保存到远程仓库上？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#git%E5%91%BD%E4%BB%A4"><span class="toc-number">3.15.</span> <span class="toc-text">git命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%86%E6%94%AF%E6%98%8E%E7%BB%86"><span class="toc-number">3.15.1.</span> <span class="toc-text">1.分支明细</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%86%E6%94%AF%E5%91%BD%E4%BB%A4"><span class="toc-number">3.15.2.</span> <span class="toc-text">2.分支命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9A%82%E6%97%B6%E4%BF%9D%E5%AD%98%E6%9B%B4%E6%94%B9"><span class="toc-number">3.15.3.</span> <span class="toc-text">3.暂时保存更改</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.16.</span> <span class="toc-text">Vue修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this-nextTick"><span class="toc-number">3.17.</span> <span class="toc-text">this.$nextTick()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">3.17.1.</span> <span class="toc-text">使用原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.17.2.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#route%E5%92%8C-router"><span class="toc-number">3.18.</span> <span class="toc-text">$route和$router</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#route"><span class="toc-number">3.18.1.</span> <span class="toc-text">$route</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#router"><span class="toc-number">3.18.2.</span> <span class="toc-text">$router</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E4%B8%ADhash%E5%92%8Chistory%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.19.</span> <span class="toc-text">Vue中hash和history的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">3.20.</span> <span class="toc-text">单向数据流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E4%B8%AD%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.21.</span> <span class="toc-text">Vue中父子组件生命周期</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">Vue面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E4%B8%ADkeep-alive%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">vue中keep-alive组件的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%EF%BC%9A%EF%BC%88%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%86%99%E6%B3%95%E6%98%AF%E5%B0%86%E7%BB%84%E4%BB%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BC%93%E5%AD%98%EF%BC%89"><span class="toc-number">4.1.1.</span> <span class="toc-text">实际应用：（下面的写法是将组件在内存中进行缓存）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#include-%E5%92%8C-exclude-%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.1.2.</span> <span class="toc-text">include 和 exclude 属性的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E4%B8%AD%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-number">4.2.</span> <span class="toc-text">Vue中如何编写可复用的组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%9D%9E%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%EF%BC%8C%E7%BD%91%E9%80%9F%E6%85%A2%E6%97%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B5%E9%9D%A2%E9%97%AA%E5%8A%A8%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.</span> <span class="toc-text">如何解决非工程化项目，网速慢时初始化页面闪动问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-number">4.4.</span> <span class="toc-text">组件之间双向绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scoped-CSS%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">4.5.</span> <span class="toc-text">Scoped CSS的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">4.5.1.</span> <span class="toc-text">区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">4.5.1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">4.5.1.2.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%81-deep-%E3%80%81-v-deep%E6%B7%B1%E5%BA%A6%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">4.5.2.</span> <span class="toc-text">&gt;&gt;&gt;、&#x2F;deep&#x2F;、::v-deep深度选择器的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">4.5.2.1.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">4.5.2.2.</span> <span class="toc-text">原理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E6%A0%87%E6%85%A7%E5%AE%89"><span class="toc-number">5.</span> <span class="toc-text">中标慧安</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE6px%E5%A4%A7%E5%B0%8F%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">怎么设置6px大小？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E5%AD%97%E6%BA%A2%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7"><span class="toc-number">5.2.</span> <span class="toc-text">文字溢出显示省略号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%A1%8C%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA"><span class="toc-number">5.2.1.</span> <span class="toc-text">单行文本溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA"><span class="toc-number">5.2.2.</span> <span class="toc-text">多行文本溢出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">5.3.</span> <span class="toc-text">css实现三角形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8"><span class="toc-number">5.4.</span> <span class="toc-text">清除浮动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#html5%E6%96%B0%E5%A2%9E%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">5.5.</span> <span class="toc-text">html5新增了什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE"><span class="toc-number">5.5.1.</span> <span class="toc-text">语义化标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webStorage-%E5%82%A8%E5%AD%98%E6%9C%BA%E5%88%B6-sessionStorage-%E5%92%8C-localStorage"><span class="toc-number">5.5.2.</span> <span class="toc-text">webStorage 储存机制 sessionStorage 和 localStorage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#history-%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.5.3.</span> <span class="toc-text">history 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0input%E6%96%B0%E5%A2%9E%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">5.5.4.</span> <span class="toc-text">表单元素input新增的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%AA%92%E4%BD%93"><span class="toc-number">5.5.5.</span> <span class="toc-text">多媒体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E7%BB%98%E7%94%BB%E7%9A%84-canvas"><span class="toc-number">5.5.6.</span> <span class="toc-text">用于绘画的 canvas</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.6.</span> <span class="toc-text">css隐藏元素的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack%E7%83%AD%E6%9B%B4%E6%96%B0"><span class="toc-number">5.7.</span> <span class="toc-text">webpack热更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E5%88%B0%E7%9A%84webpack%E5%B1%9E%E6%80%A7"><span class="toc-number">5.8.</span> <span class="toc-text">用到的webpack属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE-1"><span class="toc-number">5.9.</span> <span class="toc-text">原型和原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">5.10.</span> <span class="toc-text">vue组件通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4"><span class="toc-number">5.11.</span> <span class="toc-text">常用git命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E4%BB%A3%E7%A0%81%E6%8E%A8%E9%80%81%E8%87%B3master%E4%B8%BB%E5%88%86%E6%94%AF"><span class="toc-number">5.11.1.</span> <span class="toc-text">将代码推送至master主分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-%E6%8A%8Amaster%E5%88%86%E6%94%AF%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%88%86%E6%94%AF"><span class="toc-number">5.11.2.</span> <span class="toc-text">git 把master分支代码合并到自己的分支</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">5.12.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for%E5%92%8CforEach%E5%A6%82%E4%BD%95%E4%B8%AD%E6%96%AD%E5%BE%AA%E7%8E%AF"><span class="toc-number">5.13.</span> <span class="toc-text">for和forEach如何中断循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E4%B8%ADwatch%E5%92%8Ccomputed%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.14.</span> <span class="toc-text">vue中watch和computed的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RBAC%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.15.</span> <span class="toc-text">RBAC权限设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-1"><span class="toc-number">5.16.</span> <span class="toc-text">Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9A-1"><span class="toc-number">5.16.1.</span> <span class="toc-text">三种状态：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95%EF%BC%9A-1"><span class="toc-number">5.16.2.</span> <span class="toc-text">用法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">5.16.3.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6%E6%96%B0%E5%A2%9E"><span class="toc-number">5.17.</span> <span class="toc-text">ES6新增</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">5.18.</span> <span class="toc-text">闭包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E6%B2%A9%E7%A7%91%E6%8A%80"><span class="toc-number">6.</span> <span class="toc-text">小沩科技</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87-1"><span class="toc-number">6.1.</span> <span class="toc-text">http请求报文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87-1"><span class="toc-number">6.2.</span> <span class="toc-text">http响应报文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#https"><span class="toc-number">6.3.</span> <span class="toc-text">https</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#https%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87%EF%BC%9A"><span class="toc-number">6.3.1.</span> <span class="toc-text">https设计目标：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#https%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">6.3.2.</span> <span class="toc-text">https优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#https%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">6.3.3.</span> <span class="toc-text">https缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E5%92%8Chttps%E5%8C%BA%E5%88%AB"><span class="toc-number">6.3.4.</span> <span class="toc-text">http和https区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E8%AF%B7%E6%B1%82"><span class="toc-number">6.4.</span> <span class="toc-text">http请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">6.5.</span> <span class="toc-text">进程和线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-number">6.6.</span> <span class="toc-text">内存泄露</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E8%B5%B7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="toc-number">6.6.1.</span> <span class="toc-text">引起内存泄漏的原因：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%84%8F%E5%A4%96%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">6.6.1.1.</span> <span class="toc-text">意外的全局变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E5%BC%95%E8%B5%B7%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">6.6.1.2.</span> <span class="toc-text">闭包引起的内存泄漏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E6%B8%85%E7%90%86%E7%9A%84DOM%E5%85%83%E7%B4%A0%E5%BC%95%E7%94%A8"><span class="toc-number">6.6.1.3.</span> <span class="toc-text">没有清理的DOM元素引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A2%AB%E9%81%97%E5%BF%98%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8%E6%88%96%E8%80%85%E5%9B%9E%E8%B0%83"><span class="toc-number">6.6.1.4.</span> <span class="toc-text">被遗忘的定时器或者回调</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E4%B8%AD%E5%AE%B9%E6%98%93%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">6.6.2.</span> <span class="toc-text">vue中容易出现内存泄漏的几种情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E9%80%A0%E6%88%90%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-number">6.6.2.1.</span> <span class="toc-text">全局变量造成的内存泄露</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%9C%A8-window-body-%E7%AD%89%E4%BA%8B%E4%BB%B6%E6%B2%A1%E6%9C%89%E8%A7%A3%E7%BB%91"><span class="toc-number">6.6.2.2.</span> <span class="toc-text">监听在 window&#x2F;body 等事件没有解绑</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9E%E5%B8%86%E7%A7%91%E6%8A%80"><span class="toc-number">7.</span> <span class="toc-text">连帆科技</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.1.</span> <span class="toc-text">匿名函数和箭头函数的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.1.</span> <span class="toc-text">匿名函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0-1"><span class="toc-number">7.1.2.</span> <span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">7.1.3.</span> <span class="toc-text">区别：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E7%9A%84%E6%8C%87%E5%90%91"><span class="toc-number">7.2.</span> <span class="toc-text">this的指向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B9%E5%8F%98this%E7%9A%84%E6%8C%87%E5%90%91"><span class="toc-number">7.3.</span> <span class="toc-text">改变this的指向</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#call"><span class="toc-number">7.3.1.</span> <span class="toc-text">call</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#apply"><span class="toc-number">7.3.2.</span> <span class="toc-text">apply</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bind"><span class="toc-number">7.3.3.</span> <span class="toc-text">bind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%EF%BC%9A-1"><span class="toc-number">7.3.4.</span> <span class="toc-text">区别：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">7.4.</span> <span class="toc-text">翻转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%A8sum%E5%87%BD%E6%95%B0"><span class="toc-number">7.5.</span> <span class="toc-text">补全sum函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%8C%89%E9%92%AE"><span class="toc-number">7.6.</span> <span class="toc-text">实现一个按钮</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6%E6%96%B0%E5%A2%9E%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">7.7.</span> <span class="toc-text">ES6新增了什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol"><span class="toc-number">7.7.1.</span> <span class="toc-text">Symbol</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#var%E3%80%81let%E5%92%8Cconst"><span class="toc-number">7.7.2.</span> <span class="toc-text">var、let和const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">7.7.3.</span> <span class="toc-text">解构赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E5%92%8CMap-1"><span class="toc-number">7.7.4.</span> <span class="toc-text">Set和Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Set-1"><span class="toc-number">7.7.4.1.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map-1"><span class="toc-number">7.7.4.2.</span> <span class="toc-text">Map</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-2"><span class="toc-number">7.8.</span> <span class="toc-text">Promise</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%9B%E4%BD%9B%E8%BD%AF%E4%BB%B6%E7%AC%94%E8%AF%95"><span class="toc-number">8.</span> <span class="toc-text">笛佛软件笔试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8D%E8%83%BD%E8%A2%ABfor%E2%80%A6of%E2%80%A6%E9%81%8D%E5%8E%86"><span class="toc-number">8.1.</span> <span class="toc-text">哪些数据结构不能被for…of…遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E5%B1%9E%E6%80%A7%E4%B9%A6%E5%86%99%E9%A1%BA%E5%BA%8F"><span class="toc-number">8.2.</span> <span class="toc-text">CSS属性书写顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7key%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">8.3.</span> <span class="toc-text">JS获取对象属性key的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0"><span class="toc-number">8.4.</span> <span class="toc-text">JS全局函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%9B%E4%BD%9B%E8%BD%AF%E4%BB%B6%E9%9D%A2%E8%AF%95"><span class="toc-number">9.</span> <span class="toc-text">笛佛软件面试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#window%E7%9A%84onload%E4%BA%8B%E4%BB%B6"><span class="toc-number">9.1.</span> <span class="toc-text">window的onload事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#window%E5%AF%B9%E8%B1%A1%E5%B8%B8%E8%A7%81%E4%BA%8B%E4%BB%B6"><span class="toc-number">9.1.1.</span> <span class="toc-text">window对象常见事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%8A%A0%E8%BD%BD%E4%BA%8B%E4%BB%B6"><span class="toc-number">9.1.1.1.</span> <span class="toc-text">窗口加载事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E4%BA%8B%E4%BB%B6"><span class="toc-number">9.1.1.2.</span> <span class="toc-text">调整窗口大小事件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BOM%E5%92%8CDOM"><span class="toc-number">9.2.</span> <span class="toc-text">BOM和DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#location%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.2.1.</span> <span class="toc-text">location对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#location%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7"><span class="toc-number">9.2.1.1.</span> <span class="toc-text">location对象属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#navigation%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.2.2.</span> <span class="toc-text">navigation对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#history%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.2.3.</span> <span class="toc-text">history对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.3.</span> <span class="toc-text">computed和watch的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">9.4.</span> <span class="toc-text">js事件委托的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96"><span class="toc-number">9.5.</span> <span class="toc-text">节流和防抖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%8A%96"><span class="toc-number">9.5.1.</span> <span class="toc-text">防抖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E6%B5%81"><span class="toc-number">9.5.2.</span> <span class="toc-text">节流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB"><span class="toc-number">9.6.</span> <span class="toc-text">路由导航守卫</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB"><span class="toc-number">9.6.1.</span> <span class="toc-text">路由前置守卫</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%90%8E%E7%BD%AE%E5%AE%88%E5%8D%AB"><span class="toc-number">9.6.2.</span> <span class="toc-text">路由后置守卫</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">9.7.</span> <span class="toc-text">拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">9.7.1.</span> <span class="toc-text">请求拦截器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">9.7.2.</span> <span class="toc-text">响应拦截器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E9%92%AE%E7%9A%84%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-number">9.8.</span> <span class="toc-text">按钮的权限管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB"><span class="toc-number">9.9.</span> <span class="toc-text">路由模式区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git"><span class="toc-number">9.10.</span> <span class="toc-text">Git</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E4%B8%AD%E5%BC%8F%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="toc-number">9.10.1.</span> <span class="toc-text">集中式和分布式是什么意思</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-stash"><span class="toc-number">9.10.2.</span> <span class="toc-text">git stash</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%9A%BE%E7%82%B9"><span class="toc-number">10.</span> <span class="toc-text">项目难点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE"><span class="toc-number">10.1.</span> <span class="toc-text">移动端项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%BC%93%E5%AD%98"><span class="toc-number">10.1.1.</span> <span class="toc-text">组件缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E5%83%8F%E5%92%8C%E5%A7%93%E5%90%8D%E4%BC%98%E5%8C%96"><span class="toc-number">10.1.2.</span> <span class="toc-text">头像和姓名优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E6%9C%AA%E9%81%82%E9%A1%B5%E9%9D%A2-%E5%88%B7%E6%96%B0token"><span class="toc-number">10.1.3.</span> <span class="toc-text">登录未遂页面&#x2F;刷新token</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A6%96%E9%A1%B5-%E4%BF%9D%E5%AD%98%E6%BB%9A%E5%8A%A8%E6%9D%A1%E4%BD%8D%E7%BD%AE"><span class="toc-number">10.1.4.</span> <span class="toc-text">首页-保存滚动条位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%91%E9%81%93%E5%88%87%E6%8D%A2%E6%BB%9A%E5%8A%A8%E4%BD%8D%E7%BD%AE%E4%BF%9D%E5%AD%98"><span class="toc-number">10.1.5.</span> <span class="toc-text">频道切换滚动位置保存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%BA%E8%B5%84%E9%A1%B9%E7%9B%AE"><span class="toc-number">10.2.</span> <span class="toc-text">人资项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-number">10.2.1.</span> <span class="toc-text">页面访问权限控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E9%92%AE%E6%93%8D%E4%BD%9C%E6%9D%83%E9%99%90"><span class="toc-number">10.2.2.</span> <span class="toc-text">按钮操作权限</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chenxz21/bcxm" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">微信公众号: 小白一只手</div></div></div></div></main><footer id="footer" style="background: #FFFFFF"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/chenxz21/hexo-theme-bcxm">Bcxm</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/leancloud-storage@4.10.0/dist/av-min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>