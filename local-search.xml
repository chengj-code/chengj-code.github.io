<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/05/17/hello-world/"/>
    <url>/2025/05/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vue3和vue2区别</title>
    <link href="/2023/06/02/vue3%E5%92%8Cvue2%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/06/02/vue3%E5%92%8Cvue2%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="Vue3的变化"><a href="#Vue3的变化" class="headerlink" title="Vue3的变化"></a>Vue3的变化</h2><p>响应式原理，组合式API，支持多个根节点(Fragments)（好处：减少标签层级，减小内存占用），生命周期变化，使用方法时需要先导入，pinia状态管理工具</p><h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><p><strong>Vue2</strong>：使用数据劫持和订阅发布者模式实现数据的响应式，通过Object.defineProperty()劫持数据的setter和getter，在数据发生变化时发布消息给订阅者，订阅者收到消息后进行相应的处理。</p><p>问题：</p><ul><li>Vue2的Object.defineProperty()不能检测对象的新增属性和通过数组下标或length属性给数据重新赋值。</li><li>对象中包含对象时会一次性递归到底，开销较大</li></ul><p>解决：Vue.$set</p><p><strong>Vue3</strong>是基于ES6的Proxy API对数据代理。解决了Object.defineProperty()的缺点</p><p><strong>惰性监听</strong>：</p><ul><li>reactive只对obj的第一层进行代理，第二层children不是响应式的</li><li>当obj.children获取的时候再进行第二层的代理</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj=<span class="hljs-title function_">reactive</span>(&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;zd&#x27;</span>,<br>    <span class="hljs-attr">children</span>: &#123; <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;zl&#x27;</span> &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="组合式API"><a href="#组合式API" class="headerlink" title="组合式API"></a>组合式API</h2><p>Vue2使用选项式API，分为data、method、computed等</p><p>Vue3使用组合式API</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>import &#123;ref&#125; from &#x27;vue&#x27;<br>setup()&#123;<br>    const num=ref(0)<br>    const addNum=()=&gt;&#123;<br>        return num.value++<br>    &#125;<br>    return&#123;<br>        num, addNum<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>setup语法糖写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123;ref&#125; from &#x27;vue&#x27;<br>const num=ref(0)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="定义变量和方法"><a href="#定义变量和方法" class="headerlink" title="定义变量和方法"></a>定义变量和方法</h2><p>Vue2：在data(){}中定义数据变量，在method:{}中创建方法。</p><p>Vue3：</p><ul><li>在setup方法中使用ref&#x2F;reactive定义响应式数据，定义方法，然后return出去</li><li>使用setup语法糖时，可以直接定义数据和方法</li></ul><h2 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h2><p>Vue3生命周期函数可以执行多次，多次执行传入的回调会在时机成熟时<strong>依次执行</strong></p><p>使用上 Vue3 组合式 API 需要先引入；Vue2 选项 API 则可直接调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">vue2           -- -----&gt;      vue3--------&gt;      vue3<br>选项式<span class="hljs-variable constant_">API</span>  选项式<span class="hljs-variable constant_">API</span>    组合式<span class="hljs-variable constant_">API</span><br>beforeCreate   --------&gt;      <span class="hljs-title function_">setup</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;) <br>created        --------&gt;      <span class="hljs-title function_">setup</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)<br>beforeMount    --------&gt;      <span class="hljs-title function_">onBeforeMount</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)                --------&gt;      <span class="hljs-title function_">onBeforeMount</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)<br>mounted        --------&gt;      <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)                    --------&gt;      <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)<br>beforeUpdate   --------&gt;      <span class="hljs-title function_">onBeforeUpdate</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)               --------&gt;      <span class="hljs-title function_">onBeforeUpdate</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)<br>updated        --------&gt;      <span class="hljs-title function_">onUpdated</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)                    --------&gt;      <span class="hljs-title function_">onUpdated</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)<br>beforeDestroy  --------&gt;      <span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)              --------&gt;      <span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)<br>destroyed      --------&gt;      <span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)                  --------&gt;      <span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)<br>activated      --------&gt;      <span class="hljs-title function_">onActivated</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)                  --------&gt;      <span class="hljs-title function_">onActivated</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)<br>deactivated    --------&gt;      <span class="hljs-title function_">onDeactivated</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)                --------&gt;      <span class="hljs-title function_">onDeactivated</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)<br>errorCaptured  --------&gt;      <span class="hljs-title function_">onErrorCaptured</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)              --------&gt;      <span class="hljs-title function_">onErrorCaptured</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)<br></code></pre></td></tr></table></figure><h2 id="Vue3父子组件通信"><a href="#Vue3父子组件通信" class="headerlink" title="Vue3父子组件通信"></a>Vue3父子组件通信</h2><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><p>父组件中给子组件绑定属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> son <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./son.vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">200</span>)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  count.<span class="hljs-property">value</span>=<span class="hljs-number">2000</span><br> &#125;,<span class="hljs-number">3000</span>)<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>父组件<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">son</span> <span class="hljs-attr">message</span>=<span class="hljs-string">&quot;father message&quot;</span> <span class="hljs-attr">:count</span>=<span class="hljs-string">&quot;count&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">son</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>子组件中通过props选项接收：通过宏函数defineProps({属性名: 类型})</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-keyword">const</span> props=<span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">message</span>: <span class="hljs-title class_">String</span>,<br>  <span class="hljs-attr">count</span>:<span class="hljs-title class_">Number</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(props);<br>&lt;/script&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;son&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>子组件<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>父组件传入的数据： &#123;&#123; message &#125;&#125;----&#123;&#123;count&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><p>父组件中给子组件标签通过@绑定事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> son1 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./son1.vue&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getMessage</span>=(<span class="hljs-params">msg</span>)=&gt;&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg);<br> &#125;<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>父组件<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 1.绑定自定义事件 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">son1</span> @<span class="hljs-attr">getSonMessage</span>=<span class="hljs-string">&quot;getMessage&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">son1</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>子组件内部通过$emit方法出触发事件：通过宏函数defineEmits([‘自定义事件名’])</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-comment">// 2.通过defineEmits()拿到emit方法</span><br><span class="hljs-keyword">const</span> emit =<span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;getSonMessage&#x27;</span>])<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">sendMsg</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-comment">// 3.触发自定义事件，传数据给父组件</span><br>  <span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;getSonMessage&#x27;</span>,<span class="hljs-string">&#x27;this is son message&#x27;</span>)<br> &#125;<br>&lt;/script&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;son&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>子组件<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sendMsg&quot;</span>&gt;</span>触发自定义事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="ref和reactive"><a href="#ref和reactive" class="headerlink" title="ref和reactive"></a>ref和reactive</h2><p>reactive() 作用：接收对象类型数据的参数传入，并返回一个响应式的对象</p><p>ref() 作用：接收简单类型或对象类型数据的参数传入，并返回一个响应式的对象，在模板中直接使用，在js中通过.value属性访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>// 1.导入函数<br>import &#123; reactive &#125; from &#x27;vue&#x27;;<br>// 2.执行函数，传入一个对象类型的参数，变量接收<br>const state = reactive(&#123; count: 0 &#125;)<br>const setCount = () =&gt; &#123;<br>  state.count++<br>&#125;<br>&lt;/script&gt;<br>&lt;script setup&gt;<br>// 1.导入函数<br>import &#123; ref &#125; from &#x27;vue&#x27;;<br>// 2.执行函数，传入一个对象类型的参数，变量接收<br>const state = ref(0)<br>const setCount = () =&gt; &#123;<br>  // 脚本区域修改ref产生的响应式对象数据 必须通过.value属性<br>  state.value++<br> &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="通过ref获取组件实例"><a href="#通过ref获取组件实例" class="headerlink" title="通过ref获取组件实例"></a>通过ref获取组件实例</h3><p>需要先定义ref(null)，然后通过.value获取组件实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import son1 from &#x27;./son1.vue&#x27;<br>import &#123; ref, onMounted &#125; from &#x27;vue&#x27;;<br>const h2ref = ref(null)<br>const son1ref = ref(null)<br>onMounted(() =&gt; &#123;<br>  console.log(h2ref.value);<br>  console.log(son1ref.value.name)<br>&#125;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;div class=&quot;father&quot;&gt;<br>    &lt;h2 ref=&quot;h2ref&quot;&gt;顶层组件&lt;/h2&gt;<br>    &lt;!-- 1.绑定自定义事件 --&gt;<br>    &lt;son1 ref=&quot;son1ref&quot; @getSonMessage=&quot;getMessage&quot;&gt;&lt;/son1&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h2 id="provide和reject"><a href="#provide和reject" class="headerlink" title="provide和reject"></a>provide和reject</h2><p>作用：顶层组件向任意的底层组件传递数据和方法，实现跨层组件通信</p><p>跨层传递普通数据</p><ol><li><p>顶层组件通过provide函数提供数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;key&#x27;</span>, 顶层组件中的数据)<br></code></pre></td></tr></table></figure></li><li><p>底层组件通过inject函数获取数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> message=<span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;key&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ol><p>跨层传递方法</p><p>顶层组件可以向底层组件传递方法，底层组件调用方法修改顶层组件中的数据</p><p>在不破坏单向数据流的前提下修改顶层组件的数据，谁的数据谁修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 顶层组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">setCount</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  count.<span class="hljs-property">value</span>++<br>&#125;<br><span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;funtion-key&#x27;</span>, setCount)<br><span class="hljs-comment">// 底层组件</span><br><span class="hljs-keyword">const</span> setCount = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;funtion-key&#x27;</span>)<br>    &lt;button @click=<span class="hljs-string">&quot;setCount&quot;</span>&gt;修改顶层数据&lt;/button&gt;<br></code></pre></td></tr></table></figure><h2 id="pinia状态管理工具"><a href="#pinia状态管理工具" class="headerlink" title="pinia状态管理工具"></a>pinia状态管理工具</h2><p>pinia安装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install pinia<br></code></pre></td></tr></table></figure><p>在main.js中注册</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createPinia &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><span class="hljs-keyword">const</span> pinia=<span class="hljs-title function_">createPinia</span>()<br><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">use</span>(pinia).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>新建stores&#x2F;counter.js</p><ul><li>state数据通过ref定义响应式数据</li><li>getters数据通过computed计算属性方法定义</li><li>将所有定义的变量和方法全部return出去</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><span class="hljs-keyword">import</span> &#123; computed, ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCounterStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;counter&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// state属性</span><br>    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br>    <span class="hljs-comment">// actions同步方法</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        count.<span class="hljs-property">value</span>++<br>    &#125;<br>    <span class="hljs-comment">// actions异步方法</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">API_URL</span> = <span class="hljs-string">&#x27;http://geek.itheima.net/v1_0/channels&#x27;</span><br>    <span class="hljs-keyword">const</span> list = <span class="hljs-title function_">ref</span>([])<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">getList</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-variable constant_">API_URL</span>)<br>        <span class="hljs-comment">// console.log(res);</span><br>        list.<span class="hljs-property">value</span>=res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">channels</span><br>     &#125;<br>    <span class="hljs-comment">// getters计算属性</span><br>    <span class="hljs-keyword">const</span> computedCount = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span> * <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> &#123;<br>        count, increment, computedCount, list, getList<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>在页面中导入使用</p><ul><li><p>如果直接解构赋值，会丢失数据的响应式</p><p><code>const &#123; count, computedCount &#125; = counterStore</code></p></li><li><p>使用storeToRef方法包裹保持数据响应式</p><p><code>const &#123; count, computedCount &#125; = storeToRefs(counterStore)</code></p></li><li><p>方法直接从原来的counterStore中解构赋值<br><code>const &#123; increment &#125; = counterStore</code></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; useCounterStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./stores/counter&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; storeToRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span>;<br><span class="hljs-comment">// 执行方法得到store实例对象</span><br><span class="hljs-keyword">const</span> counterStore = <span class="hljs-title function_">useCounterStore</span>()<br><span class="hljs-comment">// 直接解构赋值 响应式的丢失</span><br><span class="hljs-comment">// const &#123; count, computedCount &#125; = counterStore</span><br><span class="hljs-comment">// 方法包裹 保持响应式更细</span><br><span class="hljs-keyword">const</span> &#123; count, computedCount &#125; = <span class="hljs-title function_">storeToRefs</span>(counterStore)<br><span class="hljs-comment">// 方法直接从原来的counterStore中解构赋值</span><br><span class="hljs-keyword">const</span> &#123; increment &#125; = counterStore<br><span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  counterStore.<span class="hljs-title function_">getList</span>()<br> &#125;)<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>&#123;&#123; computedCount &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in counterStore.list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="v-model原理不同"><a href="#v-model原理不同" class="headerlink" title="v-model原理不同"></a>v-model原理不同</h2><h3 id="Vue2的v-model原理"><a href="#Vue2的v-model原理" class="headerlink" title="Vue2的v-model原理"></a>Vue2的v-model原理</h3><p>v-model 是语法糖，本质还是父子组件间的通信</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;set-input v-model=<span class="hljs-string">&quot;msg&quot;</span> /&gt;<br>运行后：<br>&lt;set-input :value=<span class="hljs-string">&quot;msg&quot;</span> @input=<span class="hljs-string">&quot;msg=$events&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>.sync语法糖的使用</p><p>.sync 和 v-model 都是语法糖，本质还是父子组件间的通信。使用 .sync 修饰符实现父子组件多个数据双向绑定。</p><p>因为 vue2 中组件只能定义一个 v-model，如果父子需要实现多个数据双向绑定，就需要借助 .sync 修饰符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;child-comp v-model=<span class="hljs-string">&quot;msg&quot;</span> :foo.<span class="hljs-property">sync</span>=<span class="hljs-string">&quot;foo&quot;</span>  /&gt;<br>  <br><span class="hljs-comment">//可翻译为</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">child-comp</span> </span></span><br><span class="hljs-tag"><span class="language-xml"> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;msg&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;msg=$event&quot;</span>   </span></span><br><span class="hljs-tag"><span class="language-xml"> <span class="hljs-attr">:foo</span>=<span class="hljs-string">&quot;foo&quot;</span> @<span class="hljs-attr">update:foo</span>=<span class="hljs-string">&quot;foo=$event&quot;</span>  /&gt;</span></span><br></code></pre></td></tr></table></figure><p>一个组件上的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，但是像单选框、复选框等类型的输入控件可能会将 <code>value</code> 用于不同的目的。<code>model</code> 选项可以用来避免这样的冲突</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;base-checkbox v-model=<span class="hljs-string">&quot;lovingVue&quot;</span>&gt;&lt;/base-checkbox&gt;<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;base-checkbox&#x27;</span>, &#123;<br>  <span class="hljs-attr">model</span>: &#123;<br>    <span class="hljs-attr">prop</span>: <span class="hljs-string">&#x27;checked&#x27;</span>,<br>    <span class="hljs-attr">event</span>: <span class="hljs-string">&#x27;change&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">checked</span>: <span class="hljs-title class_">Boolean</span><br>  &#125;,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;input</span><br><span class="hljs-string">      type=&quot;checkbox&quot;</span><br><span class="hljs-string">      v-bind:checked=&quot;checked&quot;</span><br><span class="hljs-string">      v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;</span><br><span class="hljs-string">    &gt;</span><br><span class="hljs-string">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="Vue3的v-model原理"><a href="#Vue3的v-model原理" class="headerlink" title="Vue3的v-model原理"></a>Vue3的v-model原理</h3><h4 id="在原生标签上使用"><a href="#在原生标签上使用" class="headerlink" title="在原生标签上使用"></a>在原生标签上使用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;input v-model=<span class="hljs-string">&quot;searchText&quot;</span> /&gt;<br><span class="hljs-comment">// 翻译后  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;searchText&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">  @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;searchText = $event.target.value&quot;</span>/&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="在组件上使用"><a href="#在组件上使用" class="headerlink" title="在组件上使用"></a>在组件上使用</h4><p>默认情况下，<code>v-model</code> 在组件上都是使用 <code>modelValue</code> 作为 prop，并以 <code>update:modelValue</code> 作为对应的事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;<span class="hljs-title class_">CustomInput</span> v-model=<span class="hljs-string">&quot;searchText&quot;</span> 可翻译为/&gt;<br><span class="hljs-comment">// 可翻译为</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">CustomInput</span></span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">:modelValue</span>=<span class="hljs-string">&quot;searchText&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">  @<span class="hljs-attr">update:modelValue</span>=<span class="hljs-string">&quot;newValue =&gt; searchText = newValue&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">/&gt;</span></span><br><span class="hljs-comment">// 子组件内</span><br>&lt;!-- <span class="hljs-title class_">CustomInput</span>.<span class="hljs-property">vue</span> --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">defineProps</span>([<span class="hljs-string">&#x27;modelValue&#x27;</span>])</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;update:modelValue&#x27;</span>])</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;modelValue&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">  /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>      <br></code></pre></td></tr></table></figure><p>可以通过给 <code>v-model</code> 指定一个参数来更改这些名字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;<span class="hljs-title class_">MyComponent</span> v-<span class="hljs-attr">model</span>:title=<span class="hljs-string">&quot;bookTitle&quot;</span> /&gt;<br>    <br>&lt;!-- <span class="hljs-title class_">MyComponent</span>.<span class="hljs-property">vue</span> --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">defineProps</span>([<span class="hljs-string">&#x27;title&#x27;</span>])</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;update:title&#x27;</span>])</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;title&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;update:title&#x27;, $event.target.value)&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">  /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>    <br></code></pre></td></tr></table></figure><p>在 vue3 一个组件可以使用多个 v-model ，统一了 vue2 的 v-model 和 .sync 修饰符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;<span class="hljs-title class_">UserName</span><br>  v-<span class="hljs-attr">model</span>:first-name=<span class="hljs-string">&quot;first&quot;</span><br>  v-<span class="hljs-attr">model</span>:last-name=<span class="hljs-string">&quot;last&quot;</span><br>/&gt;<br>    <br>  <span class="hljs-comment">//可翻译为</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">child-comp</span> </span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">:first-name</span>=<span class="hljs-string">&quot;name&quot;</span> @<span class="hljs-attr">update:first-name</span>=<span class="hljs-string">&quot;name=$event&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">:last-name</span>=<span class="hljs-string">&quot;age&quot;</span> @<span class="hljs-attr">update:last-name</span>=<span class="hljs-string">&quot;age=$event&quot;</span> /&gt;</span></span> <br>      <br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">defineProps</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">firstName</span>: <span class="hljs-title class_">String</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">lastName</span>: <span class="hljs-title class_">String</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;update:firstName&#x27;</span>, <span class="hljs-string">&#x27;update:lastName&#x27;</span>])</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;firstName&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;update:firstName&#x27;, $event.target.value)&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">  /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;lastName&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;update:lastName&#x27;, $event.target.value)&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">  /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><h3 id="Vue2自定义指令"><a href="#Vue2自定义指令" class="headerlink" title="Vue2自定义指令"></a>Vue2自定义指令</h3><p>使用Vue.directive</p><p>一个指令定义对象可以提供如下几个钩子函数 </p><ul><li><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li><li><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li><li><code>update</code>：所在组件的 VNode 更新时调用，<strong>但是可能发生在其子 VNode 更新之前</strong>。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</li></ul><p>指令钩子函数会被传入以下参数</p><ul><li><code>el</code>：指令所绑定的元素，可以用来直接操作 DOM。</li><li>binding：一个对象，包含以下 property：<ul><li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</li><li><code>value</code>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code>。</li><li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li><li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>。</li><li><code>arg</code>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。</li><li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>&#123; foo: true, bar: true &#125;</code>。</li></ul></li><li><code>vnode</code>：Vue 编译生成的虚拟节点。移步 <a href="https://v2.cn.vuejs.org/v2/api/#VNode-%E6%8E%A5%E5%8F%A3">VNode API</a> 来了解更多详情。</li><li><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Vue全局指令封装</span><br><span class="hljs-comment">// 封装中间件函数插件</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">install</span> () &#123;<br>    <span class="hljs-comment">// 全局自定义指令，针对指令所在的原生标签调用focus方法</span><br>    <span class="hljs-comment">// 指令所在标签 被插入到真实DOM时才触发 如果标签用display:none隐藏再出现，不会触发inserted</span><br>    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;fofo&#x27;</span>, &#123;<br>      <span class="hljs-title function_">inserted</span> (el) &#123;<br>        <span class="hljs-title function_">fn</span>(el)<br>      &#125;,<br>      <span class="hljs-title function_">update</span> (el) &#123;<br>        <span class="hljs-comment">// 指令所在标签被更新时就触发</span><br>        <span class="hljs-title function_">fn</span>(el)<br>      &#125;<br>    &#125;)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span> (<span class="hljs-params">el</span>) &#123;<br>  <span class="hljs-keyword">if</span> (el.<span class="hljs-property">nodeName</span> === <span class="hljs-string">&#x27;TEXTAREA&#x27;</span> || el.<span class="hljs-property">nodeName</span> === <span class="hljs-string">&#x27;INPUT&#x27;</span>) &#123;<br>    el.<span class="hljs-title function_">focus</span>()<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// el本身不是输入框 尝试往里获取一下</span><br>    <span class="hljs-keyword">const</span> theInput = el.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;input&#x27;</span>)<br>    <span class="hljs-keyword">const</span> theTextarea = el.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;textarea&#x27;</span>)<br>    <span class="hljs-comment">// 判断：不一定获取的到，需要加判断，有值了再执行.foucs()才不报错</span><br>    <span class="hljs-keyword">if</span> (theInput) theInput.<span class="hljs-title function_">focus</span>()<br>    <span class="hljs-keyword">if</span> (theTextarea) theTextarea.<span class="hljs-title function_">focus</span>()<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">import</span> directiveObj <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/directive&#x27;</span><br><span class="hljs-comment">// 执行目标对象里的install方法并传入Vue类</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(directiveObj)<br></code></pre></td></tr></table></figure><h3 id="Vue3自定义指令"><a href="#Vue3自定义指令" class="headerlink" title="Vue3自定义指令"></a>Vue3自定义指令</h3><p>指令钩子函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myDirective = &#123;<br>  <span class="hljs-comment">// 在绑定元素的 attribute 前</span><br>  <span class="hljs-comment">// 或事件监听器应用前调用</span><br>  <span class="hljs-title function_">created</span>(<span class="hljs-params">el, binding, vnode, prevVnode</span>) &#123;<br>    <span class="hljs-comment">// 下面会介绍各个参数的细节</span><br>  &#125;,<br>  <span class="hljs-comment">// 在元素被插入到 DOM 前调用</span><br>  <span class="hljs-title function_">beforeMount</span>(<span class="hljs-params">el, binding, vnode, prevVnode</span>) &#123;&#125;,<br>  <span class="hljs-comment">// 在绑定元素的父组件</span><br>  <span class="hljs-comment">// 及他自己的所有子节点都挂载完成后调用</span><br>  <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el, binding, vnode, prevVnode</span>) &#123;&#125;,<br>  <span class="hljs-comment">// 绑定元素的父组件更新前调用</span><br>  <span class="hljs-title function_">beforeUpdate</span>(<span class="hljs-params">el, binding, vnode, prevVnode</span>) &#123;&#125;,<br>  <span class="hljs-comment">// 在绑定元素的父组件</span><br>  <span class="hljs-comment">// 及他自己的所有子节点都更新后调用</span><br>  <span class="hljs-title function_">updated</span>(<span class="hljs-params">el, binding, vnode, prevVnode</span>) &#123;&#125;,<br>  <span class="hljs-comment">// 绑定元素的父组件卸载前调用</span><br>  <span class="hljs-title function_">beforeUnmount</span>(<span class="hljs-params">el, binding, vnode, prevVnode</span>) &#123;&#125;,<br>  <span class="hljs-comment">// 绑定元素的父组件卸载后调用</span><br>  <span class="hljs-title function_">unmounted</span>(<span class="hljs-params">el, binding, vnode, prevVnode</span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 自定义指令简化形式</span><br>&lt;div v-color=<span class="hljs-string">&quot;color&quot;</span>&gt;&lt;/div&gt;<br>app.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">el, binding</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 这会在 `mounted` 和 `updated` 时都调用</span><br>  el.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = binding.<span class="hljs-property">value</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>定义懒加载指令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/directives/index.js</span><br><span class="hljs-comment">// 自定义懒加载指令</span><br><span class="hljs-keyword">import</span> &#123; useIntersectionObserver &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@vueuse/core&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> lazyPlugin = &#123;<br>    <span class="hljs-title function_">install</span>(<span class="hljs-params">app</span>) &#123;<br>        <span class="hljs-comment">// 懒加载指令逻辑</span><br>        app.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;lazy-img&#x27;</span>, &#123;<br>            <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el, binding</span>) &#123;<br>                <span class="hljs-comment">// el：指令绑定的那个元素 img</span><br>                <span class="hljs-comment">// binding：binding.value 指令等于号后面绑定的表达式的值 图片url</span><br>                <span class="hljs-keyword">const</span> &#123; stop &#125; = <span class="hljs-title function_">useIntersectionObserver</span>(<br>                    el, <span class="hljs-function">(<span class="hljs-params">[&#123; isIntersecting &#125;]</span>) =&gt;</span> &#123;<br>                        <span class="hljs-keyword">if</span> (isIntersecting) &#123;<br>                            <span class="hljs-comment">// 证明进入视口区域</span><br>                            el.<span class="hljs-property">src</span> = binding.<span class="hljs-property">value</span><br>                            <span class="hljs-title function_">stop</span>()<br>                        &#125;<br>                    &#125;<br>                )<br>            &#125;<br>        &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// mian.js中</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; lazyPlugin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/directives/index&#x27;</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br>app.<span class="hljs-title function_">use</span>(lazyPlugin)<br></code></pre></td></tr></table></figure><h1 id="Vue2和3对比"><a href="#Vue2和3对比" class="headerlink" title="Vue2和3对比"></a>Vue2和3对比</h1><h2 id="脚手架创建项目"><a href="#脚手架创建项目" class="headerlink" title="脚手架创建项目"></a>脚手架创建项目</h2><p>问怎么用脚手架创建vue项目。</p><blockquote><p>❝</p><p>2.x</p><p>npm install -g vue-cli （npm uninstall -g vue-cli 删）</p><p>vue init webpack “项目名称”</p><p>进入项目 npm run dev</p><p>❞</p></blockquote><blockquote><p>❝</p><p>3.x</p><p>npm install -g @vue&#x2F;cli （npm uninstall -g @vue&#x2F;cli 删）</p><p>或者npm install vue@next(最新最稳定版)</p><p>npm install -g @vue&#x2F;cli-init</p><p>vue create 项目名称</p><p>进入项目 npm run serve</p><p>❞</p></blockquote><h3 id="vue3新特性"><a href="#vue3新特性" class="headerlink" title="vue3新特性"></a>vue3新特性</h3><ol><li>支持碎片Fragments，模板可以有多个根元素</li><li>提供了composition api，更好的逻辑复用与代码组织</li><li>响应式数据声明方式改变</li><li>生命周期的改变</li><li>父子组件传参不同</li><li>vue3 Teleport瞬移组件(类似于react的Portals传送门)</li><li>vue3中v-for与v-if,只会把当前v-if当做v-for中的一个判断语句，不会相互冲突</li><li>vue3中移除keyCode作为v-on的修饰符，当然也不支持config.keyCodes</li><li>vue3中移除过滤器filter</li><li>computed和watch变成组合式的</li><li>数据响应重新实现（ES6的proxy代替Es5的Object.defineProperty）</li><li>源码使用ts重写，更好的类型推导</li><li>虚拟DOM新算法（更快，更小）</li></ol><h4 id="一-响应原理对比"><a href="#一-响应原理对比" class="headerlink" title="一.响应原理对比"></a>一.响应原理对比</h4><p><strong>「vue2使用Object.defineProperty方法实现响应式数据」</strong></p><blockquote><p>❝</p><p>缺点：</p><ul><li>无法检测到对象属性的动态添加和删除</li><li>无法检测到数组的下标和length属性的变更</li><li>深度监听需要递归到底，性能层面考虑不太好</li></ul><p>解决方案：</p><ul><li>vue2提供Vue.$set动态给对象添加属性</li><li>Vue.$delete动态删除对象属性</li><li>也可以通过splice解决数组中的问题，object.assign解决批量添加对象属性的问题</li></ul><p>❞</p></blockquote><p>Object.defineProperty还存在一个缺点：不能检测数组变化。2.x中是通过重写数组方法实现的对数组的监听。</p><p><strong>「vue3使用proxy实现响应式数据」</strong></p><blockquote><p>❝</p><p>优点：</p><ul><li>可以检测到代理对象属性的动态新增和删除</li><li>可以检测数组的下标和length属性的变化</li></ul><p>缺点：</p><ul><li>es6的proxy不支持低版本浏览器 IE11</li><li>会针对IE11出一个特殊版本进行支持</li><li>无法polyfill</li></ul><p>❞</p></blockquote><h4 id="二-Composition-API"><a href="#二-Composition-API" class="headerlink" title="二. Composition API"></a>二. Composition API</h4><p>Vue2使用选项类型API（Options API）：选项型API在代码里<strong>「分割了不同的属性」</strong>: data,computed属性，methods，等等。</p><p>Vue3使用合成型API（Composition API）：新的合成型API能让我们<strong>「用方法（function）来分割」</strong>，相比于旧的API使用属性来分组，这样代<strong>「码会更加简便和整洁」</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-comment">// 2.0</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">props</span>: &#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span><br>    &#125;,<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>            <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;&#x27;</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-title function_">login</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-comment">// 登陆方法</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">components</span>: &#123;<br>        <span class="hljs-string">&quot;buttonComponent&quot;</span>: btnComponent<br>    &#125;,<br>    <span class="hljs-attr">computed</span>: &#123;<br>        <span class="hljs-title function_">fullName</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 3.0</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">props</span>: &#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span><br>    &#125;,<br><br>    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-comment">//数据</span><br>            <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>            <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>            <span class="hljs-attr">lowerCaseUsername</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> state.<span class="hljs-property">username</span>.<span class="hljs-title function_">toLowerCase</span>()) <span class="hljs-comment">//计算属性</span><br>        &#125;)<br>        <span class="hljs-comment">//方法</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">login</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>            <span class="hljs-comment">// 登陆方法</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;<br>            login,<br>            state<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="composition-API-解决了什么问题"><a href="#composition-API-解决了什么问题" class="headerlink" title="composition API 解决了什么问题"></a>composition API 解决了什么问题</h5><p><strong>「options API」</strong></p><ul><li>条例清晰：相同的放在相同的地方，比如方法都放在methods中，状态都在data中</li><li>调用时使用this，逻辑过多时this指向不明确</li><li>代码分散：一个功能的代码往往散落在不同的options种，比如data methods等等，这也导致新添加功能的时候需要在各种options中反复横跳，这时候如果代码行数较多那是要命的</li><li>逻辑过于复杂的场景可以将某个功能代码抽象出mixin，但是这会导致数据来源不明确，在template中有个count变量，你会不知道他到底是来源于data还是mixin还是vue.prototype设置的全局变量。除此之外，如果存在多个mixin还可能存在同名变量被覆盖的问题。</li></ul><p><strong>「composition API」</strong></p><ul><li>将一个功能的代码整合到一起，方便开发的同时也便于代码复用。总之就是更好的代码组织方式和更好的代码复用。</li><li>没有对this的使用，避免了指向不明确的情况</li><li>全部都是函数，更加方便类型推断</li></ul><h4 id="三-建立数据-data"><a href="#三-建立数据-data" class="headerlink" title="三.建立数据 data"></a>三.建立数据 data</h4><p>VUE2.0中将数据放入到data属性中，在VUE3.0中使用setup()方法，此方法在组件初始化构造的时候触发。</p><p>使用以下三步来建立响应式数据:</p><ol><li>从vue引入reactive</li><li>使用reactive()方法来声名我们的数据为响应性数据</li><li>使用setup()方法来返回我们的响应性数据，从而template可以获取这些响应性数据</li></ol><p>可以通过state.username和state.password获得数据的值。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span> </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">state.username</span> &#125;&#125;</span><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="四-碎片"><a href="#四-碎片" class="headerlink" title="四.碎片"></a>四.碎片</h4><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">// 2.0</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;form-element&#x27;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span> </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">title</span> &#125;&#125;</span><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">// 3.0</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;form-element&#x27;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span> </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">title</span> &#125;&#125;</span><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="五-生命周期钩子函数改变"><a href="#五-生命周期钩子函数改变" class="headerlink" title="五.生命周期钩子函数改变"></a>五.生命周期钩子函数改变</h4><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xl">Vue2--------------vue3<br><span class="hljs-function"><span class="hljs-title">beforeCreate</span>  -&gt;</span> setup()开始创建组件之前，在beforeCreate和created之前执行。创建的是<span class="hljs-keyword">data</span>和method<br><span class="hljs-function"><span class="hljs-title">created</span>       -&gt;</span> setup()<br><span class="hljs-function"><span class="hljs-title">beforeMount</span>   -&gt;</span> onBeforeMount 组件挂载到节点上之前执行的函数。<br><span class="hljs-function"><span class="hljs-title">mounted</span>       -&gt;</span> onMounted 组件挂载完成后执行的函数。<br><span class="hljs-function"><span class="hljs-title">beforeUpdate</span>  -&gt;</span> onBeforeUpdate 组件更新之前执行的函数。<br><span class="hljs-function"><span class="hljs-title">updated</span>       -&gt;</span> onUpdated 组件更新完成之后执行的函数。<br><span class="hljs-function"><span class="hljs-title">beforeDestroy</span> -&gt;</span> onBeforeUnmount 组件卸载之前执行的函数。<br><span class="hljs-function"><span class="hljs-title">destroyed</span>     -&gt;</span> onUnmounted 组件卸载完成后执行的函数<br><span class="hljs-function"><span class="hljs-title">activated</span>     -&gt;</span> onActivated 被包含在中的组件，会多出两个生命周期钩子函数。被激活时执行 。<br><span class="hljs-function"><span class="hljs-title">deactivated</span>   -&gt;</span> onDeactivated 比如从 A组件，切换到 B 组件，A 组件消失时执行。<br></code></pre></td></tr></table></figure><h4 id="六-父子传参"><a href="#六-父子传参" class="headerlink" title="六.父子传参"></a>六.父子传参</h4><ol><li>setup 函数时，它将接受两个参数：（props、context(包含attrs、slots、emit)）</li><li>setup函数是处于生命周期函数 beforeCreate 和 Created 两个钩子函数之前的函数</li><li>执行 setup 时，组件实例尚未被创建（在 setup() 内部，this 不会是该活跃实例的引用，即不指向vue实例，<strong>「Vue 为了避免我们错误的使用，直接将 setup函数中的this修改成了 undefined」</strong>）</li><li>与模板一起使用：需要返回一个对象 (在setup函数中定义的变量和方法最后都是需要 return 出去的不然无法在模板中使用)</li><li>使用渲染函数：可以返回一个渲染函数，该函数可以直接使用在同一作用域中声明的响应式状态</li><li>setup 函数中的 props 是响应式的，当传入新的 prop 时，它将被更新。但是，因为 props 是响应式的，你<strong>「不能使用 ES6 解构，因为它会消除 prop 的响应性」</strong>。如果需要解构 prop，可以通过<strong>「使用 setup 函数中的toRefs」</strong> 来完成此操作</li></ol><h5 id="父传子-1"><a href="#父传子-1" class="headerlink" title="父传子"></a>父传子</h5><p>所以当父组件向子组件中传递，和2.x版本中没有太多区别，但是如果需要从props中派生处数据时，需要从setup函数中接收。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">// 父组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">Son</span> <span class="hljs-attr">:msg</span>=<span class="hljs-string">&quot;state.msg&quot;</span>/&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/components/transParams/Son&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123;reactive&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Parent&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123;<span class="hljs-title class_">Son</span>&#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> state =<span class="hljs-title function_">reactive</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;父组件传递给子组件的参数&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      state</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">// 子组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>这里是子组件啦<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>这里是父组件传递过来的值呀：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">msg</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Son&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">msg</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">type</span>:<span class="hljs-title class_">String</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">default</span>:<span class="hljs-string">&#x27;&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(props) <span class="hljs-comment">//Proxy &#123;msg: &#x27;父组件传递给子组件的参数&#x27;&#125;</span></span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="子传父（emit-event）"><a href="#子传父（emit-event）" class="headerlink" title="子传父（emit event）"></a>子传父（emit event）</h5><p>子组件向父组件传递至差别比较大：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">//父组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>这里是父组件啦<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>这里是子组件传递过来的值呀：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">state.sonMsg</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span> </span><br><span class="language-xml">  <span class="hljs-comment">&lt;!-- 子传父：定义子组件emit时的函数sonSendMsg，并且绑定到父组件中注册的receiveMessageFromSon函数 --&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">Son</span> @<span class="hljs-attr">sonSendMsg</span>=<span class="hljs-string">&quot;receiveMessageFromSon&quot;</span> <span class="hljs-attr">:msg</span>=<span class="hljs-string">&quot;state.msg&quot;</span>/&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/components/transParams/Son&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123;reactive&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Parent&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123;<span class="hljs-title class_">Son</span>&#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> state =<span class="hljs-title function_">reactive</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;父组件传递给子组件的参数&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">sonMsg</span>:<span class="hljs-string">&#x27;&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//子传父：定义接收函数</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">receiveMessageFromSon</span> =(<span class="hljs-params">data</span>)=&gt;&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      state.<span class="hljs-property">sonMsg</span>=data.<span class="hljs-property">sonMsg</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      state,</span></span><br><span class="language-javascript"><span class="language-xml">      receiveMessageFromSon</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">// 子组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>这里是子组件啦<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sendMsgToParent&quot;</span>&gt;</span>向父组件传递数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>这里是父组件传递过来的值呀：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">msg</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Son&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">//差别一：子组件向父组件传值要注册emits</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">emits</span>:[<span class="hljs-string">&#x27;sonSendMsg&#x27;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">msg</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">type</span>:<span class="hljs-title class_">String</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">default</span>:<span class="hljs-string">&#x27;&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props,&#123; attrs, slots, emit &#125;</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">sendMsgToParent</span> =(<span class="hljs-params"></span>)=&gt;&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 差别二：向父组件传递参数：不再通过this.$emit触发函数</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;sonSendMsg&#x27;</span>, &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">sonMsg</span>:<span class="hljs-string">&#x27;子组件传递过来的数据&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">      &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      sendMsgToParent</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>「setup函数只能是同步的不能是异步的」</strong></p><h4 id="七-vue3-Teleport瞬移组件"><a href="#七-vue3-Teleport瞬移组件" class="headerlink" title="七.vue3 Teleport瞬移组件"></a>七.vue3 Teleport瞬移组件</h4><p>类比react中的传送门将组件挂载到想挂载的DOM上。</p><p>比如创建一个modal组件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">teleport</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;#modal&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isOpen&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span>this is a modal<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;buttonClick&quot;</span>&gt;</span>Close<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">teleport</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;TeleportComponent&quot;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">props</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">isOpen</span>: <span class="hljs-title class_">Boolean</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">closeModal</span>:<span class="hljs-title class_">Function</span></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">emits</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-string">&#x27;closeModal&#x27;</span>: <span class="hljs-literal">null</span></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, context</span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">buttonClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">      context.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;closeModal&#x27;</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      buttonClick</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#center</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid black;</span><br><span class="language-css">  <span class="hljs-attribute">background</span>: white;</span><br><span class="language-css">  <span class="hljs-attribute">position</span>: fixed;</span><br><span class="language-css">  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">100px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span> <br></code></pre></td></tr></table></figure><p>使用方法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;modal&quot;</span>&gt;</span>这是modal即将挂载的元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showModal&quot;</span>&gt;</span>点击我，打开Modal<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">teleport-component</span> <span class="hljs-attr">:isOpen</span>=<span class="hljs-string">&quot;isModalOpen&quot;</span> <span class="hljs-attr">:closeModal</span>=<span class="hljs-string">&quot;closeModal&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">TeleportComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/TeleportComponent.vue&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;TeleportPage&quot;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>:&#123;<span class="hljs-title class_">TeleportComponent</span>&#125;,</span><br><span class="language-javascript">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> isModalOpen = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> closeModal = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">      isModalOpen.<span class="hljs-property">value</span>=<span class="hljs-literal">false</span></span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> showModal = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">      isModalOpen.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      closeModal,isModalOpen,showModal</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用方式有两个，第一个是在app.vue中使用，但是这样存在的问题是：<strong>「modal是在app的 DOM节点之下的,父节点的dom结构和css都会给modal产生影响」</strong>。</p><p>为了避免这个问题，我们可以在public文件夹下的index.html中增加一个节点<code>&lt;div id=&quot;modal&quot;&gt;&lt;/div&gt;</code>，这样可以看到modal组件就是没有挂载在app下,不再受app组件的影响了</p><h4 id="八-computed和watch"><a href="#八-computed和watch" class="headerlink" title="八.computed和watch"></a>八.computed和watch</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//2.0中</span><br><span class="hljs-attr">computed</span>:&#123;  <span class="hljs-comment">//计算属性</span><br>            <span class="hljs-title function_">_suming</span>(<span class="hljs-params"></span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">one</span>)+<span class="hljs-built_in">parseInt</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">two</span>)<br>            &#125;,<br>            <span class="hljs-title function_">dataTimeing</span>(<span class="hljs-params"></span>)&#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;计算属性方法&quot;</span>);<br>                <span class="hljs-comment">// return &quot;计算属性方法&quot;+new Date()</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;普通方法&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">time</span><br>            &#125;<br>        &#125;,<br><br><span class="hljs-attr">watch</span>: &#123;<br>            <span class="hljs-attr">userName</span>: &#123;<br>                <span class="hljs-title function_">handler</span>(<span class="hljs-params">val,res</span>)&#123;<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val);<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>                &#125;,<br>                <span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<br>                <span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span><br>            &#125;,<br>            <br>        &#125;<br><br><span class="hljs-comment">//3.0中</span><br>&lt;template&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>my firstName is : &#123;&#123; nameObj.firstName &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>my lastName is : &#123;&#123; nameObj.lastName &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>my fullName is : &#123;&#123; fullName &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>my desc : &#123;&#123; nameObj.desc &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeLastName&quot;</span>&gt;</span>click me to add a &#x27;!&#x27; to lastName<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>打开控制台可以查看watch的情况<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeHobby&quot;</span>&gt;</span>修改hobby,测试深度监听<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; computed, reactive, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;ComputedAndWatch&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">const</span> nameObj = <span class="hljs-title function_">reactive</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;Forever&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;Young&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">hobby</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-attr">ball</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-attr">isLike</span>: <span class="hljs-literal">false</span></span></span><br><span class="language-javascript"><span class="language-xml">                &#125;</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 计算属性</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">const</span> fullName = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;nameObj.firstName&#125;</span>_<span class="hljs-subst">$&#123;nameObj.lastName&#125;</span>`</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        nameObj.<span class="hljs-property">desc</span> = <span class="hljs-title function_">computed</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-keyword">return</span> <span class="hljs-string">`my name is <span class="hljs-subst">$&#123;nameObj.firstName&#125;</span>_<span class="hljs-subst">$&#123;nameObj.lastName&#125;</span>`</span></span></span><br><span class="language-javascript"><span class="language-xml">            &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">// 此处的set好像没生效</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;set&#x27;</span>, value)</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">const</span> changeLastName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            nameObj.<span class="hljs-property">lastName</span> = nameObj.<span class="hljs-property">lastName</span> + <span class="hljs-string">&#x27;!&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 监听属性</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 可以深度监听到isLike属性的变化</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">watch</span>(nameObj, <span class="hljs-function">(<span class="hljs-params">newVal</span>) =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;watch nameObj 改变了&#x27;</span>, newVal)</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 只有更改nameObj.lastName会触发这个watch</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">watch</span>(<span class="hljs-function">()=&gt;</span>nameObj.<span class="hljs-property">lastName</span>, <span class="hljs-function">(<span class="hljs-params">newVal</span>) =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;watch nameObj.lastName&#x27;</span>, newVal)</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">const</span> changeHobby = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            nameObj.<span class="hljs-property">hobby</span>.<span class="hljs-property">ball</span>.<span class="hljs-property">isLike</span> = !nameObj.<span class="hljs-property">hobby</span>.<span class="hljs-property">ball</span>.<span class="hljs-property">isLike</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            nameObj,</span></span><br><span class="language-javascript"><span class="language-xml">            fullName,</span></span><br><span class="language-javascript"><span class="language-xml">            changeLastName,</span></span><br><span class="language-javascript"><span class="language-xml">            changeHobby</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>如果需要监听深度属性怎么办呢，我们都知道reactive是响应式数据属性，如果这个属性是对象，那么我们就可以开启深度监听</p><p>注意：我理解这不应该说成是深度监听，只能说是监听某个属性。由上述代码可以看出直接监听nameObj就可以监听到他内部isLike属性的变化，我觉得这已经足够深度监听了</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span>第一种<br>watch(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> names.job.salary,<span class="hljs-function"><span class="hljs-params">(newValue,oldValue)</span>=&gt;</span>&#123;<br>  console.log(<span class="hljs-string">&#x27;names改变了&#x27;</span>,newValue,oldValue)<br>&#125;)<br><span class="hljs-regexp">//</span>第二种<br>watch(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> names.job,<span class="hljs-function"><span class="hljs-params">(newValue,oldValue)</span>=&gt;</span>&#123;<br>  console.log(<span class="hljs-string">&#x27;names改变了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;deep:<span class="hljs-literal">true</span>&#125;)<br></code></pre></td></tr></table></figure><h4 id="九-defineProperty实现响应式"><a href="#九-defineProperty实现响应式" class="headerlink" title="九.defineProperty实现响应式"></a>九.defineProperty实现响应式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 触发更新视图</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateView</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;视图更新啦啦啦&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">// -------------------------处理数组start-------------------</span><br><span class="hljs-comment">// 重新定义数组原型</span><br><span class="hljs-keyword">const</span> oldArrayProperty = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br><span class="hljs-comment">// 创建新的对象,原型指向oldArrayProperty,在扩展新的方法不会影响原型</span><br><span class="hljs-comment">// Array.prototype.push=function()&#123;&#125; 会污染全局</span><br><span class="hljs-keyword">const</span> arrProto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(oldArrayProperty);<br><span class="hljs-comment">//重写数组方法，弥补不能监听数组变化的缺陷</span><br>[<span class="hljs-string">&#x27;push&#x27;</span>, <span class="hljs-string">&#x27;pop&#x27;</span>, <span class="hljs-string">&#x27;shift&#x27;</span>, <span class="hljs-string">&#x27;unshift&#x27;</span>, <span class="hljs-string">&#x27;splice&#x27;</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">methodsName</span> =&gt;</span> &#123;<br>    arrProto[methodsName] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">updateView</span>()<span class="hljs-comment">//更新视图</span><br>        oldArrayProperty[methodsName].<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, ...<span class="hljs-variable language_">arguments</span>)<br>    &#125;<br>&#125;)<br><span class="hljs-comment">// -------------------------处理数组end-------------------</span><br><br><br><span class="hljs-comment">// 重新定义属性，监听起来</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">target, key, value</span>) &#123;<br>    <span class="hljs-comment">// 深度监听-递归处理，在性能上有影响</span><br>    <span class="hljs-title function_">observer</span>(value)<br><br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, key, &#123;<br>        <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> value<br>        &#125;,<br>        <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) &#123;<br>            <span class="hljs-keyword">if</span> (newVal !== value) &#123;<br>                <span class="hljs-comment">// 设置新值，深度监听</span><br>                <span class="hljs-title function_">observer</span>(newVal)<br><br>                value = newVal<br>                <span class="hljs-comment">// 触发视图更新</span><br>                <span class="hljs-title function_">updateView</span>()<br>            &#125;<br>        &#125;<br>    &#125;)<br><br>&#125;<br><br><span class="hljs-comment">// 监听对象属性</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">observer</span>(<span class="hljs-params">target</span>) &#123;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#x27;object&#x27;</span> || target === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 不是对象或者数组</span><br>        <span class="hljs-keyword">return</span> target<br>    &#125;<br>    <span class="hljs-comment">// -------------------------处理数组start-------------------</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(target)) &#123;<br>        target.<span class="hljs-property">__proto__</span> = arrProto<br>    &#125;<br>    <span class="hljs-comment">// -------------------------处理数组end-------------------</span><br><br>    <span class="hljs-comment">// 重新定义属性,for-in可以遍历数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> target) &#123; <br>        <span class="hljs-title function_">defineReactive</span>(target, key, target[key])<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 准备数据</span><br><span class="hljs-keyword">const</span> data = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jerry&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">info</span>: &#123;<br>        <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;beijing&#x27;</span><span class="hljs-comment">//深度监听</span><br>    &#125;,<br>    <span class="hljs-attr">nums</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>&#125;<br><br><span class="hljs-comment">// 监听数据</span><br><span class="hljs-title function_">observer</span>(data)<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-comment">// data.name = &#x27;tom&#x27;</span><br><span class="hljs-comment">// console.log(&#x27;更新后名字&#x27;,data.name)</span><br><span class="hljs-comment">// data.age = 20</span><br><br><span class="hljs-comment">// // 深度监听</span><br><span class="hljs-comment">// data.info.address = &#x27;唐山&#x27;</span><br><br><span class="hljs-comment">// // 设置新值深度监听</span><br><span class="hljs-comment">// data.age = &#123; num: 21 &#125;</span><br><span class="hljs-comment">// data.age.num = 22</span><br><br><span class="hljs-comment">// delete data.name// 删除属性监听不到</span><br><span class="hljs-comment">// data.x = &#x27;新增属性&#x27;//新增属性监听不到</span><br><br><span class="hljs-comment">// 数组监听</span><br>data.<span class="hljs-property">nums</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h4 id="十-proxy实现响应式"><a href="#十-proxy实现响应式" class="headerlink" title="十.proxy实现响应式"></a>十.proxy实现响应式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">target = &#123;&#125;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#x27;object&#x27;</span> || target == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 不是数组或者对象</span><br>        <span class="hljs-keyword">return</span> target<br>    &#125;<br><br>    <span class="hljs-comment">// 代理配置</span><br>    <span class="hljs-keyword">const</span> proxyConf = &#123;<br>        <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>            <span class="hljs-comment">// 只处理非原型的属性</span><br>            <span class="hljs-keyword">const</span> ownKeys = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(target)<br>            <span class="hljs-keyword">if</span> (ownKeys.<span class="hljs-title function_">includes</span>(key)) &#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;get&#x27;</span>, key)<br>            &#125;<br><br>            <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;get&#x27;</span>, key)<br>            <span class="hljs-comment">// return result //返回结果</span><br>            <span class="hljs-comment">//深度监听</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">reactive</span>(result)<br>        &#125;,<br>        <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, val, receiver</span>) &#123;<br>            <span class="hljs-comment">// 不重复修改数据</span><br>            <span class="hljs-keyword">const</span> oldVal = target[key]<br>            <span class="hljs-keyword">if</span> (oldVal === val) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>            <br>            <span class="hljs-comment">// 区别已有的key还是新增的key</span><br>            <span class="hljs-keyword">const</span> ownKeys = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(target)<br>            <span class="hljs-keyword">if</span> (ownKeys.<span class="hljs-title function_">includes</span>(key)) &#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;已有的key&#x27;</span>, key)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;新增的key&#x27;</span>, key)<br>            &#125;<br><br>            <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, val, receiver)<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;set&#x27;</span>, key, val)<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;set-result&#x27;</span>, result)<br>            <span class="hljs-keyword">return</span> result <span class="hljs-comment">//是否设置成功</span><br>        &#125;,<br>        <span class="hljs-title function_">deleteProperty</span>(<span class="hljs-params">target, key</span>) &#123;<br>            <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, key)<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;deleteProperty&#x27;</span>, key)<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;delete result&#x27;</span>, result)<br>            <span class="hljs-keyword">return</span> result <span class="hljs-comment">//是否删除成功</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 生成代理对象</span><br>    <span class="hljs-keyword">const</span> observed = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, proxyConf)<br>    <span class="hljs-keyword">return</span> observed<br>&#125;<br><br><br><span class="hljs-comment">// 测试数据</span><br><span class="hljs-keyword">const</span> data = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jerry&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">info</span>: &#123;<br>        <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;beijing&#x27;</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// const data = [1, 2, 3]</span><br><br><span class="hljs-keyword">const</span> proxyData = <span class="hljs-title function_">reactive</span>(data)<br></code></pre></td></tr></table></figure><h2 id="vue3中ref与reactive"><a href="#vue3中ref与reactive" class="headerlink" title="vue3中ref与reactive"></a>vue3中ref与reactive</h2><p>使用ref例子如下：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>姓名：</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">name</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">age</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>职业：</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">job.occupation</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>薪资：</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">job.salary</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;change&quot;</span>&gt;</span>修改薪资和年龄<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;deepChange&quot;</span>&gt;</span>检测深度监听<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; is &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@babel/types&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref,watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;RefAndReactive&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">let</span> name = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;中介&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">let</span> age = <span class="hljs-title function_">ref</span>(<span class="hljs-number">18</span>)</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">let</span> job = <span class="hljs-title function_">ref</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">occupation</span>: <span class="hljs-string">&#x27;程序员&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">salary</span>: <span class="hljs-string">&#x27;10k&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">up</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-attr">isUp</span>:<span class="hljs-literal">true</span></span></span><br><span class="language-javascript"><span class="language-xml">            &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 直接监听job监听不到isUp的变化</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">watch</span>(<span class="hljs-function">()=&gt;</span>job.<span class="hljs-property">value</span>.<span class="hljs-property">up</span>.<span class="hljs-property">isUp</span>,<span class="hljs-function">(<span class="hljs-params">newVal</span>)=&gt;</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;watch&#x27;</span>,newVal)</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">//方法</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">change</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            job.<span class="hljs-property">value</span>.<span class="hljs-property">salary</span> = <span class="hljs-string">&#x27;12k&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">            age.<span class="hljs-property">value</span> = <span class="hljs-number">19</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">deepChange</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">            job.<span class="hljs-property">value</span>.<span class="hljs-property">up</span>.<span class="hljs-property">isUp</span> = !job.<span class="hljs-property">value</span>.<span class="hljs-property">up</span>.<span class="hljs-property">isUp</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            name,</span></span><br><span class="language-javascript"><span class="language-xml">            age,</span></span><br><span class="language-javascript"><span class="language-xml">            job,</span></span><br><span class="language-javascript"><span class="language-xml">            change,</span></span><br><span class="language-javascript"><span class="language-xml">            deepChange</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>「ref与reactive区别」</strong></p><ol><li>ref定义的是基本数据类型</li><li>ref通过Object.defineProperty()的get和set实现数据劫持（如果参数是对象类型时，其实底层的本质还是reactive,系统会自动根据我们给ref传入的值转换成reactive）</li><li>ref操作数据.value，读取时不需要.value</li><li>reactive定义对象或数组数据类型</li><li>reactive通过Proxy实现数据劫持</li><li>reactive操作和读取数据不需要.value</li><li>监听深度不同</li></ol><h2 id="nextTick-实现原理"><a href="#nextTick-实现原理" class="headerlink" title="$nextTick 实现原理"></a>$nextTick 实现原理</h2><p><code>nextTick</code>存在的原因是<code>Vue</code> 在更新 <code>DOM</code> 时是<strong>「异步执行的」</strong>。只要侦听到数据变化，<code>Vue</code>将<strong>「开启一个队列」</strong>，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，<strong>「只会被推入到队列中一次」</strong>。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在<strong>「下一个的事件循环」</strong>“tick”中，<code>Vue</code> 刷新队列并执行实际 (已去重的) 工作。<code>Vue</code> 在内部对异步队列尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 和 <code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。</p><p><code>nextTick</code>具体实现过程为：</p><ol><li>将回调函数添加到callbacks中等待执行</li><li>将执行函数放入到宏任务(<code>setImediate或者setTimeout</code>)或者微任务(<code>promise,mutationObserver</code>)中</li><li>事件循环到了微任务或者宏任务，执行函数依次执行callbacks中的回调</li></ol><p>可以看出来<code>nextTick</code>是对<code>setTimeout</code>进行了多种兼容性的处理，宽泛的也可以理解为将回调函数放入<code>setTimeout</code>中执行；不过<code>nextTick</code>优先放入微任务执行，而<code>setTimeout</code>是宏任务，因此<code>nextTick</code>一般情况下总是先于<code>setTimeout</code>执行</p><p>源码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> pending = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">let</span> callbacks = []; <span class="hljs-comment">//存放的是回调函数，存放的第一个回调函数是数据更新的回调函数</span><br><span class="hljs-keyword">let</span> timerFunc = <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">//调用this.$nextTick时执行的函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">nextTick</span>(<span class="hljs-params">cb, ctx</span>) &#123;<br>  <span class="hljs-keyword">var</span> _resolve;<br>  <span class="hljs-comment">// 将回调函数已添加到callbacks</span><br>  callbacks.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (cb) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        cb.<span class="hljs-title function_">call</span>(ctx);<br>      &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-title function_">handleError</span>(e, ctx, <span class="hljs-string">&#x27;nextTick&#x27;</span>);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_resolve) &#123;<br>      <span class="hljs-title function_">_resolve</span>(ctx);<br>    &#125;<br>  &#125;);<br>  <span class="hljs-comment">//在数据首次修改时，pending为false，修改后，pending变成true</span><br>  <span class="hljs-keyword">if</span> (!pending) &#123;<br>    pending = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//在这里用到了事件循环</span><br>    <span class="hljs-title function_">timerFunc</span>();<br>  &#125;<br>  <span class="hljs-comment">// $flow-disable-line</span><br>  <span class="hljs-keyword">if</span> (!cb &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Promise</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>      _resolve = resolve;<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//定义eventLoop函数---借助promise,mutationObserver,setImediate或者setTimeout将函数添加到事件循环的宏任务或者微任务中</span><br><span class="hljs-comment">// 判断是否支持promise</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Promise</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-title function_">isNative</span>(<span class="hljs-title class_">Promise</span>)) &#123;<br>  <span class="hljs-keyword">var</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();<br>  timerFunc = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    p.<span class="hljs-title function_">then</span>(flushCallbacks);<br><br>    <span class="hljs-keyword">if</span> (isIOS) &#123; <span class="hljs-built_in">setTimeout</span>(noop); &#125;<br>  &#125;;<br>  isUsingMicroTask = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isIE &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">MutationObserver</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; (<br>  <span class="hljs-comment">// 判断是否支持MutationObserver</span><br>  <span class="hljs-title function_">isNative</span>(<span class="hljs-title class_">MutationObserver</span>) ||<br>  <span class="hljs-comment">// PhantomJS and iOS 7.x</span><br>  <span class="hljs-title class_">MutationObserver</span>.<span class="hljs-title function_">toString</span>() === <span class="hljs-string">&#x27;[object MutationObserverConstructor]&#x27;</span><br>)) &#123;<br>  <span class="hljs-keyword">var</span> counter = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">var</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutationObserver</span>(flushCallbacks);<br>  <span class="hljs-keyword">var</span> textNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(<span class="hljs-title class_">String</span>(counter));<br>  observer.<span class="hljs-title function_">observe</span>(textNode, &#123;<br>    <span class="hljs-attr">characterData</span>: <span class="hljs-literal">true</span><br>  &#125;);<br>  timerFunc = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    counter = (counter + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>;<br>    textNode.<span class="hljs-property">data</span> = <span class="hljs-title class_">String</span>(counter);<br>  &#125;;<br>  isUsingMicroTask = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> setImmediate !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-title function_">isNative</span>(setImmediate)) &#123;<br>  <span class="hljs-comment">// 判断是否支持setImmediate</span><br>  timerFunc = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">setImmediate</span>(flushCallbacks);<br>  &#125;;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 前几项都不支持则使用setTimeout</span><br>  timerFunc = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(flushCallbacks, <span class="hljs-number">0</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">//清空事件队列中的回调函数，第一个回调函数是flushSchedulerQueue ()</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flushCallbacks</span>(<span class="hljs-params"></span>) &#123;<br>  pending = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">var</span> copies = callbacks.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>);<br>  callbacks.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; copies.<span class="hljs-property">length</span>; i++) &#123;<br>    copies[i]();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//flushSchedulerQueue的核心代码，执行数据更新操作</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flushSchedulerQueue</span>(<span class="hljs-params"></span>) &#123;<br>  currentFlushTimestamp = <span class="hljs-title function_">getNow</span>();<br>  flushing = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">var</span> watcher, id;<br>  queue.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123; <span class="hljs-keyword">return</span> a.<span class="hljs-property">id</span> - b.<span class="hljs-property">id</span>; &#125;);<br>  <span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; queue.<span class="hljs-property">length</span>; index++) &#123;<br>    watcher = queue[index];<br>    <span class="hljs-keyword">if</span> (watcher.<span class="hljs-property">before</span>) &#123;<br>      <span class="hljs-comment">//调用beforeUpdate()钩子函数</span><br>      watcher.<span class="hljs-title function_">before</span>();<br>    &#125;<br>    id = watcher.<span class="hljs-property">id</span>;<br>    has[id] = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//执行更新</span><br>    watcher.<span class="hljs-title function_">run</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="v-for中没有key和有key两种情况，diff算法怎么比较"><a href="#v-for中没有key和有key两种情况，diff算法怎么比较" class="headerlink" title="v-for中没有key和有key两种情况，diff算法怎么比较"></a>v-for中没有key和有key两种情况，diff算法怎么比较</h2><h3 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h3><p>diff算法主要进行虚拟DOM的对比，找出差异，减少不必要的dom操作。</p><p>两个 js 对象或者两棵树都可以进行diff，但是两棵树的diff复杂度达到O(n^3)，基本上不可用。</p><p>所以需要优化：</p><ul><li>只对比同一层的节点，不跨级比较</li><li>tag不同则删除重建，不进行深层</li><li>tag和key都相同，认为是同一节点，不深度比较</li></ul><h3 id="用到的重要函数"><a href="#用到的重要函数" class="headerlink" title="用到的重要函数"></a>用到的重要函数</h3><ul><li>h函数，生成VNode</li><li>patch函数，接受两个参数，第一个是<code>VNode</code>或者<code>element</code>，第二个是<code>VNode</code></li><li><code>sameVnode</code>函数，接受两个<code>vnode</code>，判断两者的key和<code>sel</code>(即tag)是否相同，返回boolean值</li></ul><h3 id="patch函数"><a href="#patch函数" class="headerlink" title="patch函数"></a>patch函数</h3><ul><li><p>第一个参数不是<code>vnode</code>， 创建一个空的<code>vnode</code>并关联到这个<code>element</code></p></li><li><p>两个参数都是<code>vnode</code>：</p></li><li><ul><li>两个<code>VNode</code>相同(<code>sameVnode</code>返回true)：<code>patchVnode</code>对比节点文本变化或子节点变化</li><li>两个<code>VNode</code>不同：创建新的<code>VNode</code>，插入到<code>VDom</code></li></ul></li></ul><h3 id="pacthVnode"><a href="#pacthVnode" class="headerlink" title="pacthVnode"></a>pacthVnode</h3><p>主要作用是对比两个<code>VNode</code>。</p><ul><li><p><code>old === new return</code></p></li><li><p><code>new.text === undefined</code> （这<strong>「基本上」</strong>意味着<strong>「新节点的children不为空」</strong>）</p></li><li><ul><li>旧节点有children：<code>updateChildren</code></li><li>旧节点没有children：旧节点的text设置为空，然后<code>addNodes</code>添加children</li><li>旧节点有text：清空text</li></ul></li><li><p><code>new.text !== undefined</code>（新节点的children不存在）</p></li><li><ul><li><code>old.text !== new.text</code> 删除旧节点的children，设置新的节点的<code>text</code></li></ul></li></ul><h3 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h3><p>维持四个指针：</p><ul><li>新children的开始</li><li>新children的结束</li><li>旧children的开始</li><li>旧children的结束</li></ul><p>两两对比(<code>sameVnode</code>)：</p><ul><li><p>新的开始和旧的开始</p></li><li><p>新的开始和旧的结束</p></li><li><p>新的结束和旧的结束</p></li><li><p>新的结束和旧的开始</p></li><li><p>以上四个判断命中的话：<code>pacthVnode</code> 并且移动指针</p></li><li><p>以上四个均未命中：</p></li><li><ul><li>没对应上：创建新的<code>vnode</code>并插入</li><li>对应上了：找到对应旧节点，看<code>sel</code>是否相同</li></ul></li><li><ul><li>不相同就创建新的<code>vnode</code>并且插入</li><li>相同：<code>patchVnode</code></li></ul></li><li><ul><li>对比当前新节点的key是否对应旧节点的某个key</li></ul></li></ul><p>在没有 Key 的情况下。<code>sameVnode</code> 下的 key 都是 undefined ，所以是相同的</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p>先说出diff本来已经存在以及遍历两棵树时，时间复杂度的问题以及优化。</p><p>vue维持四个指针相互进行比较，比较过程通过key和tag判断节点是否相同。</p><p>有key的情况下：key不同则认为两节点不同，没必要比较子节点直接销毁重建；</p><p>没有key时：明明两个节点不同但是由于他们的key都是undefined，此时如果tag相同，那么就会认为是相同节点，会去比较深层的节点</p><h2 id="keep-alive实现原理"><a href="#keep-alive实现原理" class="headerlink" title="keep-alive实现原理"></a>keep-alive实现原理</h2><p>keep-alive组件的props维持includes，excludes和max分别表示要缓存的组件，不缓存的组件和缓存的最大值。</p><p>在created里边初始化cache和keys来存储已经保存的vnode和响应的keys。</p><p>在mounted里边监听includes和excludes 来实时更新cache和keys。</p><p>渲染的时候首先会找到keep-alive第一个子组件对象以及他的name，然后检查：是否满足<code>不在include或者在exclude中</code>（也就是检查是否满足不需要缓存组件），如果满足的话直接返回vnode，不满足的话（需要缓存）根据tag和ID生成缓存key，检查是否已经被缓存过，如果已经缓存过那就取出缓存并且更新key在keys中的位置，以便达到max时做资源置换，如果没缓存过，那就缓存到cache中，然后检测已缓存的实例对象是否达到max，已经达到的话按照LRU置换策略舍弃掉最近最不常用的那个（index&#x3D;&#x3D;&#x3D;0的那个），keep-alive设置为true。</p><h2 id="vue-router和window-location跳转的区别-对浏览器来讲"><a href="#vue-router和window-location跳转的区别-对浏览器来讲" class="headerlink" title="vue-router和window.location跳转的区别(对浏览器来讲)"></a>vue-router和window.location跳转的区别(对浏览器来讲)</h2><ol><li>vue-router使用pushState进行路由更新，<strong>「静态跳转，页面不会重新加载」</strong>；location.href会触发浏览器<strong>「页面重新加载」</strong>一次</li><li>vue-router使用diff算法，实现按需加载，减少dom操作</li><li>vue-router是路由跳转或同一个<strong>「页面跳转」</strong>；location.href是不同页面间跳转；</li><li>vue-router是<strong>「异步加载」</strong>this.$nextTick(()&#x3D;&gt;{获取url})；location.href是同步加载</li></ol><h2 id="Vue如何进行组件封装"><a href="#Vue如何进行组件封装" class="headerlink" title="Vue如何进行组件封装"></a>Vue如何进行组件封装</h2><p>组件封装基本上需要考虑三个方面：</p><ol><li>props：外部传递给组件的数据</li><li>事件：组件触发外部的方法</li><li>slot：外部注入到组件的视图</li></ol><p>具体使用：</p><ol><li><p>定义组件，像普通页面那样；</p></li><li><p>局部使用：在使用的页面中import，之后在components中注册；</p><p>全局使用：在<code>main.js</code>中引入，然后使用<code>Vue.component(组件名，组件)</code></p></li></ol><h2 id="双向数据绑定的机制"><a href="#双向数据绑定的机制" class="headerlink" title="双向数据绑定的机制"></a>双向数据绑定的机制</h2><p>Vuejs的数据驱动是通过MVVM这种框架来实现的。MVVM框架主要包含3个部分:model、view和 viewModel。</p><ul><li>Model:指的是数据部分，对应到前端就是javascript对象</li><li>View:指的是视图部分，对应前端就是dom</li><li>ViewModel:就是连接视图与数据的中间件</li></ul><p>ViewModel是实现数据驱动视图的核心，当数据变化的时候，ViewModel能够监听到这种变化，并及时的通知view做出修改。同样的，当页面有事件触发时，ViewModel也能够监听到事件，并通知model进行响应。ViewModel就相当于一个观察者，监控着双方的动作，并及时通知对方进行相应的操作。</p><p>首先，vuejs在实例化的过程中，会对遍历传给实例化对象选项中的data 选项，遍历其所有属性并使用 Object.defineProperty 把这些属性全部转为 getter&#x2F;setter。</p><p>同时每一个实例对象都有一个watcher实例对象，他会在模板编译的过程中,用getter去访问data的属性，watcher此时就会把用到的data属性记为依赖，这样就建立了视图与数据之间的联系。当之后我们渲染视图的数据依赖发生改变（即数据的setter被调用）的时候，watcher会对比前后两个的数值是否发生变化，然后确定是否通知视图进行重新渲染。这样就实现了所谓的数据对于视图的驱动。</p><h2 id="vue-cli工程技术集合介绍"><a href="#vue-cli工程技术集合介绍" class="headerlink" title="vue-cli工程技术集合介绍"></a>vue-cli工程技术集合介绍</h2><h3 id="构建的vue-cli工程都用到了哪些技术，它们的作用是什么？"><a href="#构建的vue-cli工程都用到了哪些技术，它们的作用是什么？" class="headerlink" title="构建的vue-cli工程都用到了哪些技术，它们的作用是什么？"></a>构建的vue-cli工程都用到了哪些技术，它们的作用是什么？</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">vue<span class="hljs-number">.</span><span class="hljs-keyword">js</span>：vue-<span class="hljs-keyword">cli</span>工程的核心，主要特点是数据双向绑定和组件系统<br>vue-router：vue官方推荐使用的路由框架<br>vuex：专为Vue<span class="hljs-number">.</span><span class="hljs-keyword">js</span>应用项目开发的状态管理器，主要用于维护vue组件间共用的一些变量和方<br>法。<br>asios：用于发起GET或POST等的http请求，基于Promise 设计<br>创建一个eenit<span class="hljs-number">.</span><span class="hljs-keyword">js</span>文件，用于vue事件机制的管理<br>webpack：模块加载和vue-<span class="hljs-keyword">cli</span>工程打包器<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="vue-cli工程中常用的npm命令有哪些？"><a href="#vue-cli工程中常用的npm命令有哪些？" class="headerlink" title="vue-cli工程中常用的npm命令有哪些？"></a>vue-cli工程中常用的npm命令有哪些？</h3><p>下载node_modules资源包的命令：<code>npm install</code></p><p>启动vue-cli开发环境的npm命令：<code>npm run dev</code></p><p>vue-cli生成生产环境部署资源的npm命令：<code>npm run build</code></p><p>用于查看vue-cli生产环境部署资源文件大小的npm命令：<code>npm run build --report</code></p><p>会在浏览器上自动弹出一个展示vue-cli工程打包后app.js、manifest.js、vendor.js文件里面所包含代码的页面。可以具此优化vue-cli生产环境部署的静态资源，提升页面的加载速度。</p><h2 id="vue-cli工程目录结构介绍"><a href="#vue-cli工程目录结构介绍" class="headerlink" title="vue-cli工程目录结构介绍"></a>vue-cli工程目录结构介绍</h2><h3 id="请说出vue-cli工程中每个文件夹和文件的用处"><a href="#请说出vue-cli工程中每个文件夹和文件的用处" class="headerlink" title="请说出vue-cli工程中每个文件夹和文件的用处"></a>请说出vue-cli工程中每个文件夹和文件的用处</h3><p>vue-cli目录解析：</p><ol><li>build 文件夹：用于存放 webpack 相关配置和脚本。开发中仅偶尔使用 到此文件夹下webpack.base.conf.js 用于配置 less、sass等css预编译库，或者配置一下 UI 库。</li><li>config 文件夹：主要存放配置文件，用于区分开发环境、线上环境的不同。 常用到此文件夹下config.js 配置开发环境的端口号、是否开启热加载或者 设置生产环境的静态资源相对路径、是否开启gzip压缩、npm run build 命令打包生成静态资源的名称和路径等。</li><li>dist 文件夹：默认 npm run build 命令打包生成的静态资源文件，用于生产部署。</li><li>node_modules：存放npm命令下载的开发环境和生产环境的依赖包。</li><li>src: 存放项目源码及需要引用的资源文件。</li><li>src下assets：存放项目中需要用到的资源文件，css、js、images等。</li><li>src下componets：存放vue开发中一些公共组件：header.vue、footer.vue等。</li><li>src下emit：自己配置的vue集中式事件管理机制。</li><li>src下router：vue-router vue路由的配置文件。</li><li>src下service：自己配置的vue请求后台接口方法。</li><li>src下page：存在vue页面组件的文件夹。</li><li>src下util：存放vue开发过程中一些公共的.js方法。</li><li>src下vuex：存放 vuex 为vue专门开发的状态管理器。</li><li>src下app.vue：使用标签渲染整个工程的.vue组件。</li><li>src下main.js：vue-cli工程的入口文件。</li><li>index.html：设置项目的一些meta头信息和提供用于挂载 vue 节 点。</li><li>package.json：用于 node_modules资源部 和 启动、打包项目的 npm 命令管理。</li></ol><h3 id="请你详细介绍一些-package-json-里面的配置"><a href="#请你详细介绍一些-package-json-里面的配置" class="headerlink" title="请你详细介绍一些 package.json 里面的配置"></a>请你详细介绍一些 package.json 里面的配置</h3><ul><li>scripts：npm run xxx 命令调用node执行的 .js 文件</li><li>dependencies：生产环境依赖包的名称和版本号，即这些依赖包都会打包进生产环境的JS文件里面</li><li>devDependencies：开发环境依赖包的名称和版本号，即这些依赖包只用于代码开发的时候，不会打包进生产环境js文件里面。</li></ul><h3 id="public和assets文件夹的区别"><a href="#public和assets文件夹的区别" class="headerlink" title="public和assets文件夹的区别"></a>public和assets文件夹的区别</h3><p><strong>「相同点」</strong>：两者中的资源都可以被html使用</p><p><strong>「不同点：」</strong></p><p>若把图片放在assets和public中，html页面都可以使用，但是在动态绑定中，assets路径的图片会加载失败（因为webpack使用的是commenJS规范，必须使用require才可以）。</p><p>public放不会变动的文件，public建议放一些外部第三方资源。</p><p>public目录下的文件并不会被Webpack处理：它们会直接被复制到最终的打包目录（默认是dist&#x2F;static）下。必须使用<strong>「绝对路径」</strong>引用这些文件。</p><p>assets放可能会变动的文件, 自己的文件放在assets。</p><p>assets目录中的文件会被webpack处理解析为模块依赖，只支持<strong>「相对路径」</strong>形式。</p><p>通过 webpack 处理会有如下好处：</p><ul><li>脚本和样式表会被压缩且打包在一起，从而避免额外的网络请求。</li><li>文件丢失会直接在编译时报错，而不是到了用户端才产生 404 错误。</li><li>最终生成的文件名包含了内容哈希，因此你不必担心浏览器会缓存它们的老版本。</li></ul><h2 id="Vue-js核心知识点高频试题一"><a href="#Vue-js核心知识点高频试题一" class="headerlink" title="Vue.js核心知识点高频试题一"></a>Vue.js核心知识点高频试题一</h2><h3 id="Vue-js的两个核心是什么？"><a href="#Vue-js的两个核心是什么？" class="headerlink" title="Vue.js的两个核心是什么？"></a>Vue.js的两个核心是什么？</h3><ol><li><p>数据驱动，也叫双向数据绑定</p><p>Vue.js数据观测原理在技术实现上，利用的是 Object.defineProperty和存储器 getter和setter（所以只兼容IE9及以上版本），可称为基于依赖收集的观测机制。核心是VM，即ViewModel，保证数据和视图的一致性。</p></li><li><p>组件系统 vue组件的核心选项：</p></li><li><ul><li>模板（template）：模板声明了数据和最终展现给用户的DOM之间的映射关系</li><li>初始数据（data）：一个组件的初始数据状态。对于可复用的组件来说，这通常是私有的状态。</li><li>接受的外部参数（props）：组件之间通过参数来进行数据的传递和共享</li><li>方法（methods）：对数据的改动操作一般都在组建的方法内进行</li><li>生命周期钩子函数（lifeCycle hooks）：一个组件会出发多个生命周期钩子函数</li><li>私有资源（assets）：Vue.js当中经用户自定义的指令、过滤器、组件等统称为资源。一个组件可以声明自己的爱有资源。私有资源只有该组件和它的子组件可以调用</li></ul></li></ol><h3 id="对于-Vue-是一套构建用户界面的渐进式框架的理解"><a href="#对于-Vue-是一套构建用户界面的渐进式框架的理解" class="headerlink" title="对于 Vue 是一套构建用户界面的渐进式框架的理解"></a>对于 Vue 是一套构建用户界面的渐进式框架的理解</h3><p>Vue的核心的功能，是一个<strong>「视图模板引擎」</strong>，但这不是说Vue就不能成为一个框架。</p><p>在声明式渲染（视图模板引擎）的基础上，我们可以通过添加组件系统、客户端 路由、大规模状态管理来构建一个完整的框架。更重要的是，这些功能相互独立，你可以在核心功能的基础上任意选用其他的部件，不一定要全部整合在一起。可以看到，所说的“渐进式”，其实就是Vue的使用方式，同时也体现了Vue的设计的理念</p><blockquote><p>❝</p><p>渐进式代表的含义是：没有多做职责之外的事。</p><p>❞</p></blockquote><p>vue.js只提供了 vue-cli 生态中最核心的组件系统和双向数据绑定。</p><p>像vuex、vue-router都属于围绕 vue.js开发的库。</p><blockquote><p>❝</p><p>比如说，你要使用Angular，必须接受以下东西：</p><p>❞</p></blockquote><ul><li>必须使用它的模块机制</li><li>必须使用它的依赖注入-</li><li>必须使用它的特殊形式定义组件（这一点每个视图框架都有，难以避免）</li></ul><p>所以Angular是带有比较强的排它性的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西集成，这些主张会带来一些困扰。</p><blockquote><p>❝</p><p>比如说，你要使用React，你必须理解：</p><p>❞</p></blockquote><ul><li>函数式编程的理念，</li><li>需要知道什么是副作用，</li><li>什么是纯函数，</li><li>如何隔离副作用</li></ul><p>它的侵入性看似没有Angular那么强，主要因为它是软性侵入。</p><blockquote><p>❝</p><p>Vue与React、Angular的不同是，但它是渐进的：</p><p>❞</p></blockquote><ul><li>你可以在原有大系统的上面，把一两个组件改用它实现，当jQuery用；</li><li>也可以整个用它全家桶开发，当Angular用；</li><li>还可以用它的视图，搭配你自己设计的整个下层用。</li><li>你可以在底层数据逻辑的地方用OO和设计模式的那套理念，</li><li>也可以函数式，都可以，它只是个轻量视图而已，只做了最核心的东西。</li></ul><h3 id="请说出vue几种常用的指令"><a href="#请说出vue几种常用的指令" class="headerlink" title="请说出vue几种常用的指令"></a>请说出vue几种常用的指令</h3><ul><li>v-if：根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 &#x2F; 组件被销毁并重建。</li><li>v-show：根据表达式之真假值，切换元素的 display CSS 属性。</li><li>v-for：循环指令，基于一个数组或者对象渲染一个列表，vue 2.0以上必须需配合 key使用。</li><li>v-bind：动态地绑定一个或多个特性，或一个组件 prop 到表达式。</li><li>v-on：用于监听指定元素的DOM事件，比如点击事件。绑定事件监听器。</li><li>v-model：实现表单输入和应用状态之间的双向绑定</li><li>v-pre：在模板中跳过vue的编译，直接输出原始值。就是在标签中加入v-pre就不会输出vue中的data值了。跳过大量没有指令的节点会加快编译。比如<code>&lt;div v-pre&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;</code>这时并不会输出我们的message值，而是直接在网页中显示</li><li>v-once：只渲染元素和组件一次。随后的重新渲染，元素&#x2F;组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</li></ul><h3 id="请问-v-if-和-v-show-有什么区别"><a href="#请问-v-if-和-v-show-有什么区别" class="headerlink" title="请问 v-if 和 v-show 有什么区别"></a>请问 v-if 和 v-show 有什么区别</h3><p>共同点：</p><p>v-if 和 v-show 都是动态显示DOM元素。</p><p>区别：</p><ol><li>编译过程： v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性display。</li><li>编译条件： v-if 是惰性的：如果在初始渲染时条件为假，则什么也不做。直到条件第一次变为真时，才会开始渲染条件块。v-show不管初始条件是什么，元素总是会被渲染，并且只是简单地基于CSS 进行切换。</li><li>性能消耗： v-if有更高的切换消耗。v-show有更高的初始渲染消耗。</li><li>应用场景： v-if适合运行时条件很少改变时使用。v-show适合频繁切换。</li></ol><h3 id="vue常用的修饰符"><a href="#vue常用的修饰符" class="headerlink" title="vue常用的修饰符"></a>vue常用的修饰符</h3><ul><li><p>v-on 指令常用修饰符：</p></li><li><ul><li>.stop - 调用 event.stopPropagation()，禁止事件冒泡。</li><li>.prevent - 调用 event.preventDefault()，阻止事件默认行为。</li><li>.capture - 添加事件侦听器时使用 capture 模式。</li><li>.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li><li>.native - 监听组件根元素的原生事件。</li><li>.once - 只触发一次回调。</li><li>.left - (2.2.0) 只当点击鼠标左键时触发。</li><li>.right - (2.2.0) 只当点击鼠标右键时触发。</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click.stop</span>=<span class="hljs-string">&quot;doThis&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">v-on:submit.prevent</span>=<span class="hljs-string">&quot;onSubmit&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 修饰符可以串联 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click.stop.prevent</span>=<span class="hljs-string">&quot;doThat&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 只有修饰符 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">v-on:submit.prevent</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span><br><span class="hljs-comment">&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-on:click.capture</span>=<span class="hljs-string">&quot;doThis&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span><br><span class="hljs-comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-on:click.self</span>=<span class="hljs-string">&quot;doThat&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click.once</span>=<span class="hljs-string">&quot;doThis&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span><br><span class="hljs-comment">&lt;!-- 而不会等待 `onScroll` 完成 --&gt;</span><br><span class="hljs-comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-on:scroll.passive</span>=<span class="hljs-string">&quot;onScroll&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-on:keyup.enter</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意： 如果是在自己封装的组件或者是使用一些第三方的UI库时，会发现并不起效果，这时就需要用.native修饰符了，如：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim">//使用示例：<br>&lt;<span class="hljs-keyword">el</span>-<span class="hljs-built_in">input</span><br>v-model=<span class="hljs-string">&quot;inputName&quot;</span><br>placeholder=<span class="hljs-string">&quot;搜索你的文件&quot;</span><br>@keyup.enter.native=<span class="hljs-string">&quot;searchFile(params)&quot;</span><br>&gt;<br>&lt;/<span class="hljs-keyword">el</span>-<span class="hljs-built_in">input</span>&gt;<br></code></pre></td></tr></table></figure><ul><li><p>v-bind 指令常用修饰符：</p></li><li><ul><li>.sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。</li></ul></li><li><p>v-model 指令常用修饰符：</p></li><li><ul><li>.lazy - 取代 input 监听 change 事件</li><li>.number - 输入字符串转为数字</li><li>.trim - 输入首尾空格过滤</li></ul></li></ul><h3 id="v-on可以监听多个方法吗？"><a href="#v-on可以监听多个方法吗？" class="headerlink" title="v-on可以监听多个方法吗？"></a>v-on可以监听多个方法吗？</h3><p>v-on可以监听多个方法，例如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;text&quot;</span> :<span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;name&quot;</span> @<span class="hljs-attribute">input</span>=<span class="hljs-string">&quot;onInput&quot;</span> @<span class="hljs-attribute">focus</span>=<span class="hljs-string">&quot;onFocus&quot;</span><br>@<span class="hljs-attribute">blur</span>=<span class="hljs-string">&quot;onBlur&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>但是同一种事件类型的方法，vue-cli工程会报错，例如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;a <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> @<span class="hljs-attribute">click</span>=<span class="hljs-string">&quot;methodsOne&quot;</span> @<span class="hljs-attribute">click</span>=<span class="hljs-string">&quot;methodsTwo&quot;</span>&gt;&lt;/a&gt;<br></code></pre></td></tr></table></figure><h3 id="vue中-key-值的作用"><a href="#vue中-key-值的作用" class="headerlink" title="vue中 key 值的作用"></a>vue中 key 值的作用</h3><p>key值：用于管理可复用的元素。因为vue会尽可能高效的渲染元素，通常会复用已有元素而不是从头开始渲染。这么做会使Vue变得非常快，但是这样也不总是符合实际需求。</p><p>2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。</p><p>例如，如果你允许用户在不同的登录方式之间切换：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Username<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Enter your username&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-else</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Email<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Enter your email address&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那么在上面的代码中切换loginType 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，&lt;&#x2F; input&gt;不会被替换掉，仅仅是替换了它的placeholder。</p><p>这样也不总是符合实际需求，所以Vue为你提供了一种方式来表达这两个元素是完全独立的，不要复用它们。只需添加一个具有唯一值的 key 属性即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Username<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Enter your username&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;username-input&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-else</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Email<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Enter your email address&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;email-input&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在，每次切换时，输入框都将被重新渲染。</p><h3 id="vue事件中如何使用event对象？"><a href="#vue事件中如何使用event对象？" class="headerlink" title="vue事件中如何使用event对象？"></a>vue事件中如何使用event对象？</h3><p>如果直接传递具体的值。可以像如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&lt;button <span class="hljs-meta">@click</span>=<span class="hljs-string">&quot;event(&#x27;123&#x27;)&quot;</span>&gt;修饰符&lt;/button&gt;<br><br><span class="hljs-title function_">event</span>(<span class="hljs-params">message</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">//123</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要访问原始的DOM事件，可以使用特殊变量 $event，使用方法如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&lt;button <span class="hljs-meta">@click</span>=<span class="hljs-string">&quot;event($event)&quot;</span>&gt;修饰符&lt;/button&gt;<br><br><span class="hljs-title function_">event</span>(<span class="hljs-params">e</span>)&#123;<br>    <span class="hljs-title function_">console</span>(e); <span class="hljs-comment">//MouseEvent事件</span><br>&#125;<br>&lt;button data-id=<span class="hljs-string">&#x27;event&#x27;</span> <span class="hljs-meta">@click</span>=<span class="hljs-string">&quot;event($event)&quot;</span>&gt;修饰符&lt;/button&gt;<br><br><span class="hljs-title function_">event</span>(<span class="hljs-params">e</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">srcElement</span>.<span class="hljs-property">dataset</span>.<span class="hljs-property">id</span>); <span class="hljs-comment">//event</span><br>&#125;<br></code></pre></td></tr></table></figure><p>ref的使用：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&lt;<span class="hljs-selector-tag">div</span> ref=<span class="hljs-string">&quot;name&quot;</span>&gt;<br>    &lt;<span class="hljs-selector-tag">button</span> data-id=<span class="hljs-string">&#x27;event&#x27;</span> @click=<span class="hljs-string">&quot;event($event)&quot;</span>&gt;修饰符&lt;/button&gt;<br>&lt;/div&gt;<br> <br><span class="hljs-function"><span class="hljs-title">event</span><span class="hljs-params">()</span></span>&#123;<br>    console<span class="hljs-selector-class">.log</span>(this.<span class="hljs-variable">$refs</span>.name)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="什么是-nextTick？"><a href="#什么是-nextTick？" class="headerlink" title="什么是$nextTick？"></a>什么是$nextTick？</h3><p>简单回答：因为Vue的异步更新队列，$nextTick是用来知道什么时候DOM更新完成的。</p><p>异步更新队列：指的是当状态发生变化时，Vue异步执行DOM更新。</p><p>DOM的异步更新：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>&#123;&#123;test&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span>tet<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-title function_">data</span> () &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">test</span>: <span class="hljs-string">&#x27;begin&#x27;</span><br>        &#125;;<br>    &#125;,<br>    <span class="hljs-title function_">methods</span> () &#123;<br>        <span class="hljs-title function_">handleClick</span> () &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">test</span> = <span class="hljs-string">&#x27;end&#x27;</span>;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">test</span>.<span class="hljs-property">innerText</span>);<span class="hljs-comment">//打印“begin”</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>vue官方文档中是这样说的：</p><blockquote><p>❝</p><p>可能你还没有注意到，Vue异步执行DOM更新。只要观察到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据变化。如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作上非常重要。然后，在下一个事件循环在“tick”中，Vue刷新队列并执行实际（已去重）的工作</p><p>❞</p></blockquote><p>简而言之，就是在一个事件循环中发生的所有数据改变都会在下一个事件循环的Tick中来触发视图更新，这也是一个“批处理”的过程。（注意下一个事件循环的Tick有可能是在当前的Tick微任务执行阶段执行，也可能是在下一个Tick执行，主要取决于nextTick函数到底是使用Promise&#x2F;MutationObserver还是setTimeout）</p><h4 id="为什么要异步更新视图"><a href="#为什么要异步更新视图" class="headerlink" title="为什么要异步更新视图"></a>为什么要异步更新视图</h4><p>看下面的代码：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">test</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">export default &#123;</span><br><span class="language-xml">    data () &#123;</span><br><span class="language-xml">        return &#123;</span><br><span class="language-xml">            test: 0</span><br><span class="language-xml">        &#125;;</span><br><span class="language-xml">    &#125;,</span><br><span class="language-xml">    mounted () &#123;</span><br><span class="language-xml">        for(let i = 0; i &lt; 1000; i++) &#123;</span><br><span class="language-xml">            this.test++;</span><br><span class="language-xml">        &#125;</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><p>现在有这样的一种情况，mounted的时候test的值会被++循环执行 1000 次。 每次++时，都会根据响应式触发setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;run。 如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。</p><p>所以Vue实现了一个queue队列，在下一个Tick（或者是当前Tick的微任务阶段）的时候会统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行 1000 次Watcher的run。最终更新视图只会直接将test对应的DOM的 0 变成 1000 。 保证更新视图操作DOM的动作是在当前栈执行完以后下一个Tick（或者是当前Tick的微任务阶段）的时候调用，大大优化了性能。</p><p>Vue会根据当前浏览器环境优先使用原生的Promise.then和MutationObservery以及setImmediate，如果都不支持，就会采用setTimeout代替。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>在操作DOM节点无效的时候，就要考虑操作的实际DOM节点是否存在，或者相应的DOM是否被更新完毕。</p><ul><li><p>在created钩子中涉及DOM节点的操作肯定是无效的，因为此时还没有完成相关DOM的挂载。</p><p>解决的方法就是在nextTick函数中去处理DOM，这样才能保证DOM被成功挂载而有效操作。</p></li><li><p>在数据变化之后要执行某个操作，而这个操作需要使用随数据改变而改变的DOM时，这个操作应该放进Vue.nextTick。</p></li><li><p>获取this.$refs.refName 返回undefined时，证明组件可能尚未存在，这时候可以在Vue.nextTick获取。</p></li></ul><h3 id="Vue-组件中-data-为什么必须是函数"><a href="#Vue-组件中-data-为什么必须是函数" class="headerlink" title="Vue 组件中 data 为什么必须是函数"></a>Vue 组件中 data 为什么必须是函数</h3><p>因为一个组件是可以共享的，但它们的data是私有的，所以每个组件都return一个新的data对象，返回一个唯一的对象，不要和其他组件共用一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;my-component&#x27;</span>, &#123;<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;OK&lt;/div&gt;&#x27;</span>,<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;&#125; <span class="hljs-comment">// 返回一个唯一的对象，不要和其他组件共用一个对象进行返回</span><br>    &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p>实际上，它的使用过程如下：</p><ul><li>首先需要创建一个组件构造器</li><li>然后注册组件</li><li>注册组件的本质其实就是建立一个组件构造器的引用</li><li>使用组件才是真正的创建一个组件实例</li><li>所以，注册组件其实并不是产生新的组件类，但会产生一个可以用用来实例化的新方式</li></ul><p>理解这个过程之后，在理解js的原型链：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> MyComponent = <span class="hljs-built_in">function</span>() &#123;&#125;<br><br>MyComponent<span class="hljs-selector-class">.prototype</span><span class="hljs-selector-class">.data</span> = &#123;<br>    <span class="hljs-selector-tag">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-selector-tag">b</span>: <span class="hljs-number">2</span>, <br>&#125;<br></code></pre></td></tr></table></figure><p>上面是一个虚拟的组件构造器，真实的组件构造器方法很多:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> component1 = <span class="hljs-keyword">new</span> MyComponent()<br><span class="hljs-keyword">var</span> component2 = <span class="hljs-keyword">new</span> MyComponent()<br></code></pre></td></tr></table></figure><p>上面实例化出来两个组件实例，也就是通过调用，创建的两个实例</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">component1</span>.<span class="hljs-class"><span class="hljs-keyword">data</span>.a === component2.<span class="hljs-keyword">data</span>.a // true</span><br><span class="hljs-title">component1</span>.<span class="hljs-class"><span class="hljs-keyword">data</span>.b = 5</span><br><span class="hljs-title">component2</span>.<span class="hljs-class"><span class="hljs-keyword">data</span>.b // 5</span><br></code></pre></td></tr></table></figure><p>从上面的代码可以看出，如果两个实例同时引用一个对象，那么当你修改其中一个属性的时候，另外一个实例也会跟着改。两个实例应该自己各有自己的实例域才对，做更改：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> MyComponent = function() &#123;<br>    <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span> = <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span>()<br>&#125;<br>MyComponent.prototype.<span class="hljs-keyword">data</span> = function() &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        a: <span class="hljs-number">1</span>,<br>        b: <span class="hljs-number">2</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样每一个实例的data属性都是独立的，不会相互影响了。所以，你现在知道为什么vue组件的data必须是函数了吧。这都是因为js本身的特性带来的，跟vue本身设计无关。</p><h3 id="v-for-与-v-if-的优先级"><a href="#v-for-与-v-if-的优先级" class="headerlink" title="v-for 与 v-if 的优先级"></a>v-for 与 v-if 的优先级</h3><p>当它们处于同一节点，v-for的优先级比v-if更高，这意味着 v-if将分别重复运行于每个 v-for循环中。当你想为仅有的一些项渲染节点时，这种优先级的机制会十分有用，如下：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;todo in todos&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!todo.isComplete&quot;</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">todo</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>上面的代码只传递了未完成的 todos。 而如果你的目的是有条件地跳过循环的执行，那么可以将 v-if置于外层元素 (或 &lt; template&gt;)上。如：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;todos.length&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;todo in todos&quot;</span>&gt;</span></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">todo</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-else</span>&gt;</span>No todos left!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>「注意：当你只想条件性的渲染列表中的某些项的时候建议使用computed进行过滤后使用v-for进行渲染，而不是v-for和v-if同时使用。」</strong></p><h2 id="Vue-js核心知识点高频试题二"><a href="#Vue-js核心知识点高频试题二" class="headerlink" title="Vue.js核心知识点高频试题二"></a>Vue.js核心知识点高频试题二</h2><h3 id="组件传参"><a href="#组件传参" class="headerlink" title="组件传参"></a>组件传参</h3><h4 id="props-emit"><a href="#props-emit" class="headerlink" title="props&#x2F;$emit"></a>props&#x2F;$emit</h4><p>组件是Vue.js中最强大的功能之一，而组件实例的作用域是相互独立的，这就意味着不同组件之间的数据无法相互引用。一般来说，组件可以有以下几种关系：</p><ul><li>父子关系</li><li>兄弟关系</li><li>个贷关系</li></ul><h5 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h5><p>子组件:</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">            //遍历传递过来的值，然后呈现到页面</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;user in users&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">user</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;zizujian&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">props</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">users</span>: &#123; <span class="hljs-comment">//这个就是父组件中子标签自定义名字</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">type</span>: <span class="hljs-title class_">Array</span>,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">require</span>: <span class="hljs-literal">true</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>父组件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">User</span> <span class="hljs-attr">:users</span>=<span class="hljs-string">&quot;users&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">User</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../zizujian&quot;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;fuzujian&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123; <span class="hljs-title class_">User</span> &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">users</span>: [<span class="hljs-string">&quot;ma&quot;</span>, <span class="hljs-string">&quot;nan&quot;</span>, <span class="hljs-string">&quot;nan&quot;</span>]</span><br><span class="language-javascript">        &#125;;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;;</span><br></code></pre></td></tr></table></figure><p>总结：父组件通过 props向下传递数据给子组件。</p><p>注：组件中的数据共有三种形式： data 、 props、 computed</p><h5 id="子组件向父组件传值（通过事件形式）"><a href="#子组件向父组件传值（通过事件形式）" class="headerlink" title="子组件向父组件传值（通过事件形式）"></a>子组件向父组件传值（通过事件形式）</h5><p>子组件</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeTitle&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">title</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;zizujian&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Vue.js Demo&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">changeTitle</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">//自定义事件，传递值“子组件向父组件传值”</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&quot;titleChanged&quot;</span>, <span class="hljs-string">&quot;子组件向父组件传值&quot;</span>); </span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br></code></pre></td></tr></table></figure><p>父组件</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> @<span class="hljs-attr">titleChanged</span>=<span class="hljs-string">&quot;updateTitle&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Header</span>&gt;</span>//与子组件titleChanged自定义事件保持一致</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">title</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Header</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../zizujian&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;fuzujian&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">components</span>: &#123; <span class="hljs-title class_">Header</span> &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;传递的是一个值&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">updateTitle</span>(<span class="hljs-params">e</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = e;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br></code></pre></td></tr></table></figure><p>总结：子组件通过 event给父组件发送消息，实际上就是子组件把自己的数据发送到父组件。</p><h4 id="emit-on"><a href="#emit-on" class="headerlink" title="$emit&#x2F;$on"></a>$emit&#x2F;$on</h4><p>这种方式通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件，巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级。</p><p>当我们的项目比较大时，可以选择更好的转台管理解决方案Vuex</p><p>具体实现：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">var</span> Event=<span class="hljs-literal">new</span> Vue();<br><br><span class="hljs-comment">// 发送数据</span><br>Event.$emit(事件名,数据);<br><br><span class="hljs-comment">// 接收数据</span><br>Event.$on(事件名,<span class="hljs-built_in">data</span> =&gt; &#123;&#125;);<br></code></pre></td></tr></table></figure><h4 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h4><p>vuex适用于一个状态需要在多个组件中同时使用的场景。避免传来传去逻辑复杂难以维护。</p><h4 id="attrs-listeners"><a href="#attrs-listeners" class="headerlink" title="$attrs&#x2F;$listeners"></a>$attrs&#x2F;$listeners</h4><p>多级组件嵌套传递数据，仅仅是传递数据，不做中间处理</p><p><code>$attrs</code>：包含了父作用域中不被 prop所识别（且获取）的特性绑定。当一个组件没有声明任何prop时，这里会包含所有父作用域的绑定，并且可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件。通常配合<code>inheritAttrs</code>选项一起使用。</p><p><code>$listeners</code>：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on&#x3D;”$listeners” 传入内部组件</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">// index.vue</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>浪里行舟<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">child-com</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">:foo</span>=<span class="hljs-string">&quot;foo&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">:boo</span>=<span class="hljs-string">&quot;boo&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">:coo</span>=<span class="hljs-string">&quot;coo&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">:doo</span>=<span class="hljs-string">&quot;doo&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;前端工匠&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-com1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">childCom1</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./childCom1.vue&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">components</span>: &#123; childCom1 &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;Javascript&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">boo</span>: <span class="hljs-string">&quot;Html&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">coo</span>: <span class="hljs-string">&quot;CSS&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">doo</span>: <span class="hljs-string">&quot;Vue&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml">// childCom1.vue</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;border&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>foo: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">foo</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>childCom1的$attrs: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">$attrs</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">child-com2</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$attrs&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-com2</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">childCom2</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./childCom2.vue&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">components</span>: &#123;childCom&#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 可以关闭自动挂载到组件根元素上的没有在props声明的属性</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">props</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">foo</span>: <span class="hljs-title class_">String</span> <span class="hljs-comment">// foo作为props属性绑定</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$attrs</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// &#123; &quot;boo&quot;: &quot;Html&quot;, &quot;coo&quot;: &quot;CSS&quot;, &quot;doo&quot;:&quot;Vue&quot;, &quot;title&quot;: &quot;前端工匠&quot; &#125;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml">// childCom2.vue</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;border&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>boo: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">boo</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>childCom2: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">$attrs</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">child-com3</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$attrs&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-com3</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">childCom3</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./childCom3.vue&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">components</span>: &#123;childCom&#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">false</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">props</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">boo</span>: <span class="hljs-title class_">String</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$attrs</span>); </span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// &#123; &quot;coo&quot;: &quot;CSS&quot;, &quot;doo&quot;: &quot;Vue&quot;, &quot;title&quot;:&quot;前端工匠&quot; &#125;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml">// childCom3.vue</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;border&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>childCom3: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">$attrs</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">props</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">coo</span>: <span class="hljs-title class_">String</span>,</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>Vue2.4提供了<code>$attrs/$listeners</code> 来传递数据与事件，跨级组件之间的通讯变得更简单。</p><p>简单来说：<code>$attrs与$listeners</code> 是两个对象，<code>$attrs</code> 里存放的是父组件中绑定的非 Props 属性，<code>$listeners</code>里存放的是父组件中绑定的非原生事件。</p><h4 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide&#x2F;inject"></a>provide&#x2F;inject</h4><p>Vue2.2.0新增API,这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。一言而蔽之：祖先组件中通过provider来提供变量，然后在子孙组件中通过inject来注入变量。</p><p>provide &#x2F; inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p><p>假设有两个组件： A.vue 和 B.vue，B 是 A 的子组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// A.vue</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">provide</span>: &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;浪里行舟&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// B.vue</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">inject</span>: [<span class="hljs-string">&#x27;name&#x27;</span>],<br>    <span class="hljs-title function_">mounted</span> () &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// 浪里行舟</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的</p><p>所以，上面 A.vue 的 name 如果改变了，B.vue 的 this.name 是不会改变的，仍然是”浪里行舟”。</p><h5 id="provide与-inject如何实现数据响应式"><a href="#provide与-inject如何实现数据响应式" class="headerlink" title="provide与 inject如何实现数据响应式"></a>provide与 inject如何实现数据响应式</h5><p>一般来说，有两种办法：</p><ul><li>provide祖先组件的实例，然后在子孙组件中注入依赖，这样就可以在子孙组件中直接修改祖先组件的实例的属性，不过这种方法有个缺点就是这个实例上挂载很多没有必要的东西比如props，methods</li><li>使用2.6最新API Vue.observable 优化响应式 provide(推荐)</li></ul><p>我们来看个例子：孙组件D、E和F获取A组件传递过来的color值，并能实现数据响应式变化，即A组件的color变化后，组件D、E、F会跟着变（核心代码如下：）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//A 组件</span><br>&lt;div&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>A 组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;() =&gt; changeColor()&quot;</span>&gt;</span>改变color<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ChildrenB</span> /&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ChildrenC</span> /&gt;</span></span><br>&lt;/div&gt;<br>......<br><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;blue&quot;</span><br>    &#125;;<br>&#125;,<br><span class="hljs-comment">// provide() &#123;</span><br><span class="hljs-comment">//  return &#123;</span><br><span class="hljs-comment">//      theme: &#123;</span><br><span class="hljs-comment">//          color: this.color //这种方式绑定的数据并不是可响应的</span><br><span class="hljs-comment">//      &#125; // 即A组件的color变化后，组件D、E、F不会跟着变</span><br><span class="hljs-comment">//  &#125;;</span><br><span class="hljs-comment">// &#125;,</span><br><br><span class="hljs-title function_">provide</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">theme</span>: <span class="hljs-variable language_">this</span><span class="hljs-comment">//方法一：提供祖先组件的实例</span><br>    &#125;;<br>&#125;,<br><span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">changeColor</span>(<span class="hljs-params">color</span>) &#123;<br>        <span class="hljs-keyword">if</span> (color) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> === <span class="hljs-string">&quot;blue&quot;</span>? <span class="hljs-string">&quot;red&quot;</span> : <span class="hljs-string">&quot;blue&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 方法二:使用2.6最新API Vue.observable 优化响应式 provide</span><br> <span class="hljs-title function_">provide</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">theme</span> = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">observable</span>(&#123;<br>        <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;blue&quot;</span><br>     &#125;);<br>     <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">theme</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">theme</span><br>     &#125;;<br> &#125;,<br> <span class="hljs-attr">methods</span>: &#123;<br>     <span class="hljs-title function_">changeColor</span>(<span class="hljs-params">color</span>) &#123;<br>         <span class="hljs-keyword">if</span> (color) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">theme</span>.<span class="hljs-property">color</span> = color;<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">theme</span>.<span class="hljs-property">color</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">theme</span>.<span class="hljs-property">color</span> === <span class="hljs-string">&quot;blue&quot;</span>? <span class="hljs-string">&quot;red&quot;</span> :<span class="hljs-string">&quot;blue&quot;</span>;<br>         &#125;<br>     &#125;<br> &#125;<br> <br><span class="hljs-comment">// F 组件</span><br>&lt;template functional&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;border2&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; color: injections.theme.color &#125;&quot;</span>&gt;</span>F 组件<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">inject</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">theme</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">//函数式组件取值不一样</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> (&#123;&#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125; &#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>虽说provide 和 inject 主要为高阶插件&#x2F;组件库提供用例，但如果你能在业务中熟练运用，可以达到事半功倍的效果！</p><h4 id="parent-children与-ref"><a href="#parent-children与-ref" class="headerlink" title="$parent &#x2F; $children与 ref"></a>$parent &#x2F; $children与 ref</h4><ul><li>ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li><li><code>$parent / $children</code>：访问父 &#x2F; 子实例</li></ul><p>需要注意的是：这两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据。我们先来看个用 ref来访问组件的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// component-a 子组件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-title function_">data</span> () &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Vue.js&#x27;</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-title function_">sayHello</span> () &#123;<br>            <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 父组件</span><br>&lt;template&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">component-a</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;comA&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component-a</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">mounted</span> () &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">const</span> comA = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">comA</span>;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(comA.<span class="hljs-property">title</span>); <span class="hljs-comment">// Vue.js</span></span></span><br><span class="language-javascript"><span class="language-xml">        comA.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 弹窗</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>不过，这两种方法的弊端是，无法在跨级或兄弟间通信。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">// parent.vue<br><span class="hljs-tag">&lt;<span class="hljs-name">component-a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component-a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">component-b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component-b</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">component-b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component-b</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们想在 component-a 中，访问到引用它的页面中（这里就是parent.vue）的两个 component-b组件，那这种情况下，就得配置额外的插件或工具了，比如 Vuex 和 Bus 的解决方案。</p><h4 id="组件传参场景总结"><a href="#组件传参场景总结" class="headerlink" title="组件传参场景总结"></a>组件传参场景总结</h4><p>常见使用场景可以分为三类：</p><ul><li>父子通信： 父向子传递数据是通过 props，子向父是通过 events（<code>$emit</code>）；通过父链 &#x2F; 子链也可以通信（<code>$parent / $children</code>）；ref 也可以访问组件实例；provide &#x2F; inject API；<code>$attrs/$listeners</code></li><li>兄弟通信： Bus；Vuex</li><li>跨级通信： Bus；Vuex；provide &#x2F; inject API、<code>$attrs/$listeners</code></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端面试八股文整理</title>
    <link href="/2023/05/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/"/>
    <url>/2023/05/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML+CSS"></a>HTML+CSS</h1><h2 id="HTML语义化"><a href="#HTML语义化" class="headerlink" title="HTML语义化"></a>HTML语义化</h2><p>HTML语义化就是指在使用HTML标签构建页面时，避免大篇幅的使用无语义的标签，比如div、span，要求尽可能的使用具有语义的标签，比如<code>&lt;h1&gt;~&lt;h5&gt;、&lt;header&gt;、&lt;aside&gt;、&lt;footer&gt;</code>等。</p><p>使用HTML语义化标签的作用:</p><ol><li>易于用户阅读，样式文件未加载时，页面结构清晰。</li><li>有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。</li><li>方便屏幕阅读器解析，如盲人阅读器根据语义渲染网页。</li><li>代码更具可读性，更好维护</li></ol><p>HTML5新增的语义化标签主要有：<code>&lt;article&gt;、&lt;section&gt;、&lt;nav&gt;、&lt;aside&gt;、&lt;header&gt;、&lt;footer&gt;、&lt;time&gt;、mark、figure、caption、context、menu、audio，video，embed</code></p><h2 id="CSS样式优先级"><a href="#CSS样式优先级" class="headerlink" title="CSS样式优先级"></a>CSS样式优先级</h2><p>第一类：!important ∞</p><p>第二类：行内样式 1000</p><p>第三类：id选择器(100)&gt;(类选择器|伪类选择器|属性选择器)(10)&gt; (标签选择器、伪元素选择器(1) &gt;通配符选择器(0)。</p><p>第四类：继承样式，是所有样式中优先级比较低的。</p><p><strong>伪类选择器</strong>：<code>:first-child、:last-child、:nth-child(n)、:first-of-type、:last-of-type、:nth-of-type(n)</code></p><p><code>.demo li:nth-child(n)</code>：在父元素下找到第n个元素</p><p><code>.demo span:nth-of-type(n)</code>：在父元素下找到type为li的第n个元素</p><p><strong>属性选择器</strong>：</p><ul><li>**div[title]{}**：选择含有指定属性title的div元素</li><li>**div[title&#x3D;ab]{}**：选择含有指定属性title并且属性值为ab的div元素</li><li>**div[title^&#x3D;ab]{}**：选择含有指定属性title并且属性值以ab开头的div元素</li><li>**div[title$&#x3D;ab]{}**：选择含有指定属性title并且属性值以ab结尾的div元素</li><li>*<em>div[title</em>&#x3D;ab]{}**：选择含有指定属性title并且属性值包含ab的div元素</li></ul><p><strong>伪元素选择器</strong>：新创建的这个元素在文档树中是找不到的，所以称为伪元素，必须写<strong>content</strong>属性</p><ul><li><strong>::before</strong>：在元素前面插入内容</li><li><strong>::after</strong>：在元素后面插入内容</li></ul><h3 id="可以被继承的css属性"><a href="#可以被继承的css属性" class="headerlink" title="可以被继承的css属性"></a>可以被继承的css属性</h3><ol><li><strong>字体系列属性</strong>：font、font-family、font-weight、font-size、fontstyle;</li><li><strong>文本系列属性</strong>：<ol><li><strong>内联元素</strong>：color、line-height、word-spacing（设置单词之间的间距）、letter-spacing（设置文本字符间距）、 text-transform(用于设置文本的大小写：uppercase所有字符强制转为大写，lowercase转小写，capitalize首字符强制转为大写);</li><li><strong>块级元素</strong>：text-indent、text-align;</li></ol></li><li><strong>元素可见性</strong>：visibility </li><li><strong>表格布局属性</strong>：caption-side（标题位置）、border-collapse（设置边框分离还是合并）、border-spacing（边框分离状态下设置边框间距）、empty-cells（定义如何渲染无可视内容的单元格边框和背景）、table-layout（定义用于布局单元格行和列的算法）;</li><li><strong>列表布局属性</strong>：list-style</li></ol><h3 id="不可以被继承的css属性"><a href="#不可以被继承的css属性" class="headerlink" title="不可以被继承的css属性"></a>不可以被继承的css属性</h3><ol><li><strong>display</strong>：规定元素应该生成的框的类型；</li><li><strong>文本属性</strong>：vertical-align、text-decoration(用于设置文本的修饰线外观包括上&#x2F;下划线，管穿线，删除线，闪烁 ); </li><li><strong>盒子模型的属性</strong>：width、height、margin、border、padding; </li><li><strong>背景属性</strong>：background、background-color、background-image; </li><li><strong>定位属性</strong>：float、clear、position、top、right、bottom、left、min-width、min-height、maxwidth、max-height、overflow、clip;</li></ol><h2 id="CSS尺寸设置的单位"><a href="#CSS尺寸设置的单位" class="headerlink" title="CSS尺寸设置的单位"></a>CSS尺寸设置的单位</h2><p><strong>px</strong>: pixel像素的缩写，绝对长度单位，它的大小取决于屏幕的分辨率，是开发网页中常常使用的单位。</p><p><strong>em</strong>:相对长度单位，在font-size 中使用是相对于父元素的字体大小。</p><p><strong>rem</strong>:相对长度单位，相对于根元素的字体大小，根元素字体大小未设置，使用浏览器默认字体大小。</p><p><strong>vw</strong>:相对长度单位，相对于视窗宽度的1%。</p><p><strong>vh</strong>:相对长度单位，相对于视窗高度的1%。</p><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p><strong>BFC</strong>(Block Formatting Context)块级格式化上下文，是Web页面一块独立的渲染区域，内部元素的渲染不会影响边界以外的元素。</p><p>BFC布局规则:内部盒子会在垂直方向，一个接一个地放置。</p><p>BFC形成的条件：</p><ul><li>float设置成left 或right</li><li>position设置成absolute或fixed</li><li>overflow设置成auto、scroll、hidden</li><li>display设置成flex或inline-block等</li></ul><p>BFC能解决的问题:</p><ul><li>BFC盒子默认会包裹内部子元素——清除浮动</li><li>BFC盒子与子盒子不存在margin塌陷问题—–解决margin塌陷问题</li></ul><h2 id="高度塌陷和外边距塌陷"><a href="#高度塌陷和外边距塌陷" class="headerlink" title="高度塌陷和外边距塌陷"></a>高度塌陷和外边距塌陷</h2><h3 id="高度塌陷"><a href="#高度塌陷" class="headerlink" title="高度塌陷"></a>高度塌陷</h3><p>出现原因：父元素没有设置高度，依靠子元素撑开，子元素设置浮动后会脱离标准流，造成父元素高度为0产生塌陷。</p><p>解决方法：</p><ul><li>给父元素设置高度</li><li>设置父元素display: flex</li><li>设置父元素overflow: hidden</li></ul><h3 id="外边距塌陷"><a href="#外边距塌陷" class="headerlink" title="外边距塌陷"></a>外边距塌陷</h3><p>外边距塌陷：垂直方向上的两个块级元素外边距出现了合并的现象，距离为较大外边距。(水平方向上的元素没有外边距塌陷现象)</p><p>解决方法 ：</p><ul><li>相邻块元素<ul><li>不用margin，用padding</li><li>中间加个空标签隔开，高度为两者margin之和</li><li>只有一个元素设置margin</li><li>改变元素的显示方式，将其中一个块元素设置为行内块元素</li></ul></li><li>嵌套块元素<ul><li>改变元素的显示方式，将其中一个块元素设置为行内块元素</li><li>更改元素的文档流，给其中一个元素设置浮动</li><li>给父元素设置overflow: hidden</li><li>给父元素设置上边框</li></ul></li></ul><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><p><strong>浮动作用</strong>：设置浮动的图片，可以实现文字环绕图片，设置了浮动的块级元素可以排列在同一行，设置了浮动的行内元素可以设置宽高，同时可以按照浮动设置的方向对齐排列盒子。 </p><p><strong>设置浮动</strong>：css属性float：left&#x2F;right&#x2F;none 左浮动&#x2F;右浮动&#x2F;不浮动（默认）</p><p><strong>浮动元素特点</strong>：元素脱标，元素不占位置</p><p>浮动可以进行模式转换(行内块元素) </p><p>浮动造成的影响：</p><p>盒子脱离文档流。如果父级盒子没有设置高度，需要被子盒子撑开，子盒子设置浮动后父级盒子的高度就塌陷了，同时也会造成父级盒子后面的兄弟盒子布局受到影响。如果浮动元素后面还有其他兄弟元素，其他兄弟元素的布局也会受到影响。 </p><p><strong>清除浮动</strong>：</p><ol><li>父级div定义overflow: hidden</li><li>额外标签法：在父元素最后一个浮动子元素后面添加一个空标签div设置样式clear: both</li><li>父元素添加after伪元素</li><li>给父元素添加before和after双伪元素</li></ol><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>相对定位和粘性定位没有脱离文档流</p><p>绝对定位，固定定位都是脱离文档流的</p><h2 id="自适应布局的实现方案"><a href="#自适应布局的实现方案" class="headerlink" title="自适应布局的实现方案"></a>自适应布局的实现方案</h2><h3 id="左列固定右列自适应："><a href="#左列固定右列自适应：" class="headerlink" title="左列固定右列自适应："></a>左列固定右列自适应：</h3><p>(1) 左侧float: left右侧margin-left 左侧设置固定width，</p><p>(2) 左侧float: left右侧float: right左侧设置固定width，右侧width: calc(100%-左侧width)</p><p>(3) 左侧右侧都设置float: left; 左侧设置固定width，右侧width: calc(100%-左侧width)</p><p>(4) 子绝父相，左侧left:0，右侧right:0; 左侧设置固定width，右侧width: calc(100%-左侧width)</p><p>(5) 父元素盒子设置display: flex；左侧设置固定width，右侧设置flex: 1</p><h3 id="左右宽度固定，中间宽度自适应"><a href="#左右宽度固定，中间宽度自适应" class="headerlink" title="左右宽度固定，中间宽度自适应"></a>左右宽度固定，中间宽度自适应</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>center<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>// 左中右都设置float: left; 左右两侧设置固定width，中间width: calc(100%-左侧width-右侧width)<br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.center</span>,<span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.left</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.center</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">100%</span>-<span class="hljs-number">200px</span>-<span class="hljs-number">200px</span>);</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>// 父盒子设置display: flex；左右侧设置固定width，中间设置flex: 1<br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.container</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.left</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.center</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>// 左右中三列设置position: absolute; 左列设置left:0; 右列设置right:0; 左右设置固定宽度，中间设置left：左列width；right：右列width；<br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.container</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.left</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;        </span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.center</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">right</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>center<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>// 左侧设置float: left; 右侧设置float: right; 左右宽度固定，中间设置左右外边距，距离为左右宽度<br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.left</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">float</span>: right;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.center</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>// 左右中三列设置position: absolute; 左列设置left:0; 右列设置right:0; 左右设置固定宽度，中间设置left：左列width；right：右列width；<br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.container</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.left</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;        </span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.center</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">right</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-class">.center</span>,<span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.center</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-comment">/* 通过margin+相对定位设置位置 */</span></span><br><span class="language-css">      <span class="hljs-selector-class">.left</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="language-css">        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">        <span class="hljs-attribute">left</span>: -<span class="hljs-number">300px</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: grey;</span><br><span class="language-css">        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">300px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-comment">/* 两边留白 */</span></span><br><span class="language-css">      <span class="hljs-selector-class">.container</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">padding-left</span>:<span class="hljs-number">300px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">padding-right</span>:<span class="hljs-number">300px</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>中间<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左边<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右边<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="盒子水平垂直居中"><a href="#盒子水平垂直居中" class="headerlink" title="盒子水平垂直居中"></a>盒子水平垂直居中</h2><p>方法一：利用定位</p><p>父盒子使用相对定位relative,子盒子使用绝对定位absolute, 子盒子设置top:50%; left:50%，</p><p>(1)当子盒子width, height已知时，设置margin-top: -height&#x2F;2; margin-left: -width&#x2F;2;</p><p>(2)当子盒子width, height未知时，设置transform: translate(-50%, -50%)</p><p>方法二：flex布局</p><p>父盒子设置display: flex; justify-content: center(设置主轴(默认<em>x</em>轴)元素居中); align-items: center(设置侧轴(<em>y</em>轴)元素居中)。</p><p>方法三：margin: auto</p><p>父盒子使用相对定位relative,子盒子使用绝对定位absolute, 子盒子设置margin: auto; top: 0; left: 0; right: 0; bottom: 0。</p><p>方法四：display: table-cell</p><p>父盒子设置display: table-cell; vertical-align: middle; text-align: center;</p><h2 id="移动端布局"><a href="#移动端布局" class="headerlink" title="移动端布局"></a>移动端布局</h2><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><p>是指利用媒体查询(media query)，@media查询针对不同的媒体类型定义不同的样式，从而实现响应式布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css">// <span class="hljs-keyword">@media</span> 后面跟媒体类型 <br>// <span class="hljs-keyword">and</span> () 条件查询的拼接<br>@media screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">500px</span>)&#123;<br>    <span class="hljs-selector-class">.container</span>&#123;<br>        <span class="hljs-attribute">display</span>: flex;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">500px</span>) <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">1000px</span>)&#123;<br>    <span class="hljs-selector-class">.container</span>&#123;<br>        <span class="hljs-attribute">display</span>: inline-block;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="流式布局（百分比布局）"><a href="#流式布局（百分比布局）" class="headerlink" title="流式布局（百分比布局）"></a>流式布局（百分比布局）</h3><p>流式布局是宽度使用百分比(宽度自适应)代替固定宽度px，高度大多使用px来固定，因此在大屏幕手机下显示的效果会变成页面元素的宽度被拉长，高度和原来保持一致。</p><p>优点：可以解决自适应的问题</p><p>缺点：</p><ul><li>实际显示的效果不友好,屏幕越大，宽度被拉的很长，容易变形</li><li>大量使用百分比布局，会出现兼容性问题</li></ul><h3 id="rem布局"><a href="#rem布局" class="headerlink" title="rem布局"></a>rem布局</h3><p>rem是指相对于根元素的字体大小的单位，即根据html元素的font-size来计算大小。</p><p>rem原理：在布局过程中使用rem设置元素的尺寸，改变html的字体大小，页面上的元素将等比例缩放实现适配。</p><p>比如说html的font-size大小为100px, div的width为1rem，则div的width大小为100px</p><p>rem实现布局：</p><p>1.先设置视口meta viewport理想视口</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=2.0, maximum-scale=2.00, minimum-scale=2.00, user-scalable=no&quot;</span></span><br></code></pre></td></tr></table></figure><p> 2.写媒体查询(根据不同设备宽度修改样式)或原生JS适配文件</p><p>750px—100px；320px—?px</p><p>当前屏幕的html字体大小&#x3D;当前屏幕宽度×预设字体大小&#x2F;psd设计稿宽度;</p><p>3.在设计稿测量px转换为rem (px&#x2F;100)写rem单位</p><p>优点：</p><ul><li>有利于手机端各种机型的适配</li><li>减少代码的重复性</li></ul><p>缺点：必须通过js来动态控制根元素的大小(VSCode装一个插件: px to rem)</p><h3 id="vw-vh布局"><a href="#vw-vh布局" class="headerlink" title="vw&#x2F;vh布局"></a>vw&#x2F;vh布局</h3><p>使用纯css实现动态改变font-size属性值，不需要引用js文件</p><p>vw：viewport’s width 是css3规范中视口宽度单位，将视口宽度平均分成100份</p><p>vh：viewport’s height 将视口高度平均分成100份</p><p>原理：确定基准值以常见的750像素宽度的设计稿为例，根据vw单位的原理100vw &#x3D; 750px,即1vw &#x3D; 7.5px，根据设计稿中的px值，转换成对应的vw值进行布局，也可以直接写px</p><p>100vw &#x3D; 750px 1vw &#x3D; 7.5px;</p><p>100vw &#x3D; 375px 1vw &#x3D; 3.75px</p><p>1px &#x3D;0.1333333333333333vw</p><p>优点：页面元素随着页面宽度变化</p><p>缺点：</p><ul><li>兼容性没有rem好 ,得大量计算，不是很精确</li><li>转换后的长度单位不够直观修改维护困难(VS Code装一个插件: px to vw)</li></ul><p>(5) vw + rem布局</p><p>确定基准值以常见的750px设计稿为例（宽度），根据vw单位和rem单位原理实现</p><p>在750px设计搞下，如果使用vw单位换算，可以理解成100vw &#x3D; 750px，1px &#x3D; 0.13333333vw；如果使用rem单位换算，预设1rem &#x3D; 100px; 则100px &#x3D; 13.333333vw html{ font-size: 13.333333vw; }</p><p>弊端：不是很精确</p><p>750px  100vw  1vw &#x3D; 7.5px;</p><p>375px  100vw  1vw &#x3D; 3.75px</p><p>以设计稿为准:</p><p>假设还是750px设计稿 750px&#x3D;100vw 1px&#x3D;0.1333vw;  </p><p>预设字体基础值 100px 1rem &#x3D; 100px&#x3D; 13.33vw;</p><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p>定义：Flex是Flexible Box的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性。</p><p>原理：通过给父元素添加display: flex;属性来控制子元素的位置和排列方式。</p><p>父元素属性：</p><p>(1)flex-direction：设置主轴的方向。它可能有4个值：</p><p>row: （默认值）主轴为水平方向，起点在左端，从左至右排列；</p><p>row-reverse：主轴为水平方向，起点在右端，从右至左排列；</p><p>column：主轴为垂直方向，起点在上沿，从上至下排列；</p><p>column-reverse：主轴为垂直方向，起点在下沿，从下至上排列。</p><p>(2) flex-wrap： 控制项目(子元素)是否换行。它可能取三个值：</p><p>nowrap：（默认值）不换行；</p><p>wrap：换行，第一行在上方；</p><p>wrap-reverse：换行，第一行在下方。</p><p>默认不换行，如果父元素装不下会缩小所有子元素的宽度，使子元素挤在一起。</p><p>(3) flex-flow：是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</p><p>(4) justify-content：设置主轴上的子元素对齐方式。它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右：</p><p>flex-start：（默认值）从头部开始排列；如果主轴是<em>x</em>轴则从左到右;</p><p>flex-end：从尾部开始排列;</p><p>center：在主轴居中对齐；如果主轴是<em>x</em>轴则水平居中;</p><p>space-around：平分剩余空间，盒子左右间距相等;</p><p>space-between: 先两侧贴边，平分剩余空间。</p><p>(5) align-items：设置侧轴上的子元素排列方式(单行)。它可能取5个值，具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下：</p><p>flex-start：从上到下；</p><p>flex-end：从下到上；</p><p>center：垂直居中；</p><p>stretch：(默认值)，如果项目未设置高度或设为auto，将占满整个容器的高度。</p><p>(6) align-content：设置侧轴上的子元素排列方式(多行)。该属性可能取6个值：</p><p>flex-start：从侧轴头部开始排列；</p><p>flex-end：从侧轴尾部开始排列；</p><p>center：侧轴中间显示；</p><p>space-around：子元素在侧轴平分剩余空间</p><p>space-between：子元素在侧轴先分布两头，平分剩余空间；</p><p>stretch：(默认值)，子元素高度平分父元素高度。</p><p>子元素属性：</p><p>(1) order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><p>(2) flex属性：子元素占的份数</p><p>(3) align-self 控制子元素自己在侧轴排列方式，可覆盖align-items属性。</p><p>默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><p>align-self: auto | flex-start | flex-end | center | stretch;</p><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p><h2 id="CSS实现三角形"><a href="#CSS实现三角形" class="headerlink" title="CSS实现三角形"></a>CSS实现三角形</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css">// 等腰三角形<br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">20px</span> solid transparent;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">20px</span> solid red;<br>  <span class="hljs-attribute">border-left</span>: <span class="hljs-number">20px</span> solid transparent;<br>  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">20px</span> solid transparent;<br>&#125;<br>// 直角三角形<br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">0px</span> solid transparent;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">20px</span> solid red;<br>  <span class="hljs-attribute">border-left</span>: <span class="hljs-number">10px</span> solid transparent;<br>  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">0px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="块元素和行内元素"><a href="#块元素和行内元素" class="headerlink" title="块元素和行内元素"></a>块元素和行内元素</h2><h3 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">div、p、h1-h6、form、ul、ol、dl、dt、dd、li、table、tr、td、th、hr、blockquote、address、table、menu、pre<br><br><span class="hljs-title class_">HTML5</span>：header、section、article、footer等等<br><br>块元素特性<br><span class="hljs-number">1.</span>块级元素独占一行，当没有设置宽高时，它默认设置为<span class="hljs-number">100</span>%<br><span class="hljs-number">2.</span>块级元素允许设置宽高，width、height、margin、padding、border都可控制<br><span class="hljs-number">3.</span>块级元素可以包行内元素、块级元素<br><span class="hljs-number">4.</span>块级元素可以设置margin和padding属性<br></code></pre></td></tr></table></figure><h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">span、img、a、label、code、input、abbr、em、b、big、cite、i、q、textarea、select、small、sub、sup，strong、u，button<br><br>行内元素特性<br><span class="hljs-number">1.</span>行内元素不能独占一行，与其他行内元素排成一行<br><span class="hljs-number">2.</span>行内元素不能设置width、height、margin、padding<br><span class="hljs-number">3.</span>行内元素默认宽度为其content宽度<br><span class="hljs-number">4.</span>行内元素只能包括文字或行内元素、行内块元素，不能包括块级元素<br><span class="hljs-number">5.</span>行内元素padding-left、padding-right，margin-left，margin-right（水平方向），有边距效果，padding-top，padding-bottom，margin-top，margin-bototm，（垂直方向）没有边距效果<br></code></pre></td></tr></table></figure><h1 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h1><h2 id="var-let-const区别"><a href="#var-let-const区别" class="headerlink" title="var let const区别"></a>var let const区别</h2><p>var：存在变量提升；变量覆盖，已经被定义且赋值的变量，如果再次被赋值，则以后一次值为准；没有块级作用域；</p><p>const：定义的是常量，声明之后必须赋值；定义的值不能去修改，否则报错；有块级作用域；不存在变量提升和变量覆盖；对于数组和对象的元素修改，不算对常量的修改，不会报错。(const定义的数据是一个简单数据类型的时候，是不能修改的，但如果是一个复杂数据类型是可以修改的，因为对于数据的存放是有栈、堆之说的，当存简单数据类型的时候，是放在栈中而对于复杂数据类型，是将它的地址放在栈中，真正的数据放在堆中，当我数据变化的时候并不会去修改地址，所以用const可以修改对象中的值)</p><p>let：有块级作用域；不存在变量提升和变量覆盖；let不允许在相同的作用域中重复声明，注意是相同作用域，不同作用域重复声明不会报错。与var 关键字不同，var 声明的变量会挂载到window对象上，成为其属性，而使用let 在全局作用域中声明的变量不会成为 window 对象的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;w&#x27;</span><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;o&#x27;</span>,<br>    <span class="hljs-attr">print</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> p = obj.<span class="hljs-property">print</span><br>obj.<span class="hljs-title function_">print</span>() <span class="hljs-comment">// &#x27;o&#x27;</span><br><span class="hljs-title function_">P</span>()         <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>obj.print()就是obj调用的print()，this指向obj，所以在函数内部寻找变量，发现是o。p()相当于window.p()，this指向window，但let定义的变量a，他不会挂载到window上，所以结果是undefined</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;<br><span class="hljs-comment">// 10 10 10 10 10 10 10 10 10 10</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;<br><span class="hljs-comment">// 0 1 2 3 4 5 6 7 8 9 10</span><br></code></pre></td></tr></table></figure><p>因为setTimeout是微任务，要等同步任务执行完才执行微任务，使用var定义时变量i是全局变量，值会被覆盖掉，循环后i的值是10，所以最后会打印10个10。</p><p>let定义的变量有自己的块级作用域，在每次执行循环体之前，JS引擎会把i在循环体的上下文中重新声明及初始化一次。</p><h2 id="JS变量提升"><a href="#JS变量提升" class="headerlink" title="JS变量提升"></a>JS变量提升</h2><p>变量提升是指JS的变量和函数声明会在代码编译期，提升到代码的最前面。</p><p>变量提升成立的前提是使用var关键字进行声明的变量，并且变量提升的时候只有声明被提升，赋值（函数表达式）并不会被提升，同时函数的声明提升会比变量的提升优先（var 定义的变量有变量提升，function 定义的函数也有函数提升）变量提升的结果，可以在变量初始化之前访问该变量，返回的是undefined。在函数声明前可以调用该函数。</p><p>当变量名和函数名相同时，如果变量声明并且赋了值。变量会覆盖函数。反之，声明了没赋值，函数覆盖变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-title function_">foo</span>();<br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-comment">// 执行时变成这样</span><br><span class="hljs-keyword">var</span> foo;<br><span class="hljs-keyword">var</span> x = <span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// TypeError: foo is not a function</span><br>foo = <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> val = <span class="hljs-number">12</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val);<br>    <span class="hljs-keyword">var</span> val = <span class="hljs-number">20</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val);<br>&#125;<br><span class="hljs-title function_">fun1</span>()<br><span class="hljs-comment">// 执行时</span><br><span class="hljs-keyword">var</span> val = <span class="hljs-number">12</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> val;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val); <span class="hljs-comment">// undefined</span><br>    val = <span class="hljs-number">20</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val); <span class="hljs-comment">// 20</span><br>&#125;<br><span class="hljs-title function_">fun1</span>()<br></code></pre></td></tr></table></figure><p>当局部变量和全局变量同时存在时，局部变量的优先级更高（就近原则）。在函数fun1内部，由于存在变量提升，会先使用var声明局部变量val，而变量的赋值并不会跟着一起提升，接着使用console.log()输出val，由于val变量已声明但未赋值，故输出结果为undefined，然后再对val进行赋值，其值为20，最后再次输出val，输出结果为20. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> b = <span class="hljs-number">3</span>;<br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    b = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br>&#125;)();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b)<br><span class="hljs-comment">// 执行时</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-number">3</span>;<br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> b<br>    b = <span class="hljs-number">5</span>;<br>    b = <span class="hljs-number">2</span>;<br>&#125;)();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b)<br></code></pre></td></tr></table></figure><p>立即执行函数内部，var发生变量提升，结果相当于 (function(){ var b; b&#x3D;5; b&#x3D;2; })() 所以这个立即执行函数并没有改变全局环境中的b，所以全局环境中的b依旧是3。</p><h2 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h2><p>Number、String、Boolean、Biglnt (ES10新增)、Symbol (ES6新增)、Null、Undefined、Obiect、8种</p><p>JS数据类型分为两类:</p><p>一类是<strong>基本数据类型</strong>，也叫简单数据类型，包含7种类型，分别是Number、String、Boolean、Biglnt (ES10新增)、Symbol (ES6新增)、 Null、Undefined。Symbol是ES6新增的基本数据类型，表示独一无二的值。Symbol()函数会返回symbol类型的值，每个从Symbol()返回的值都是唯一的。</p><p>另一类是<strong>引用数据类型</strong>也叫复杂数据类型，通常用Obiect代表，普通对象，Array数组，RegExp正则，Date日期，Math数学函数都属于Obiect。</p><h3 id="本质区别"><a href="#本质区别" class="headerlink" title="本质区别"></a>本质区别</h3><p>基本数据类型和引用数据类型它们在<strong>内存中的存储方式</strong>不同。</p><p>基本数据类型是直接存储在<strong>栈</strong>中的简单数据段，占据空间小，属于被频繁使用的数据。</p><p>引用数据类型是存储在<strong>堆</strong>内存中，占据空间大。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址，当解释器寻找引用值时，会检索其在栈中的地址取得地址后从堆中获得实体。</p><h3 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h3><p>JavaScript有4种方法判断变量的类型，分别是typeof、instanceof、constructor、 Object.prototype.toString.call()(对象原型链判断方法)。</p><p><strong>typeof</strong>：判断基本数据类型 null返回object，function返回function，其余返回object</p><p><strong>使用方法</strong>：typeof 数据 返回数据类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> <span class="hljs-number">18</span>,<span class="hljs-comment">//&quot;nu ber&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-comment">//&quot;string&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">false</span>, <span class="hljs-comment">//boolean&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>, <span class="hljs-comment">//&quot;undefined&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>, <span class="hljs-comment">//&quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]，<span class="hljs-comment">//&quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-attr">fa</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">b</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">c</span>:<span class="hljs-number">3</span>], <span class="hljs-comment">//&quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)(<span class="hljs-params"><span class="hljs-variable language_">console</span>.log(<span class="hljs-string">&quot;aaa&quot;</span>);], <span class="hljs-comment">//&quot;function&quot;</span></span><br><span class="hljs-params"><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(), <span class="hljs-comment">//&quot;object&quot;</span></span><br><span class="hljs-params"><span class="hljs-keyword">typeof</span> /~[a-zh-z](<span class="hljs-number">5</span>,<span class="hljs-number">20</span>]$/， <span class="hljs-comment">//&quot;object&quot;</span></span><br><span class="hljs-params"><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>() <span class="hljs-comment">//&quot;object&quot;</span></span><br><span class="hljs-params"><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> Nurber(<span class="hljs-number">100</span>), <span class="hljs-comment">// &quot;object&quot;</span></span><br><span class="hljs-params"><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;abc&quot;</span>),<span class="hljs-comment">// &quot;string</span></span><br><span class="hljs-params"><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">true</span>),<span class="hljs-comment">// &quot;boolean</span></span><br></code></pre></td></tr></table></figure><p><strong>instanceof</strong>：判断复杂数据类型(引用数据类型)，判断基本数据类型返回false </p><p><strong>使用方法</strong>：数据 instanceof 数据类型 返回true或false</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">1ee <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span>, <span class="hljs-comment">//false</span><br><span class="hljs-string">&quot;dsfsf’ instanceof String, //false</span><br><span class="hljs-string">false instanceof Boolean, //false</span><br><span class="hljs-string">undefined instanceof Object, //false</span><br><span class="hljs-string">null instanceof object, //false</span><br><span class="hljs-string">[1,2,3] instanceof Array, //true</span><br><span class="hljs-string">(a:1,b:2c:3] instanceof object, //true</span><br><span class="hljs-string">function()(console.log(&quot;</span>aaa<span class="hljs-string">&quot;);&#125; instanceof Function, //true</span><br><span class="hljs-string">new Date() instanceof Date, //true</span><br><span class="hljs-string">/~[a-zA-Z](5,20)$/ instanceof RegExp， //true</span><br><span class="hljs-string">new Error() instanceof Error //true</span><br></code></pre></td></tr></table></figure><p><strong>constructor</strong>:可以检测基本数据类型，也能分辨出数组和对象，但是我们可以随意更改constructor的值，导致检测结果不准确。除了undefined和null都可以用。</p><p><strong>使用方法</strong>：数据.constructor &#x3D;&#x3D;&#x3D; 数据类型  返回true或false</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-literal">false</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Boolean</span>;            <span class="hljs-comment">// true</span><br>“<span class="hljs-number">123</span>”.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">String</span>;             <span class="hljs-comment">// true</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Nurber</span>(<span class="hljs-number">123</span>) .<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Nurber</span>;  <span class="hljs-comment">// true</span><br>[].<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span>;                 <span class="hljs-comment">// true</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>() .<span class="hljs-property">construetor</span> === <span class="hljs-title class_">Functions</span>;<span class="hljs-comment">// true</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() .<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Date</span>;         <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">HIMLDocument</span>;    <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Window</span>;            <span class="hljs-comment">// true</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>() .<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Error</span>;       <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>Object.prototype.toString.call()</strong>&#x2F;<strong>Object.prototype.toString.apply()</strong>: 适用于所有类型的判断检测。</p><p>检测方法是Object.prototype.toString.call(数据)，返回的是该数据类型的字符串<code>&quot;[object 数据类型]&quot;</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>);       <span class="hljs-comment">// ”[object Null]”</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>);  <span class="hljs-comment">// ”[object Undefined]”</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(“abc”);      <span class="hljs-comment">// ”[object String]”</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-number">123</span>);        <span class="hljs-comment">// ”[object Number]”</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">true</span>);       <span class="hljs-comment">// ”[object Boolean]”</span><br></code></pre></td></tr></table></figure><h2 id="数组去重方法"><a href="#数组去重方法" class="headerlink" title="数组去重方法"></a>数组去重方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1.Set去重</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">23</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">33</span>,<span class="hljs-number">22</span>,<span class="hljs-number">12</span>,<span class="hljs-number">21</span>]<br><span class="hljs-keyword">let</span> item = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)]<br><span class="hljs-comment">// 2.filter去重</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">arr</span>)&#123;<br><span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item, index, arr</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">indexOf</span>(item, <span class="hljs-number">0</span>)===index;<br><span class="hljs-comment">// arr.indexOf(item, 0)是item在arr中第一次出现的索引值</span><br><span class="hljs-comment">// index是item当前索引值</span><br>&#125;);<br>&#125;<br><span class="hljs-comment">// 3.forEach去重</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">let</span> newArr=[];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-params">(item, index, arr)=&gt;&#123;</span><br><span class="hljs-params"><span class="hljs-keyword">if</span>(newArr.indexOf(item))===-<span class="hljs-number">1</span>)&#123;</span><br><span class="hljs-params">newArr.push(item);</span><br><span class="hljs-params">&#125;</span><br><span class="hljs-params">&#125;</span>);<br><span class="hljs-keyword">return</span> newArr;<br>&#125;<br><span class="hljs-comment">// 4.sort去重</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">arr</span>) &#123;<br>  arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span> a - b);<br>  <span class="hljs-keyword">let</span> newArr = [arr[<span class="hljs-number">0</span>]]<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] !== arr[i - <span class="hljs-number">1</span>]) &#123;<br>      newArr.<span class="hljs-title function_">push</span>(arr[i])<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> newArr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//选择排序</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">123</span>,<span class="hljs-number">203</span>,<span class="hljs-number">23</span>,<span class="hljs-number">13</span>,<span class="hljs-number">34</span>,<span class="hljs-number">65</span>,<span class="hljs-number">65</span>,<span class="hljs-number">45</span>,<span class="hljs-number">89</span>,<span class="hljs-number">13</span>,<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>; i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=i+<span class="hljs-number">1</span>; j&lt;arr.<span class="hljs-property">length</span>; j++)&#123;<br>       <span class="hljs-comment">//如果第一个比第二个大，就交换他们两个位置</span><br>       <span class="hljs-keyword">if</span>(arr[i]&gt;arr[j])&#123;<br>           <span class="hljs-keyword">var</span> temp = arr[i];<br>           arr[i] = arr[j];<br>           arr[j] = temp;<br>       &#125;<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">//(11) [1, 13, 13, 23, 34, 45, 65, 65, 89, 123, 203]</span><br><span class="hljs-comment">//冒泡排序</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">123</span>,<span class="hljs-number">203</span>,<span class="hljs-number">23</span>,<span class="hljs-number">13</span>,<span class="hljs-number">34</span>,<span class="hljs-number">65</span>,<span class="hljs-number">65</span>,<span class="hljs-number">45</span>,<span class="hljs-number">89</span>,<span class="hljs-number">13</span>,<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>; i++)&#123;<br>    <span class="hljs-comment">//每一轮比较要比多少次</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>; j&lt;arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>-i; j++)&#123;<br>      <span class="hljs-comment">//如果第一个比第二个大，就交换他们两个位置</span><br>      <span class="hljs-keyword">if</span>(arr[j]&gt;arr[j+<span class="hljs-number">1</span>])&#123;<br>        <span class="hljs-keyword">var</span> temp = arr[j];<br>        arr[j] = arr[j+<span class="hljs-number">1</span>];<br>        arr[j+<span class="hljs-number">1</span>] = temp;<br>      &#125;<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">//(11) [1, 13, 13, 23, 34, 45, 65, 65, 89, 123, 203]</span><br></code></pre></td></tr></table></figure><h2 id="数组遍历方法"><a href="#数组遍历方法" class="headerlink" title="数组遍历方法"></a>数组遍历方法</h2><p><strong>forEach</strong>方法：遍历数组，默认有3个参数：item：遍历的每一个元素，index：遍历的索引，arr：遍历的数组</p><p><strong>map</strong>方法：遍历数组，和forEach一致，不同的是会返回一个新的数组，如果没有return会返回undefined</p><p><strong>filter</strong>方法：遍历数组，返回一个新数组，新数组由参数里条件为true的元素组成</p><p><strong>some</strong>方法：遍历数组，只要有一个元素符合条件就返回true，都不符合条件返回false</p><p><strong>every</strong>方法：遍历数组，所有元素就返都符合条件才返回true，不然返回false    </p><p><strong>reduce</strong>方法：遍历数组，一般作为累加器.</p><ul><li>prevValue表示上一次调用回调时的返回值(accumulator：累加器)</li><li>currentValue表示当前的元素。</li><li>currentIndex表示当前的元素索引。</li><li>init 代表初始值，不写默认是0。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br><span class="hljs-keyword">let</span> init=<span class="hljs-number">0</span><br><span class="hljs-keyword">let</span> res=arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">preValue,currentValue</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> preValue+cuurentValue<br>&#125;,init)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) <span class="hljs-comment">// 36</span><br><span class="hljs-comment">/////////////////////////////////</span><br><span class="hljs-keyword">let</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br><span class="hljs-keyword">let</span> init=<span class="hljs-number">3</span><br><span class="hljs-keyword">let</span> res=arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">preValue,currentValue</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> preValue+cuurentValue<br>&#125;,init)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) <span class="hljs-comment">// 39</span><br></code></pre></td></tr></table></figure><p>**for…of…**方法：遍历数组&#x2F;字符串，for…in…返回的是数组的下标，for…of…返回的是数组元素的索引</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> item <span class="hljs-keyword">of</span> arr)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item) <span class="hljs-comment">// 1, 2, 3, 4, 5</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组方法汇总"><a href="#数组方法汇总" class="headerlink" title="数组方法汇总"></a>数组方法汇总</h2><h3 id="不改变原数组的方法："><a href="#不改变原数组的方法：" class="headerlink" title="不改变原数组的方法："></a>不改变原数组的方法：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item, index, arr</span>)=&gt;</span>&#123;&#125;) <span class="hljs-comment">// 循环遍历数组、返回一个新的数组</span><br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index, arr</span>)=&gt;</span>&#123;&#125;) <span class="hljs-comment">// 循环遍历数组，不改变原数组</span><br>arr.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">item, index, arr</span>)=&gt;</span>&#123;&#125;) <span class="hljs-comment">// 有一项返回为true，则整体为true</span><br>arr.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">item, index, arr</span>)=&gt;</span>&#123;&#125;) <span class="hljs-comment">// 有一项返回为true，则整体为false</span><br>arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item, index, arr</span>)=&gt;</span>&#123;&#125;) <span class="hljs-comment">// 数组过滤</span><br>arr.<span class="hljs-title function_">reduce</span>(prevValue/accumulator, currentValue, currentIndex, arr)=&gt;&#123;&#125;,init) <span class="hljs-comment">// 数组求和</span><br>arr.<span class="hljs-title function_">slice</span>(start, end) <span class="hljs-comment">// 数组截取，包括start，不包括end，返回一个新的数组（start为起始索引end为结束索引值）</span><br>arr.<span class="hljs-title function_">concat</span>(arr) <span class="hljs-comment">// 数组的拼接，不影响原数组，浅拷贝</span><br>arr.<span class="hljs-property">indexOf</span>/<span class="hljs-title function_">lastIndexOf</span>(item) <span class="hljs-comment">// 查找数组项，返回对应的下标</span><br>arr.<span class="hljs-title function_">join</span>(‘-’) <span class="hljs-comment">// 把数组转化为字符串(split(‘-’) 将字符串分割为数组)</span><br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>].<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// &#x27;12345&#x27;</span><br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>].<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-comment">// &#x27;1-2-3-4-5&#x27;</span><br>arr.<span class="hljs-title function_">findIndex</span>(item) <span class="hljs-comment">// 查找并返回第一个符合要求的值的索引</span><br>arr.<span class="hljs-property">find</span> (item) <span class="hljs-comment">// 查找并返回第一个符合要求的值</span><br></code></pre></td></tr></table></figure><h3 id="改变原数组的方法："><a href="#改变原数组的方法：" class="headerlink" title="改变原数组的方法："></a>改变原数组的方法：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-property">push</span>/pop <span class="hljs-comment">// 在数组的末尾添加/删除元素改变原数组</span><br>arr.<span class="hljs-property">unshift</span>/shift <span class="hljs-comment">// 在数组的头部添加/删除元素，改变原数组</span><br><span class="hljs-comment">// 注意：pop和shift返回被删除的元素，push和unshift返回数组的新长度</span><br>arr.<span class="hljs-property">splice</span> <span class="hljs-comment">// 删除数组元素，改变原数组，返回被删除的元素</span><br>arr.<span class="hljs-title function_">splice</span>(start, number) <span class="hljs-comment">// start为起始索引 number为删除个数</span><br>arr.<span class="hljs-title function_">splice</span>(start, number, value) <span class="hljs-comment">// value为新增元素</span><br><span class="hljs-keyword">let</span> arr=[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>]<br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>) <span class="hljs-comment">// arr: [&#x27;a&#x27;,&#x27;e&#x27;,&#x27;f&#x27;]</span><br><span class="hljs-keyword">let</span> arr=[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>]<br><span class="hljs-keyword">let</span> result=arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;value&#x27;</span>) <br><span class="hljs-comment">// arr: [&#x27;a&#x27;,&#x27;value&#x27;,&#x27;e&#x27;,&#x27;f&#x27;]</span><br><span class="hljs-comment">// result: [&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]</span><br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>a-b) <span class="hljs-comment">// 数组排序改变原数组（a-b为升序，b-a为降序）</span><br>arr.<span class="hljs-title function_">reverse</span>() <span class="hljs-comment">// 数组反转，改变原数组</span><br></code></pre></td></tr></table></figure><h3 id="find和filter区别"><a href="#find和filter区别" class="headerlink" title="find和filter区别"></a>find和filter区别</h3><p><strong>find</strong>是寻找，是在数组中找到第一个符合条件的元素并返回这个数</p><p><strong>filter</strong>是过滤，是在遍历数组后拿到所有符合条件的元素，返回的是一个数组 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>item===<span class="hljs-number">2</span>)) <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>item===<span class="hljs-number">2</span>)) <span class="hljs-comment">// [2,2]</span><br></code></pre></td></tr></table></figure><h2 id="伪数组和数组"><a href="#伪数组和数组" class="headerlink" title="伪数组和数组?"></a>伪数组和数组?</h2><h3 id="伪数组和数组区别："><a href="#伪数组和数组区别：" class="headerlink" title="伪数组和数组区别："></a>伪数组和数组区别：</h3><ol><li>伪数组的类型不是Array，而是Object，数组的类型是Array。</li><li>可以使用length属性查看长度</li><li>可以使用[index]获取某个元素</li><li>但是不能使用数组的其他方法,也不能改变长度</li><li>遍历使用for in方法。</li></ol><h3 id="伪数组的常见场景"><a href="#伪数组的常见场景" class="headerlink" title="伪数组的常见场景:"></a>伪数组的常见场景:</h3><ol><li>function内arguments对象。</li><li>还有像调用getElementsByTagName, getElementsByClassName,document.childNodes, querySelectorAll，之类返回的NodeList对象都属于伪数组，也称为类数组.（注意：getElementById和querySelector获取到的是单个元素）。</li><li>jQuery中的$()方法获取到的全部是伪数组,本质都是html标签序列。</li><li>自定义的伪数组,例如 let obj&#x3D;{0:‘a’,1:‘b’,length:2}。</li></ol><h3 id="伪数组转换为数组"><a href="#伪数组转换为数组" class="headerlink" title="伪数组转换为数组"></a>伪数组转换为数组</h3><ol><li><code>Array.from(伪数组)</code></li><li><code>Array.of(伪数组)</code></li><li><code>new Array(伪数组)</code></li><li><code>Array.prototype.slice.call(伪数组)/Array.prototype.slice.apply(伪数组)</code></li><li><code>[].slice.call(伪数组)/[].slice.apply(伪数组)</code></li><li><code>var args = [...arguments]</code></li></ol><h3 id="判断变量是否为数组？"><a href="#判断变量是否为数组？" class="headerlink" title="判断变量是否为数组？"></a>判断变量是否为数组？</h3><ol><li><code>Array.isArray(arr) // true</code></li><li><code>arr.__proto__ === Array.prototype // true</code></li><li><code>arr instanceof Array // true</code></li><li><code>arr.constructor === Array // true</code></li><li><code>Object,prototype.toString.call(arr) // &quot;[object Array]&quot;</code></li></ol><h2 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">str.<span class="hljs-title function_">charAt</span>(index) <span class="hljs-comment">// 从一个字符串中返回指定的字符</span><br>str.<span class="hljs-title function_">concat</span>(str1, str2) <span class="hljs-comment">// 将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回</span><br>str.<span class="hljs-title function_">includes</span>(字符串中某一个字符) <span class="hljs-comment">// 用于判断一个字符串是否包含在另一个字符串中，根据情况返回true 或false。</span><br>str.<span class="hljs-title function_">indexOf</span>(字符串中某一个字符，fromIndex) <span class="hljs-comment">// 返回调用它的 string 对象中第一次出现的指定值的索引，从fromIndex处进行搜索。如果未找到该值，则返回-1。</span><br>str.<span class="hljs-title function_">match</span>(正则表达式) <span class="hljs-comment">// 检索返回一个或多个字符串匹配正则表达式的结果</span><br>str.<span class="hljs-title function_">repeat</span>(复制次数) <span class="hljs-comment">// 字符串复制指定次数</span><br>str.<span class="hljs-title function_">replace</span>(oldStr，newStr) <span class="hljs-comment">// 将oldStr替换为newStr（只能替换首个返回条件的字符） </span><br>str.<span class="hljs-title function_">replaceAll</span>(oldStr，newStr) <span class="hljs-comment">// 将所有的oldStr替换为newStr</span><br>str.<span class="hljs-title function_">search</span>(要查找的字符串) <span class="hljs-comment">// 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。返回与指定查找的字符串或者正则表达式相匹配的String对象起始位置</span><br>str.<span class="hljs-title function_">slice</span>(start, end) <span class="hljs-comment">// 提取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串。（包含start，不包含end）start和end都可以是负数，如果是负数，就从字符串的尾部开始算起，例如-1就是最后一个字符，-2就是倒数第二个字符</span><br>str.<span class="hljs-title function_">split</span>(‘-’) <span class="hljs-comment">// 使用指定的分隔符字符串将一个string对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。</span><br><span class="hljs-keyword">let</span> str=<span class="hljs-string">&#x27;a-b-c-d-e&#x27;</span><br>str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// [&#x27;a&#x27;,&#x27;-&#x27;,&#x27;b&#x27;,&#x27;-&#x27;,&#x27;c&#x27;,&#x27;-&#x27;,&#x27;d&#x27;,&#x27;-&#x27;,&#x27;e&#x27;]</span><br>str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-comment">// [&#x27;a&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;]</span><br>str.<span class="hljs-title function_">substring</span>(start, end) <span class="hljs-comment">// 截取str从start到end的所有字符(包含起始位置,但不包含结束位置)。两个参数都必须是非负整数，如果参数start与end相等，那么该方法返回的就是一个空字符串，如果start比end大，那么该方法在提取字符串之前会先交换这两个参数。如果未指定end参数，则截取从start到原字符串结尾的字符串</span><br><span class="hljs-keyword">let</span> str=<span class="hljs-string">&#x27;abcde leodonna&#x27;</span><br>str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>,<span class="hljs-number">8</span>) <span class="hljs-comment">// bcde le</span><br>str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">4</span>) <span class="hljs-comment">// e leodonna</span><br>str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">4</span>,<span class="hljs-number">1</span>) <span class="hljs-comment">// bcd</span><br>str.<span class="hljs-title function_">toLowerCase</span>() <span class="hljs-comment">// 用于把字符串转换为小写。</span><br>str.<span class="hljs-title function_">toUpperCase</span>() <span class="hljs-comment">// 用于把字符串转换为大写。</span><br>str.<span class="hljs-title function_">trim</span>() <span class="hljs-comment">// 用于删除字符串的头尾空白符，空白符包括：空格、制表符 tab、换行符等其他空白符等。</span><br></code></pre></td></tr></table></figure><h2 id="防抖和节流-袋鼠云笔试"><a href="#防抖和节流-袋鼠云笔试" class="headerlink" title="防抖和节流(袋鼠云笔试)"></a>防抖和节流(袋鼠云笔试)</h2><p>防抖：触发事件后，在n秒内，事件只执行一次，如果在n秒内又触发了事件，则会重新计算函数的执行时间。(注意，下面代码let timer&#x3D;null只执行一次)</p><p>比如点击按钮，2秒后调用函数，结果在1.5秒的时候又点了，则会重新计算2秒后在调用函数。</p><p>应用场景：</p><p>1.调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖；</p><p>2.文本编辑器实时保存，当无任何更改操作一秒后进行保存。</p><p>3.搜索框输入时，n秒后再请求后台数据，如果不到n秒又输入就重新等待n秒</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn,delay</span>)&#123;<br>    <span class="hljs-keyword">let</span> timer=<span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">let</span> arg=<span class="hljs-variable language_">arguments</span><br>        <span class="hljs-keyword">if</span>(timer) <span class="hljs-title function_">clearTimerout</span>(timer)<br>        timer=<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,arg)<br>        &#125;,delay)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>节流：连续发生的事件在n秒内，只执行为一次</p><p>应用场景：</p><p>1.鼠标连续不断地触发某事件（如点击），单位时间内只触发一次；</p><p>2.监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断。例如：懒加载；</p><p>3.浏览器播放事件，每个一秒计算一次进度信息等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn,delay</span>)&#123;<br>    <span class="hljs-keyword">let</span> timer=<span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">let</span> arg=<span class="hljs-variable language_">arguments</span><br>        <span class="hljs-keyword">if</span>(!timer) &#123;<br>            timer=<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,arg)<br>                timer=<span class="hljs-literal">null</span><br>            &#125;,delay)     <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="js闭包"><a href="#js闭包" class="headerlink" title="js闭包"></a>js闭包</h2><p>闭包就是一个函数对周围状态的引用捆绑在一起，内层函数可以访问到外层函数的作用域。</p><p>简单来说，闭包就是内层函数+引用的外层函数变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;<br>    <span class="hljs-title function_">f</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>闭包不一定有return，当外部如果想要使用闭包的变量的时候，此时需要return。</p><p>闭包存在意义：</p><p>可以延长变量的生命周期，可以创建私有的环境</p><p>闭包好处：</p><p>可以读取其他函数的内部变量，将变量始终保存在内存中</p><p>主要实现数据的私有（因为外部函数可以使用但是不能修改内部函数的变量）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>        count++<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`函数被调用了<span class="hljs-subst">$&#123;count&#125;</span>次`</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> fun<br>&#125;<br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">fn</span>()<br><span class="hljs-title function_">result</span>() <span class="hljs-comment">// 2</span><br><span class="hljs-title function_">result</span>() <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>坏处：消耗内存、使用不当会造成内存溢出问题</p><p>result是一个全局变量，代码执行完毕不会立即销毁，result使用fn函数，fn用到fun函数，fun函数里面用到count，count被引用就不会被回收，所以一直存在，此时：闭包引起了内存泄露。</p><h2 id="JS垃圾回收机制-袋鼠云笔试"><a href="#JS垃圾回收机制-袋鼠云笔试" class="headerlink" title="JS垃圾回收机制(袋鼠云笔试)"></a>JS垃圾回收机制(袋鼠云笔试)</h2><p>GC–garbage collection，JS具有“自动”垃圾回收机制，即执行环境会负责管理代码执行过程中使用的内存</p><p>GC会定期（周期性的）找出那些不再继续使用的变量，然后释放其内存</p><p>不再使用的变量即生命周期结束的变量会被释放，只能是局部变量，全局变量的生命周期，直到浏览器关闭页面才会结束</p><p>闭包由于内部函数原因，外部函数不能算结束，无法释放内存</p><p>js的垃圾回收机制—-采用的方式</p><p>(1)<strong>标记清除法</strong></p><p><strong>标记</strong>：遍历所有的对象找到活动对象，进行标记的操作，表示该对象可达。</p><p><strong>清除</strong>：遍历所有的对象，找到那些没有标记的对象进行清除。(注意在第二阶段中也会把第一阶段涉及的标志给抹掉，便于GC下次能够正常的工作) </p><p>(2)<strong>引用计数法</strong></p><p>跟踪记录每个值被引用的次数，当某个值的引用次数变为0时，说明没有方法在访问该值了，则可将其占用的内存收回</p><h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><ol><li>以函数的形式（包括普通函数、定时器函数、立即执行函数）调用时，this的指向永远都是window。比如fun();相当于window.fun();匿名函数具有全局性，匿名函数的this指向window对象</li><li>以方法的形式调用时，this指向调用方法的那个对象</li><li>以构造函数的形式调用时，this指向实例对象</li><li>以事件绑定函数的形式调用时，this指向绑定事件的对象</li><li>使用call、apply和bind调用时，this指向指定的那个对象</li><li>箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象)，此处指父级作用域</li><li>严格模式下变量必须用关键字声明后才能使用<ul><li>严格模式下，普通函数的this指向undefined</li><li>严格模式下，立即执行函数的this指向undefined</li><li>严格模式下，setTimeout中函数的this指向的window（与普通函数不同）</li><li>严格模式下，构造函数的this指向undefined，但是构造函数实例化对象的this指向的是实例化对象本身</li></ul></li></ol><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">() =&gt; &#123; ... &#125;<br>() =&gt; <span class="hljs-keyword">return</span> ...<br>val =&gt; <span class="hljs-keyword">return</span> val++<br></code></pre></td></tr></table></figure><p>函数体中只有一句代码，且代码的执行结果就是返回值 可以省略大括号。如果形参只有一个时，可以省略小括号。</p><p>箭头函数的this指向父级作用域的this</p><p> 箭头函数与普通函数的区别</p><ul><li>箭头函数的定义要比普通函数定义简洁、清晰得多，更快捷。</li><li>箭头函数的this指向外层第一个普通函数，如果外层没有普通函数，则指向 window</li><li>箭头函数不可以作为构造函数(即不能使用new)</li><li>箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是外层函数执行环境中的值。箭头函数this指向全局时，不能调用 arguments</li><li>箭头函数没有原型prototype</li></ul><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><ul><li>JS是单线程，为防止阻塞，将代码分为同步和异步任务。</li><li>同步任务交给JS引擎执行，异步任务交给宿主环境执行。</li><li>同步代码会被放入执行栈中，异步任务会将回调函数放入任务队列中。</li><li>当执行栈中代码执行完毕，会去任务队列中看是否有异步任务，如果有送入执行栈执行，反复循环查看，这就是事件循环（Eventloop）。</li></ul><h2 id="宏任务微任务"><a href="#宏任务微任务" class="headerlink" title="宏任务微任务"></a>宏任务微任务</h2><p>代码可能有3种：</p><ol><li><p>同步任务（JS执行栈&#x2F;回调栈）</p></li><li><p>微任务的异步代码（JS引擎）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">process.<span class="hljs-title function_">nextTick</span>(node)<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">then</span>() <span class="hljs-keyword">catch</span>()<br><span class="hljs-title class_">Async</span>/<span class="hljs-title class_">Await</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">observe</span>()<br></code></pre></td></tr></table></figure></li><li><p>宏任务的异步代码（宿主环境）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">script</span>(代码块)<br><span class="hljs-built_in">setTimeout</span>/<span class="hljs-built_in">setInterval</span>定时器<br>I/O<br><span class="hljs-variable constant_">UI</span> render<br></code></pre></td></tr></table></figure></li></ol><p>异步任务会先执行任务队列中的微任务（promise方法），执行完毕会再去任务队列查看是否有微任务，如果有，继续执行，如果没有就去执行宏任务(setTimeout等)</p><p>注意：</p><ul><li>Promise本身是同步的，then&#x2F;catch的回调函数是异步的微任务</li><li>setTimeout，如果时间为0，则会立即插入队列，不是立即执行，等待前面的代码执行完毕。仍然是异步任务要交给宿主环境执行。</li></ul><h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><p>原型对象：每个函数都有prototype属性，称之为原型，因为这个属性的值是个对象，也称为原型对象。</p><p>作用：</p><ol><li>存放了一些属性和方法</li><li>在JavaScript中实现继承</li></ol><p>对象原型：每个对象都有<code>__proto__</code>属性，指向它的原型对象prototype</p><p>每个构造函数都有个prototype属性，即对象原型，构造函数的每个实例对象都有<code>__proto__</code>属性，指向构造函数的原型对象。</p><p>对象都有<code>__proto__</code>属性，这个属性指向它的原型对象prototype，原型对象也是对象，也有<code>__proto__</code>属性，指向原型对象的原型对象，这样一层一层形成的链式结构称为原型链，直到最顶层找不到返回null。</p><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p><strong>定义</strong>：事件委托也叫事件代理，是指将事件处理程序绑定到父元素上，然后通过判断事件的目标，来执行对应的时间处理程序</p><p><strong>原理</strong>：事件冒泡机制。</p><p><strong>优点</strong>：</p><ul><li>可以大量节省内存占用，减少事件注册，提高代码的性能和可维护性。比如ul上代理所有li的click事件就很不错。</li><li>当新增子对象时，无需再对其进行事件绑定和解绑事件，对于动态内容部分尤为合适。</li></ul><p><strong>缺点</strong>：</p><ol><li>事件委托基于冒泡，对于不冒泡的事件不支持。（不支持冒泡的事件：UI事件(load, unload, scroll, resize)，焦点事件(blur, focus), 鼠标事件(mouseleave, mouseenter)）</li><li>层级过多，冒泡过程中，可能会被某层阻止掉（event.stopPropagation()）。</li><li>理论上委托会导致浏览器频繁调用处理函数，虽然很可能不需要处理。所以建议就近委托，比如在table上代理td，而不是在document上代理td。</li><li>把所有事件都用代理就可能会出现事件误判。比如，在document中代理了所有button的click事件，另外的人在引用改js时，可能不知道，造成单击button触发了两个click事件。</li></ol><p>事件冒泡和事件捕获</p><p>事件冒泡和事件捕获都是为了解决页面中事件流（事件发生顺序）的问题。</p><ol><li><strong>事件冒泡</strong>：事件会从最内层的元素开始发生，一直向上传播，直到document对象。</li><li><strong>事件捕获</strong>：与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素</li></ol><p>处理顺序：</p><p>DOM事件流：将事件分为三个阶段：捕获阶段、目标阶段和冒泡阶段</p><p>先事件捕获（从 Windows -&gt; document 依次往下）；再是目标事件处理；最后是事件冒泡。</p><p>如何阻止事件冒泡？</p><p>1.<strong>event.stopPropagation()</strong></p><p>这是阻止事件的冒泡方法，不止事件向document上蔓延，但是默认事件任然会执行，当你调用这个方法的时候，如果点击一个连接，这个连接仍然会被打开</p><p>2.<strong>event.preventDefault()</strong></p><p>这是阻止默认事件的方法，调用此方法时，链接不会被打开，但是会发生冒泡，冒泡会传递到上一层的父元素</p><p>3.<strong>return false</strong>;</p><p>这个方法比较暴力，他会同时阻止事件冒泡也会阻止默认事件，不仅阻止了事件往上冒泡，而且阻止了事件本身</p><h2 id="事件扩展符用过吗-…"><a href="#事件扩展符用过吗-…" class="headerlink" title="事件扩展符用过吗(…)"></a>事件扩展符用过吗(…)</h2><p>展开语法(Spread syntax)，可以在函数调用&#x2F;数组构造时，将数组表达式或者string在语法层面展开，还可以在构造字面量对象时，将对象表达式按key-value的方式展开。</p><p>常见的场景：</p><ul><li>将数组展开为构造函数的参数</li><li>字面量数组或字符串连接不需要使用concat等方法</li><li>构造字面量对象时，进行浅拷贝或者属性拷贝</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span>数组拷贝 <span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]；<span class="hljs-keyword">let</span> b = [...a] <span class="hljs-comment">// b = [1,2,3]</span><br><span class="hljs-number">2.</span>数组合并 <span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]；<span class="hljs-keyword">let</span> b = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]；<span class="hljs-keyword">let</span> c = [...a, ...b] <span class="hljs-comment">// c = [1,2,3,4,5,6]</span><br><span class="hljs-number">3.</span>伪数组转成真正的数组 <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])；<span class="hljs-keyword">let</span> b = [...a] <span class="hljs-comment">// b = [1,2,3]</span><br></code></pre></td></tr></table></figure><h3 id="剩余参数和arguments对象"><a href="#剩余参数和arguments对象" class="headerlink" title="剩余参数和arguments对象"></a>剩余参数和arguments对象</h3><p>剩余参数语法允许将一个不定数量的参数表示为一个数组</p><p>表示：一个普通标识符前加3个点，例如：…args</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sum</span>=(<span class="hljs-params">f, ...args</span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args)<br>&#125;<br><span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>arguments是伪数组，跟数组很像，拥有length属性和索引元素，但是它不是一个真正的数组，不能使用数组的方法，也不能改变长度，遍历使用for in方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// arguments转化成数组的方法</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(伪数组)<br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(伪数组)<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(伪数组)<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(伪数组)/<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">apply</span>(伪数组)<br>[].<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(伪数组)/[].<span class="hljs-property">slice</span>.<span class="hljs-title function_">apply</span>(伪数组)<br></code></pre></td></tr></table></figure><p>剩余参数和arguments对象的区别：</p><ol><li>剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。</li><li>剩余参数是真正的Array实例，而arguments对象不是一个真正的数组，arguments也就不能使用数组的方法。</li></ol><h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h2><p><strong>浅拷贝</strong>：创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p><p><strong>深拷贝</strong>：会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。</p><h3 id="浅拷贝实现方法："><a href="#浅拷贝实现方法：" class="headerlink" title="浅拷贝实现方法："></a>浅拷贝实现方法：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-number">1</span>) <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>()<br><span class="hljs-comment">// 定义：用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</span><br><span class="hljs-comment">// 用法：Object.assign(target, ...sourceObj)</span><br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: &#123; <span class="hljs-attr">a</span>:<span class="hljs-string">&#x27;kobe&#x27;</span>, <span class="hljs-attr">b</span>:<span class="hljs-number">39</span> &#125;&#125;<br><span class="hljs-keyword">var</span> initalObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;,obj)<br>initalObj.<span class="hljs-property">a</span>.<span class="hljs-property">a</span> = <span class="hljs-string">&#x27;wade&#x27;</span><br>consoloe.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">a</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// &#x27;wade&#x27;</span><br><br>(<span class="hljs-number">2</span>)<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">concat</span>()<br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,&#123;<span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;kobe&#x27;</span>&#125;]<br><span class="hljs-keyword">let</span> arr2 = arr.<span class="hljs-title function_">concat</span>()<br>arr2[<span class="hljs-number">2</span>].<span class="hljs-property">username</span>=<span class="hljs-string">&#x27;wade&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">2</span>].<span class="hljs-property">username</span>) <span class="hljs-comment">// &#x27;wade&#x27;</span><br><br>(<span class="hljs-number">3</span>)<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">slice</span>()<br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,&#123;<span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;kobe&#x27;</span>&#125;]<br><span class="hljs-keyword">let</span> arr3 = arr.<span class="hljs-title function_">slice</span>()<br>arr2[<span class="hljs-number">2</span>].<span class="hljs-property">username</span>=<span class="hljs-string">&#x27;wade&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">2</span>].<span class="hljs-property">username</span>) <span class="hljs-comment">// &#x27;wade&#x27;</span><br><br>(<span class="hljs-number">4</span>) 拓展运算符(...) 用法：...object<br><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;zs&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">hobbies</span>:&#123; <span class="hljs-string">&#x27;eat&#x27;</span>,<span class="hljs-string">&#x27;sleep&#x27;</span>,<span class="hljs-string">&#x27;game&#x27;</span> &#125; &#125;<br><span class="hljs-keyword">const</span> obj2 = &#123; ...obj1 &#125;<br>obj2.<span class="hljs-property">hobbies</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;play&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">hobbies</span>[<span class="hljs-number">0</span>]) <span class="hljs-comment">// &#x27;play&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="深拷贝实现方法："><a href="#深拷贝实现方法：" class="headerlink" title="深拷贝实现方法："></a>深拷贝实现方法：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-number">1</span>)<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>())<br><span class="hljs-comment">// 原理：用JSON.stringify()将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一来一去新的对象产生了，而对象会开辟新的栈，实现深拷贝，但是他不能处理函数</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,&#123;<span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;kobe&#x27;</span>&#125;]<br><span class="hljs-keyword">let</span> arr4 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(arr))<br>arr4[<span class="hljs-number">2</span>].<span class="hljs-property">username</span>=<span class="hljs-string">&#x27;wade&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">2</span>].<span class="hljs-property">username</span>) <span class="hljs-comment">// &#x27;kobe&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr4[<span class="hljs-number">2</span>].<span class="hljs-property">username</span>) <span class="hljs-comment">// &#x27;wade&#x27;</span><br>(<span class="hljs-number">2</span>)手写递归方法<br><span class="hljs-comment">// 原理：遍历对象、数组直到里边都是基本数据类型，再去复制</span><br><span class="hljs-comment">// 定义检测数据类型的功能阳数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkedType</span>(<span class="hljs-params">target</span>) &#123; returm <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(target).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8.</span>-<span class="hljs-number">1</span>) &#125;<br><span class="hljs-comment">//实现深度克隆---对象/数姐</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">target</span>) &#123;<span class="hljs-comment">//利断持贝的数据类型</span><br><span class="hljs-comment">//初始化变量result 成为最终克降的数据</span><br><span class="hljs-keyword">let</span> result, targetType = <span class="hljs-title function_">checkedType</span>(target)<br><span class="hljs-keyword">if</span>(tarketType === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>        result=&#123;&#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(targetType === <span class="hljs-string">&quot;Array&quot;</span>) &#123;<br>        result = []<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> target<br>    &#125;<br><span class="hljs-comment">// 遍历目标数据</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> target) &#123;<span class="hljs-comment">//获取玛历数据结构的每一项值。</span><br>        <span class="hljs-keyword">let</span> value = target[i]<span class="hljs-comment">//判断目标结构里的每一值是否存在对象/数组</span><br>        <span class="hljs-comment">//对象/数组里嵌套了对象/数组</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-title function_">chackedType</span>(value) === <span class="hljs-string">&quot;Object&quot;</span> || <span class="hljs-title function_">checkedType</span>(value) ===“<span class="hljs-title class_">Array</span><span class="hljs-string">&quot;)&#123; </span><br><span class="hljs-string">           //继续遍历获取到value值</span><br><span class="hljs-string">           result[i] = clone(value)</span><br><span class="hljs-string">    &#125;else&#123; //获取到value值是基本的数据爱型或者是的数result[i] w walue;</span><br><span class="hljs-string">        result[i] =  value</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">return rosult</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">(3)函数库lodash</span><br><span class="hljs-string">// lodash提供_.cloneDeep用来做深拷贝</span><br><span class="hljs-string">var _ = require(&#x27;lodash&#x27;)</span><br><span class="hljs-string">var obj1 = &#123;</span><br><span class="hljs-string">    a : 1,</span><br><span class="hljs-string">    b : &#123; f: &#123; g: 1 &#125; &#125;,</span><br><span class="hljs-string">    c: [1, 2, 3]</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">var obj2 = _.cloneDeep(obj1)</span><br><span class="hljs-string">console.log(obj1.b.f === obj2.b.f)</span><br></code></pre></td></tr></table></figure><h2 id="http请求？"><a href="#http请求？" class="headerlink" title="http请求？"></a>http请求？</h2><p>常用：get、push、put、delete</p><p>get和post区别：</p><ol><li>get是从服务器上获取数据，post是向服务器传送数据。</li><li>post比get安全。get传递的参数写在param里，会以查询字符串的方式拼接在url地址后面?key&#x3D;value。post传递的参数写在data里，携带在请求体里。</li><li>get方式需要使用Request.QueryString来取得变量的值，而post方式通过Request.Form来获取变量的值，也就是说get是通过地址栏来传值，而post是通过提交表单来传值。</li><li>get方式提交的数据字节数由浏览器或服务器限制，而post则没有此限制。</li></ol><h2 id="http状态码？"><a href="#http状态码？" class="headerlink" title="http状态码？"></a>http状态码？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 2xx（成功）表示成功处理了请求的状态代码。</span><br><span class="hljs-number">200</span>（成功）服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。<br><span class="hljs-number">201</span>（已创建）请求成功并且服务器创建了新的资源。<br><br><span class="hljs-comment">// 3xx（重定向）表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向。</span><br><span class="hljs-number">301</span>（永久移动）请求的网页已永久移动到新位置。服务器返回此响应（对<span class="hljs-variable constant_">GET</span>或<span class="hljs-variable constant_">HEAD</span>请求的响应）时，会自动将请求者转到新位置。<br><span class="hljs-number">302</span>（临时移动）服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br><span class="hljs-number">304</span>（未修改）自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。<br><br><span class="hljs-comment">// 4xx（客户端错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。</span><br><span class="hljs-number">400</span>（错误请求）服务器不理解请求的语法。<br><span class="hljs-number">401</span>（未授权）请求要求身份验证。对于需要登录的网页，服务器可能返回此响应。<br><span class="hljs-number">403</span>（禁止）服务器拒绝请求。<br><span class="hljs-number">404</span>（未找到）服务器找不到请求的网页。<br><span class="hljs-number">408</span>（请求超时）服务器等候请求时发生超时。<br><br><span class="hljs-comment">// 5xx（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</span><br><span class="hljs-number">500</span>（服务器内部错误）服务器遇到错误，无法完成请求。<br><span class="hljs-number">501</span>（尚未实施）服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。<br><span class="hljs-number">503</span>（服务不可用）服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。<br></code></pre></td></tr></table></figure><h2 id="http请求报文"><a href="#http请求报文" class="headerlink" title="http请求报文"></a>http请求报文</h2><p>http请求包括请求行、请求头、空行和请求体组成。</p><p>请求行包括请求方法、URL地址和协议版本，用空格隔开。</p><p>请求头用于指定服务器要使用的附加信息。请求头包括：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Accept</span>：向服务器申明客户端可以接收的媒体类型（<span class="hljs-variable constant_">MIME</span>）的资源<br><span class="hljs-title class_">Accept</span>-<span class="hljs-title class_">Encoding</span>：客户端所能够支持的压缩格式<br><span class="hljs-title class_">Accept</span>-<span class="hljs-title class_">Language</span>：指定http请求返回信息时优先选择的语言<br><span class="hljs-title class_">Connection</span>：是否需要持久连接<br><span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Length</span>：是请求体内容的长度<br><span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Type</span>：表示http请求提交的内容类型，只有在<span class="hljs-variable constant_">POST</span>方法提交时才需要设置此属性<br><span class="hljs-title class_">Cookie</span>：存放用户身份的数据<br><span class="hljs-title class_">Host</span>：请求地址<br><span class="hljs-title class_">User</span>-<span class="hljs-title class_">Agent</span>：记录客户端的详细信息<br></code></pre></td></tr></table></figure><p>空行就是用于分割POST请求的请求头和请求体。</p><p>请求体主要封装的是POST请求消息的请求参数。</p><h2 id="http响应报文"><a href="#http响应报文" class="headerlink" title="http响应报文"></a>http响应报文</h2><p>http请求包括状态行、响应头、空行和响应体组成。</p><p>状态行包括报文协议及版本、状态码以及状态描述。</p><p>响应头用于描述服务器的基本信息。</p><p>空行就是用于分割POST请求的响应头和响应体。</p><p>响应体主要存放服务器响应给客户端的资源内容。</p><h2 id="http和https协议"><a href="#http和https协议" class="headerlink" title="http和https协议"></a>http和https协议</h2><p>https协议的全称为Hypertext Transfer Protocol over Secure Socket Layer，它是以安全为目标的http通道，是http的“升级”版本。</p><p>https的安全基础是SSL，即在http下加入SSL层。也就是https通过安全传输机制进行传送数据，这种机制可保护网络传送的所有数据的隐秘性与完整性，可以降低非侵入性拦截攻击的可能性。</p><p>http协议与https协议的主要区别如下。</p><ol><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的SSL加密传输协议。</li><li>http与https协议使用的是完全不同的连接方式，http采用80端口连接，而https则是443端口。</li><li>https协议需要到ca 申请证书，一般免费证书很少，需要交费。而http协议却不需要。</li><li>http连接相对简单，是无状态的，而 https协议是由SSL+http协议构建的可进行加密传输、身份认证的网络协议，相对来说，它要比http协议更安全。</li></ol><h2 id="cookie、localStorage、sessionStorage的区别-袋鼠云笔试"><a href="#cookie、localStorage、sessionStorage的区别-袋鼠云笔试" class="headerlink" title="cookie、localStorage、sessionStorage的区别(袋鼠云笔试)"></a>cookie、localStorage、sessionStorage的区别(袋鼠云笔试)</h2><p>共同点:都是保存在浏览器端、且同源的</p><p>不同点：</p><p>1、存储位置不同：</p><p>cookie在浏览器和服务器间来回传递，cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下</p><p>sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。</p><p>2、存储大小限制不同：</p><p>cookie数据不能超过4K，sessionStorage和localStorage可以达到5M</p><p>3、保存数据有效时间不同：</p><p>sessionStorage：仅在当前浏览器窗口关闭之前有效；</p><p>localStorage：始终有效，窗口或浏览器关闭也一直保存，本地存储，因此用作持久数据；</p><p>cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭</p><p>作用域不同</p><h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>token的定义：Token是服务端生成的一串字符串，当作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token并将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</p><p>token认证流程：</p><p>token 的认证流程与cookie很相似</p><p>用户登录，成功后服务器返回Token给客户端。</p><p>客户端收到数据后保存在客户端</p><p>客户端再次访问服务器，将token放入headers中</p><p>服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</p><h2 id="后台管理系统中的权限管理是怎么实现的"><a href="#后台管理系统中的权限管理是怎么实现的" class="headerlink" title="后台管理系统中的权限管理是怎么实现的?"></a>后台管理系统中的权限管理是怎么实现的?</h2><p>登录：</p><p>当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个token，拿到token之后(将这个token存贮到cookie中，保证刷新页面后能记住用户登录状态)，前端会根据token再去拉取一个userinfo的接口来获取用户的详细信息(如用户权限，用户名等等信息)</p><p>权限验证：</p><p>通过token获取用户对应的权限，动态根据用户的权限算出其对应的路由，通过router.addRoutes 动态挂载这些路由。</p><p>具体思路：</p><p>登录成功后，服务端会返回一个token (该token的是一个能唯一标示用户身份的一个key)，之后我们将token存储在本地cookie之中，这样下次打开页面或者刷新页面的时候能记住用户的登录状态，不用再去登录页面重新登录了。</p><p>PS：为了保证安全性，我司现在后台所有token有效期(Expires&#x2F;Max-Age)都是Session，就是当浏览器关闭了就丢失了。重新打开游览器都需要重新登录验证，后端也会在每周固定一个时间点重新刷新token，让后台用户全部重新登录一次，确保后台用户不会因为电脑遗失或者其它原因被人随意使用账户。</p><p>用户登录成功之后，我们会在全局钩子router.beforeEach 中拦截路由，判断是否已获得token，在获得token之后我们就要去获取用户的基本信息了，页面会先从cookie 中查看是否存有 token，没有，就走一遍上一部分的流程重新登录，如果有token.就会把这个token 返给后端去拉取userinfo，保证用户信息是最新的。当然如果是做了单点登录功能的话，用户信息存储在本地也是可以的。当你一台电脑登录时，另一台会被提下线，所以总会重新登录获取最新的内容。</p><p>权限控制的主体思路：</p><p>前端会有一份路由表，它表示了每一个路由可访问的权限。当用户登录之后，通过 token 获取用户的role，动态根据用户的role 算出其对应有权限的路由，再通过router.addroutes动态挂载路由。但这些控制都只是页面级的，说白了前端再怎么做权限控制都不是绝对安全的，后端的权限验证是逃不掉的。</p><p>我司现在就是前端来控制页面级的权限，不同权限的用户显示不同的侧边栏和限制其所能进入的页面(也做了少许按钮级别的权限控制)，后端则会验证每一个涉及请求的操作，验证其是否有该操作的权限，每一个后台的请求不管是get还是post 都会让前端在请求 header里面携带用户的 token，后端会根据该 token 来验证用户是否有权限执行该操作。若没有权限则抛出一个对应的状态码，前端检测到该状态码，做出相对应的操作。</p><p>使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。</p><p>具体实现:</p><p>创建vue实例的时候将vue-router挂载，但这个时候vue-router挂载一些登录或者不用权限的公用的页面。</p><p>当用户登录后，获取用role，将role和路由表每个页面的需要的权限作比较，生成最终用户可访问的路由表。</p><p>调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由。</p><p>使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>Promise是ES6异步编程的一种解决方案，async和await是基于Promise的解决方案， Promise是一个对象或者说是构造函数，用来封装异步操作并可以获取其成功或失败的结果。</p><h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><p>ajax和axios请求。由于网速的不同，可能得到返回值的时间也是不同的，但是下一步要执行的代码依赖于上一次请求返回值，这个时候就需要等待，结果出来了之后才知道怎么样继续下去。</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>1.可以避免多层异步调用嵌套问题(回调地狱)</p><p>2.Promise 对象提供了简洁的API，使得控制异步操作更加容易</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol><li>promise一旦新建就会立即执行，无法中途取消</li><li>当处于pending状态时，无法得知当前处于哪一个状态</li><li>如果不设置回调函数，promise内部的错误就无法反映到外部</li><li>promise封装ajax时，由于promise是异步任务，发送请求的三步会被延后到整个脚本同步代码执行完，并且将响应回调函数延迟到现有队列的最后，如果大量使用会大大降低了请求效率。</li></ol><h3 id="三种状态："><a href="#三种状态：" class="headerlink" title="三种状态："></a>三种状态：</h3><ol><li>pending：等待中，或者进行中，表示还没有得到结果</li><li>resolved(Fulfilled)：已经完成，表示得到了我们想要的结果，可以继续往下执行</li><li>rejected：也表示得到结果，但是由于结果并非我们所愿，因此拒绝执行</li></ol><p>这三种状态不受外界影响，而且状态只能从pending改变为resolved或者rejected，不可逆。</p><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><p>1.promise的实例方法</p><ol><li><p>then()得到异步任务的正确结果；</p></li><li><p>catch()获取异常信息；</p></li><li><p>finally()成功与否都会执行(尚且不是正式标准)。</p></li></ol><p>注意：then方法可以接受两个函数，第一个函数为promise状态为成功的回调函数，第二个函数为promise状态为失败的回调函数(可以不写，一般用catch方法捕获promise状态为失败的异常信息)</p><p>2.promise的对象方法(p1,p2,p3为promise的实例对象)</p><ul><li>Promise.all()并发处理多个异步任务，所有任务都执行完成才能得到结果</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2, p3]) .<span class="hljs-property">then</span> ( <span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span> (result)<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>Promise.race()并发处理多个异步任务，只要有一个任务完成就能得到结果</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">race</span> ([p1, p2, p3]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>. <span class="hljs-title function_">log</span> (result)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="Promise的特点"><a href="#Promise的特点" class="headerlink" title="Promise的特点"></a>Promise的特点</h3><ol><li><p>在Promise对象的构造函数中，将一个函数作为第一个参数。</p><ol><li>而Promise对象的构造函数的第一个参数中的这个函数，就是用来处理Promise的状态变化，这个函数的第一个参数表示promise的状态为成功，第二个参数表示promise的状态为失败，这两个参数(名字可以自己命名)都为一个函数，他们的作用分别是将promise状态修改为resolved(成功)和rejected(失败)。</li></ol></li><li><p>Promise对象中的then方法，可以接收构造函数中处理的状态变化，并分别对应执行。then方法有2个函数参数，第一个函数接收resolved(promise状态为成功)的执行，第二个函数接收reject(promise状态为失败)的执行。</p></li><li><p>promise的状态只能从 未完成-&gt;完成, 未完成-&gt;失败 且状态不可逆转。</p><ol><li>promise的异步结果，只能在完成状态时才能返回，而且我们在开发中是根据结果来选择状态的，然后根据状态来选择是否执行then()。</li><li>实例化的Promise内部会立即执行，then方法中的异步回调函数会在脚本中所有同步任务完成时才会执行。因此，promise的异步回调结果最后输出。</li></ol></li><li><p>Promise.then()方法</p><ol><li>then()函数返回的实际也是一个Promise对象(无论函数内部返回什么类型的数据，函数都会进行加工返回一个promise对象)</li><li>then()函数内部返回为普通值(非Promise类型的属性)，返回的普通值会直接传递给下一个then，通过then参数中函数的参数接收该值。这时then()函数返回的Promise对象状态为成功(resloved)，then()函数的返回值为对象的成功值，如return 123，返回的Promise对象值为123，如果没有返回值，是undefined。</li><li>当then()函数内部返回的是Promise类型的对象时，then()函数的返回的Promise对象的状态值为这个Promise对象的状态值，成功值也是如此，返回的该promise对象会调用下一个then方法。</li></ol></li><li><p>Promise.catch()方法</p><ol><li>catch()函数只有一个回调函数，意味着如果Promise对象状态为失败就会调用catch()方法并且调用回调</li></ol></li></ol><h3 id="async和await的区别"><a href="#async和await的区别" class="headerlink" title="async和await的区别"></a>async和await的区别</h3><p>async是来定义函数的，定义异步函数，打印函数名可以得到一个promise对象，言外之意可以通过这个函数名称调用.then这个方法</p><p>await后面跟的是任意表达式，一般使用promise的表达式</p><p>async内部实现，又返回值成功返回promise.resolve()，出错返回promise.reject()返回值用catch捕获</p><p>await等待后面的promise对象执行完毕，拿到了promise.resolve()的值之后，执行后面的代码。await后面的表达式，能是promise.reject()，所以建议await放在try….catch语句中</p><p>优点：async和await编写方便，提高程序效率，避免了回调地狱</p><p>补充：promise和async和await的区别</p><p>promise es6语法，promise中包含catch，async需要自己定义catch</p><p>promise提供的方法会多一些，all、race等方法，async中是没有的。</p><h2 id="Promise面试题以下代码的执行结果是？"><a href="#Promise面试题以下代码的执行结果是？" class="headerlink" title="Promise面试题以下代码的执行结果是？"></a>Promise面试题以下代码的执行结果是？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">//同步</span><br>    <span class="hljs-title function_">resolve</span>() <span class="hljs-comment">//执行.then()回调函数打印3</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">//同步</span><br>&#125;)<br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123; <span class="hljs-comment">//微任务</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>) <span class="hljs-comment">//同步</span><br><span class="hljs-comment">// 1 2 4 3</span><br></code></pre></td></tr></table></figure><p>解释：以上考察的是关于promise的原理，promise的构造函数本身是同步执行的，当newPromise的一瞬间，1,2就立刻被执行，而.then方法是异步执行的，当执行完1和2之后，会执行输出4，最后执行输出3</p><h2 id="一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么"><a href="#一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么" class="headerlink" title="一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么?"></a>一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么?</h2><ol><li>浏览器查找域名对应的IP地址(DNS查询:浏览器缓存-系统缓存路由器缓存-ISPDNS缓存-&gt;根域名服务器)</li><li>浏览器向Web 服务器发送一个HTTP请求(TCP三次握手)</li><li>服务器301 重定向 (从<a href="http://example.com/">http://example.com</a> 重定向到 <a href="http://www.example.com/">http://www.example.com</a>)</li><li>浏览器跟踪重定向地址，请求另一个带www的网址</li><li>服务器处理请求(通过路由读取资源)</li><li>服务器返回一个HTTP 响应(报头中把 Content-type设置为text&#x2F;html)</li><li>浏览器进DOM 树构建</li><li>浏览器发送请求获取嵌在HTML中的资源(如图片、音频、视频、CSSJS等)</li><li>浏览器显示完成页面</li><li>浏览器发送异步请求</li></ol><h2 id="跨域是什么-如何解决跨域问题"><a href="#跨域是什么-如何解决跨域问题" class="headerlink" title="跨域是什么? 如何解决跨域问题?"></a>跨域是什么? 如何解决跨域问题?</h2><p>跨域:当前页面中的某个接口请求的地址和当前页面的地址如果协议、域名、端口其中有一项不同，就说该接口跨域了。</p><p>跨域限制的原因:浏览器为了保证网页的安全，出的同源协议策略。</p><p>跨域解决方案: </p><ol><li><p>cors：目前最常用的一种解决办法，通过设置后端允许跨域实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>,*);<br>res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span> <span class="hljs-string">&quot;GET,PUT,OPTIONS,POST&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>jsonp：浏览器端通过script标签的src属性，请求服务器端的数据，同时服务器端返回一个函数的调用。</p><p>特点：</p><p>(1)不属于真正的Ajax请求，因为没有使用XMLHttpRequest这个对象</p><p>(2)只支持get请求。</p></li><li><p>node中间件、nginx反向代理：</p><p>跨域限制的时候浏览器不能跨域访问服务器，node中间件和nginx反向代理，都是让请求发给代理服务器，静态页面和代理服务器是同源的，然后代理服务器再向后端服务器发请求，服务器和服务器之间不存在同源限制。</p></li><li><p>postmessage：</p><p>H5新增API，通过发送和接收API实现跨域通信。</p><p>跨域场景:前后端分离式开发、调用第三方接口</p></li></ol><h2 id="项目性能优化方案"><a href="#项目性能优化方案" class="headerlink" title="项目性能优化方案"></a>项目性能优化方案</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">减少http请求<br>减少<span class="hljs-variable constant_">DNS</span>查询<br>使用<span class="hljs-variable constant_">CDN</span>加载静态资源文件和<span class="hljs-variable constant_">JS</span>库<br>避免重定向<br>图片懒加载<br>路由懒加载(<br>目的：为了让第一个页面，加载的app.<span class="hljs-property">js</span>小一点，打开网页快一点<br>思路：把组件对应js分成若干个.<span class="hljs-property">js</span> 路由切换到哪个页面再加载对应的.<span class="hljs-property">js</span>文件<br>原因：webpack分析入口时，发现router上来就<span class="hljs-keyword">import</span>所有页面，所有直接打包app.<span class="hljs-property">js</span>很大<br>解决：当路由路径匹配规则时，才去<span class="hljs-keyword">import</span>引入对应的组件js文件)<br>减少<span class="hljs-variable constant_">DOM</span>元素操作<br>使用外部js和css<br>压缩js、css、字体、图片等<br>使用iconfont字体图标、雪碧图(sprit精灵图)等<br>避免图片的src为空<br>把样式表放在link中<br>把js放在页面的底部<br></code></pre></td></tr></table></figure><h2 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h2><p>问题：</p><p>大型网站如常用的淘宝，京东等页面，需要展示大量的商品图片信息，如果打开网页时让所有图片一次性加载完成，需要处理很多次网络请求，等待加载时间比较长，用户体验感很差。</p><p>解决方式：</p><p>随着滚动动态加载，即图片的惰性加载。视图之外的图片默认不加载，随着页面的滚动，图片进入了显示的范围，则触发图片的加载显示。</p><p>优点：页面加载速度快，用户体验感更好且节省流量</p><p>原理方法：</p><p>初始化时，图片标签的src不能是真实的图片地址，也不可以是空地址或者坏地址(会出现图片加载失败的图标)。</p><ol><li><p>1、初始化的时候，可以设置图片的src是某一个小型图片。例如一张1px*1px的透明图片。由于所有图片都使用这一张图片，只会发送一次请求，不会增加性能负担。</p></li><li><p>2、将图片的真实路径绑定给一个自定义属性，例如data-url。注意：页面的img元素，如果没有src属性，浏览器就不会发出请求去下载图片。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;1px.gif&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>定义滚动事件，当元素进入视口，则将src替换为真正的url地址。利用js提取data-url的真实图片地址赋值给src属性。</p></li></ol><p>实现方法：</p><p>图片懒加载的关键在于获取元素的位置，并判断其是否出现在视口。故有以下两种方式</p><p>滚动监听+scrollTop+offsetTop+innerHeight</p><p>jquery插件库EasyLazyload</p><p>3.1 滚动监听+scrollTop+offsetTop+innerHeight</p><p>scrollTop：指网页元素被滚动条卷去的部分。</p><p>offsetTop：元素相对父元素的位置</p><p>innerHeight：当前浏览器窗口的大小。需要注意兼容性问题。</p><p>IE8及更早版本以前没有提供取得浏览器窗口大小的属性，不过提供了API：document.documentElement.clientHeight&#x2F;clientWidth：返回元素内容及其内边距所占据的空间大小。</p><p>当scrollTop+innerHeight &gt; offsetTop，即图片在视口内，否则图片在可视区域外。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">scrollTop：指网页元素被滚动条卷去的头部。<br>scrollLeft：指网页元素被滚动条卷去的左边。<br>offsetTop：元素相对父元素上边界的距离<br>offsetWidth：元素相对父元素左边界的距离<br><span class="hljs-attr">clientLeft</span>: 该元素对象左边框的宽度<br><span class="hljs-attr">clientWidth</span>: 该元素对象左内边框到右内边框的宽度<br><span class="hljs-attr">offsetLeft</span>: 该左边框到窗口左边界的距离<br><span class="hljs-attr">offsetWidth</span>: 该元素对象左外边框到右外边框的宽度<br>clientX/clientY：当事件触发时鼠标指针相对于可视区域左边界的x,y坐标<br>pageX/pageY：当事件触发时鼠标指针相对于可视区域左边界的x,y坐标<br>screenX/screenY：点击位置距离电脑屏幕的x,y坐标<br>offsetX/offsetY：相对于带有定位的父盒子的x,y坐标<br></code></pre></td></tr></table></figure><h2 id="获取浏览器url中查询字符串的参数"><a href="#获取浏览器url中查询字符串的参数" class="headerlink" title="获取浏览器url中查询字符串的参数"></a>获取浏览器url中查询字符串的参数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">geturlpara</span>(<span class="hljs-params">sHref</span>) &#123;<br>    <span class="hljs-comment">//获取向号</span><br>    <span class="hljs-keyword">var</span> args = shref.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;?&quot;</span>);<br>    <span class="hljs-comment">//无传入参数</span><br>    <span class="hljs-keyword">if</span>(args[<span class="hljs-number">0</span>] == sHref) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-comment">//对?后的参数进行处理</span><br>    <span class="hljs-keyword">var</span> arr = args[<span class="hljs-number">1</span>].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&amp;&quot;</span>);<br>    <span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;arr.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">var</span> arg = arr[i].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;=&quot;</span>);<br>        obj[arg[<span class="hljs-number">0</span>]] =arg[<span class="hljs-number">1</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Set和Map"><a href="#Set和Map" class="headerlink" title="Set和Map"></a>Set和Map</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值（对象或者基本类型）都可以作为一个键或一个值。Map 对象是一个构造函数，所以我们在初始化的时候可以传入默认数据的，只不过我们需要注意传入默认数据的格式，它默认接收一个二维数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> defaultMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;zs&#x27;</span>],[<span class="hljs-string">&#x27;age&#x27;</span>,<span class="hljs-number">20</span>]])<br><span class="hljs-comment">// Map(2) &#123; &#x27;name&#x27; =&gt; &#x27;zs&#x27;, &#x27;age&#x27; =&gt; 20 &#125;</span><br><span class="hljs-comment">// 0: &#123; &#x27;name&#x27; =&gt; &#x27;zs&#x27; &#125; key:&#x27;name&#x27;, value:&#x27;zs&#x27;</span><br><span class="hljs-comment">// 1: &#123; &#x27;age&#x27; =&gt; 20 &#125; key:&#x27;age&#x27;, value: 20</span><br></code></pre></td></tr></table></figure><p>特点：</p><ol><li>Map 对象这种数据结构和和对象类型，都已键值对的形式存储数据，即 key-value 形式。</li><li>Map 对象存储的数据是有序的，而我们平常使用的对象是无序的，所以通常当我们需要使用对象形式（键值对）存储数据且需要有序时，采用 Map 对象进行存储。</li><li>Map 对象的键值可以是任意类型，我们平时使用的对象只能使用字符串作为键。</li></ol><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set对象是值的集合，你可以按照插入的顺序迭代它的元素。Set 中的元素只会出现一次，即 Set 中的元素是唯一的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> defaultSet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-number">12</span>,<span class="hljs-literal">true</span>])<br><span class="hljs-title class_">Set</span>(<span class="hljs-number">3</span>) &#123;<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-number">12</span>, <span class="hljs-literal">true</span>&#125;<br><span class="hljs-comment">// [[Entries]]</span><br><span class="hljs-comment">// 0: &quot;name&quot;</span><br><span class="hljs-comment">// 1: 12</span><br><span class="hljs-comment">// 2: true</span><br><span class="hljs-comment">// size: 3</span><br></code></pre></td></tr></table></figure><p>特点：</p><ol><li>Set 对象是一个伪数组对象。</li><li>Set 对象存储的值是不重复的，所以我们通常使用它来实现数组去重。</li><li>Set 对象存储的数据不是键值对的形式，而且它可以存储任何类型的数据。</li></ol><h3 id="Map和Set区别："><a href="#Map和Set区别：" class="headerlink" title="Map和Set区别："></a>Map和Set区别：</h3><ol><li><p>Map和Set查找速度都非常快，时间复杂度为O(1)，而数组查找的时间复杂度为O(n)。</p><p>(Map和Set存储的所有元素都是以节点的方式来进行存储的，这种节点结构和链表有点类似。我们都知道链表的特点是插入和删除都非常快，时间复杂度为O(1)，两个节点通过指针相连，删除或者增加元素时，我们只是重新更改了指针的指向，不想数组那样，掺入或删除之后需要重新排序)</p></li><li><p>Map对象初始化的值为一个二维数组，Set对象初始化的值为一维数组。</p></li><li><p>Map对象和Set对象都不允许键重复（可以将Set对象的键想象成值）。</p></li><li><p>Map对象的键是不能改的，但是值能改，Set对象只能通过迭代器来更改值。</p></li></ol><p>使用场景：</p><p>Set：使用Set对象的唯一性值特性给数组去重，需要注意的是Set对象是一个类数组，使用…扩展运算符将一个类数组转化为了一个真正的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)]) <span class="hljs-comment">// [1,2,3,4,5]</span><br></code></pre></td></tr></table></figure><p>Map：使用Map对象建立一个请求状态码对象字典，因为状态码是数字类型，所以使用Map对象很合适。除了该场景外，如果需要保证对象的顺序，那么也是可以使用Map对象的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> errors=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>    [<span class="hljs-number">400</span>, <span class="hljs-string">&#x27;InvaildParameter&#x27;</span>],<br>    [<span class="hljs-number">404</span>, <span class="hljs-string">&#x27;Not found&#x27;</span>],<br>    [<span class="hljs-number">500</span>, <span class="hljs-string">&#x27;InternalError&#x27;</span>]<br>])<br><span class="hljs-comment">// 0: &#123; 400 =&gt; &#x27;InvaildParameter&#x27; &#125;</span><br><span class="hljs-comment">// 1: &#123; 404 =&gt; &#x27;Not found&#x27; &#125;</span><br><span class="hljs-comment">// 2: &#123; 500 =&gt; &#x27;InternalError&#x27; &#125;</span><br></code></pre></td></tr></table></figure><h2 id="JS获取DOM元素的方法"><a href="#JS获取DOM元素的方法" class="headerlink" title="JS获取DOM元素的方法"></a>JS获取DOM元素的方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">返回的<span class="hljs-title class_">NodeList</span>对象都属于伪数组，也称为类数组<br>getElementsByName 获取符合name属性的元素结合<br>getElementsByClassName 获取符合<span class="hljs-keyword">class</span>属性的元素结合<br>querySelectorAll 获取符合选择器要求的元素结合<br>getElementsByTagName 获取符合标签名的元素结合<br><br>获取到的是单个元素<br>getElementById 获取符合id要求的元素<br>querySelector 获取符合选择器要求的第一个元素<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span> 获取body元素对象<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span> 获取html元素对象<br></code></pre></td></tr></table></figure><h2 id="HTML5自定义属性"><a href="#HTML5自定义属性" class="headerlink" title="HTML5自定义属性"></a>HTML5自定义属性</h2><p>设置自定义属性 element.setAttribute(‘data-属性’，值)</p><p>获取自定义属性 element.getAttribute(‘data-属性’)&#x2F;element.dataset.属性&#x2F; element.dataset[‘属性’]</p><p>dataset是一个存放了所有以data-开头的自定义属性的集合</p><h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><p>节点Node至少拥有nodetype，nodeName，nodeValue三个基本属性</p><p>元素节点 nodetype 1</p><p>属性节点 nodetype 2</p><p>文本节点 nodetype 3</p><p>节点操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js">获取父节点：node.<span class="hljs-property">parentNode</span> 得到的是离元素最近的父级节点。注意：如果找不到父节点就返回为<span class="hljs-literal">null</span>。<br><br>子节点操作<br>node.<span class="hljs-property">childNodes</span> (获取所有的子节点 包含 元素节点 文本节点等等)<br>node.<span class="hljs-property">childNode</span>[i] (获取第i-<span class="hljs-number">1</span>个子节点)<br>node.<span class="hljs-property">children</span> (获取所有的子元素节点)（常用）<br>node.<span class="hljs-property">children</span>[i] (获取第i-<span class="hljs-number">1</span>个子元素节点)（常用，没有兼用性问题）<br>node.<span class="hljs-property">firstChild</span>（第一个子节点 不管是文本节点还是元素节点）<br>node.<span class="hljs-property">lastChild</span>（最后一个子节点 不管是文本节点还是元素节点）<br>node.<span class="hljs-property">firstElementChild</span>（第一个子元素节点，ie9才支持）<br>node.<span class="hljs-property">lastElementChild</span>（最后一个子元素节点，ie9才支持）<br><br>兄弟节点操作<br>node.<span class="hljs-property">nextSibling</span> (下一个兄弟节点 包含元素节点或者 文本节点等等)<br>node.<span class="hljs-property">previousSibling</span> (上一个兄弟节点 包含元素节点或者 文本节点等等)<br>node.<span class="hljs-property">nextElementSibling</span> （得到下一个兄弟元素节点）<br>node.<span class="hljs-property">previousElementSibling</span> （得到上一个兄弟元素节点,如果不存在，则返回<span class="hljs-literal">null</span>）<br><br>创建节点：<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(‘tagName’)<br><br>添加节点：<br>(<span class="hljs-number">1</span>)node.<span class="hljs-title function_">appendChild</span>(child) 其中node父级，child是子级 后面追加元素，此操作类似数组中的push；<br>(<span class="hljs-number">2</span>)node.<span class="hljs-title function_">insertBefore</span>(child, 指定元素) 该方法是将节点添加到指定元素的前面。<br><br>删除节点操作：<br>删除节点：node.<span class="hljs-title function_">removeChild</span>(child)<br><br>复制节点操作：<br>浅拷贝：node.<span class="hljs-title function_">cloneNode</span>() 浅拷贝的意思是只复制标签不复制里面的内容<br>深拷贝：node.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>) 深拷贝的意思是复制标签以及里面的内容<br></code></pre></td></tr></table></figure><h2 id="websocket和http"><a href="#websocket和http" class="headerlink" title="websocket和http"></a>websocket和http</h2><p>相同点</p><p>1、都是一样基于TCP的，都是可靠性传输协议。</p><p>2、都是应用层协议。</p><p>区别：</p><p>1、WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息，而HTTP是单向的；</p><p>2、WebSocket是需要浏览器和服务器握手进行建立连接的，而http是浏览器发起向服务器的连接。</p><h2 id="JavaScript的全局函数"><a href="#JavaScript的全局函数" class="headerlink" title="JavaScript的全局函数"></a>JavaScript的全局函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">编码相关：<br><span class="hljs-built_in">escape</span>()、<span class="hljs-built_in">unescape</span>()、<span class="hljs-built_in">encodeURI</span>()、<span class="hljs-built_in">decodeURI</span>()、<br><span class="hljs-built_in">encodeURIComponent</span>()、<span class="hljs-built_in">decodeURIComponent</span>()<br><br>数据处理：  <br><span class="hljs-title class_">Number</span>()、<span class="hljs-title class_">String</span>()<br><br>数字相关：<br><span class="hljs-built_in">isFinite</span>()、<span class="hljs-built_in">isNaN</span>()、<span class="hljs-built_in">parseFloat</span>()、<span class="hljs-built_in">parseInt</span>()<br><br>特殊：<br><span class="hljs-built_in">eval</span>()<br></code></pre></td></tr></table></figure><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="MVC和MVVM的区别"><a href="#MVC和MVVM的区别" class="headerlink" title="MVC和MVVM的区别"></a>MVC和MVVM的区别</h2><p>MVC是Model-View- Controller的简写，即模型-视图-控制器。</p><p>Model：模型，指的是后端传递的数据。</p><p>View：视图层，用户所看到的页面。</p><p>Controller：控制器，页面业务逻辑。</p><p>View传送指令到Controller，Controller完成业务逻辑后，要求Model改变状态，Model将新的数据发送到View，用户得到反馈。</p><p>MVC是单向通信。</p><p>MVC的优点：</p><p>1耦合度低，视图层和业务层分离</p><p>2重用度高</p><p>3生命周期成本低</p><p>4可维护性高</p><p>5部署快</p><p>MVC的缺点：</p><p>1前后端无法独立开发，必须等后端接口做好了才可以往下走；前端没有自己的数据中心，太过依赖后台。（视图与控制器间的过于紧密的连接：视图和业务逻辑没有完全分离）</p><p>2 View更新的时候，必须要通过Controller去更新一遍Model；同样的Model更新的时候，也要去更新一遍视图。此时开发者是在同时维护View层和Model层。当页面复杂的时候，开发者不得不做许多繁琐的工作来保证数据的状态、页面的展示都是正确的。（频繁手动操作dom）</p><p>MVC的应用：主要用于中大型项目的分层开发。</p><p>MVVM：</p><p>Model：模型，指的是后端传递的数据。</p><p>View：视图，指的是所看到的页面。</p><p>ViewModel：视图模型，mvvm模式的核心，它是连接view和model的桥梁。主要用来处理业务逻辑</p><p>MVVM的特点： </p><p>MVVM框架下，视图和模型是不能直接通信的，它们通过ViewModal来通信。</p><p>当数据源发生变化时，会被VM监听到，VM根据最新的数据源自动更新页面结构；</p><p>当表单元素的值发生变化时，也会被VM监听到，VM会把变化后最新的值自动同步到Model数据源中。</p><p>MVVM的优点：</p><p>MVVM模式的主要目的是分离视图（View）和模型（Model），有几大优点：</p><p>1低耦合，视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</p><p>2可重用性，可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</p><p>3可测试，界面向来是比较难于测试的，而现在测试可以针对ViewModel来写</p><p>4双向数据绑定，它实现了View和Model的自动同步，当Model的属性改变时，不需要手动操作Dom元素，来改变View的显示，而是改变属性后该属性对应View层显示会自动改变。</p><p>MVVM适用场景： </p><p>适合数据驱动的场景，数据操作比较多的场景</p><p>MVVM与MVC区别：</p><p>1 MVVM实现了View和Model的自动同步（双向数据绑定），也就是当Model的属性改变时，我们不用再自己手动操作Dom元素，来改变View的显示，而是改变属性后该属性对应View层显示会自动改变(自动更新 dom)。</p><p>2 MVVM并不是VM完全取代了C，只是在MVC的基础上增加了一层VM，只不过是弱化了C的概念，ViewModel存在目的在于抽离Controller中展示的业务逻辑，而不是替代Controller，其它视图操作业务等还是应该放在Controller中实现。也就是说MVVM实现的是业务逻辑组件的复用，使开发更高效，结构更清晰，增加代码的复用性。</p><h2 id="Vue2-0-响应式原理与缺陷"><a href="#Vue2-0-响应式原理与缺陷" class="headerlink" title="Vue2.0 响应式原理与缺陷?"></a>Vue2.0 响应式原理与缺陷?</h2><p>Vue响应式指的是: 组件的data发生变化立刻触发视图的更新</p><p>原理：Vue采用数据劫持结合发布者-订阅者模式的方式来实现数据的响应式，通过Object.defineProperty来劫持数据的setter，getter，在数据变动时发布消息给订阅者，订阅者收到消息后进行相应的处理。 通过原生js提供的监听数据的API，当数据发生变化的时候，在回调函数中修改dom。</p><p>核心API: </p><p>Object.defineProperty (操作的对象，属性，{get(){} set(){} })</p><p>Object.definePropertyAPI的使用</p><p>作用:用来定义对象属性</p><p>特点:默认情况下定义的数据的属性不能修改描述属性和存取属性不能同时使用，使用会报错</p><p>响应式原理: 获取属性值会触发getter方法，设置属性值会触发setter方法，在setter方法中调用修改dom的方法。</p><p>Object.defineProperty的缺点（也是为熊数据变了，视图没变的原因） </p><p>1.深度监听需要一次性递归，一次性递归到底开销很大，如果数据很大，大量的递归导致调用栈溢出</p><p>2.不能监听对象的新增属性和删除属性，</p><p>3.无法监控到数组下标的变化，通过数组下标修改元素，无法实时响应</p><p>4.无法正确的监听数组的方法。</p><h2 id="Vue双向数据绑定原理"><a href="#Vue双向数据绑定原理" class="headerlink" title="Vue双向数据绑定原理"></a>Vue双向数据绑定原理</h2><p>v-model指令和.sync修饰符可以实现数据的双向绑定</p><p><strong>v-model****本质：</strong>给所在标签绑定:value&#x3D;“Vue变量” @input&#x3D;“val &#x3D;&gt; Vue变量 &#x3D; val”</p><p>&lt;标签 v-model&#x3D;“Vue变量” &gt;&lt;&#x2F;标签&gt;</p><p>运行时</p><p>&lt;标签 :value&#x3D;“Vue变量” @input&#x3D;“val &#x3D;&gt; Vue变量&#x3D;val”&gt;&lt;&#x2F;标签&gt;</p><p>子组件内子传父的时候 this.$emit(‘input’, 值)</p><p>Vue2中里面一个标签上v-model只能用一次，Vue3里可以用多次.sync修饰符</p><p><strong>.sync****本质</strong>：给所在标签绑定:props属性名&#x3D;“Vue变量” @update:props属性名&#x3D;“val &#x3D;&gt; Vue变量 &#x3D; val”</p><p>&lt;标签 :visible.sync&#x3D;“Vue变量” &gt;&lt;&#x2F;标签&gt;</p><p>运行时</p><p>&lt;标签 :visible&#x3D;“Vue变量” @update:visible&#x3D;“val &#x3D;&gt; Vue变量&#x3D;val”&gt;&lt;&#x2F;标签&gt;</p><p>子组件内子传父的时候 this.$emit(‘update:visible’, 值)</p><h2 id="Vue中为什么数据变了，视图没变？"><a href="#Vue中为什么数据变了，视图没变？" class="headerlink" title="Vue中为什么数据变了，视图没变？"></a>Vue中为什么数据变了，视图没变？</h2><p>(1) 我们在开发过程中会碰到数据更新，但是视图并未改变的情况，情况如下：</p><p>第一种:动态给对象新增属性或者删除属性是不会触发视图刷新的,Vue识别不到；</p><p>第二种:通过数组下标修改数组中的元素或者手动修改数组的长度或者使用了不改变原数组的方数组法,Vue识别不到；</p><p>(2) 如何解决？</p><p>解决方法1：静默刷新(使用v-if的特性)</p><p>在修改值之后将元素销毁，然后在修改后的下一次DOM渲染完成时再显示出来，这样就会触发组件重新加载data的数据进行渲染,data中被修改的数据才是最新的。</p><p>解决方法2：Vue. $set(官方推荐)</p><p>使用这个api修改的数据会为其添加响应式getter和setter让其拥有数据响应的特性</p><p>Vue.$set (要操作的对象或者数组，要增加或者修改的数组或对象key，对应的值)</p><p>解决方法3：Vue.$forceUpdate()手动强制更新视图</p><p>因为Vue修改数据是异步执行的,所以视图不会立即更新,会等到下一次dom更新循环结束后统一更新发生在这一次循环中修改的数据,然后同步视图更新,所以我们可以修改后自己手动强制更新视图。</p><p>解决方法4：Object.assign(使用修改栈能触发视图更新的特性)</p><p>我们都知道Object.assign能拷贝合成一个新对象,所以我们只需要将要修改的值合并成一个新对象然后赋值给data中的对象或数组,这样栈的指向被修改了，触发视图更新</p><p>解决方法5:对于数组还可以使用splice方法</p><p>(Vue对于数组的操作能识别变化的方法包括push(), pop(), shift(), unshift(), splice(), sort(), reverse()这些都可被vue监测到)</p><p>​                                 </p><h2 id="vue中的data为什么是一个函数？（面试常问）"><a href="#vue中的data为什么是一个函数？（面试常问）" class="headerlink" title="vue中的data为什么是一个函数？（面试常问）"></a>vue中的data为什么是一个函数？（面试常问）</h2><p>Vue中的data必须是个函数，因为当data是函数时，组件实例化的时候这个函数将会被调用，返回一个对象，计算机会给这个对象分配一个内存地址，实例化几次就分配几个内存地址，他们的地址都不一样，所以每个组件中的数据不会相互干扰，改变其中一个组件的状态，其它组件不变。</p><p>简单来说，就是为了保证组件的独立性和可复用性，如果data是个函数的话，每复用一次组件就会返回新的data，类似于给每个组件实例创建一个私有的数据空间，保护各自的数据互不影响</p><h2 id="Vuex是什么，每个属性是干嘛的"><a href="#Vuex是什么，每个属性是干嘛的" class="headerlink" title="Vuex是什么，每个属性是干嘛的"></a>Vuex是什么，每个属性是干嘛的</h2><p>定义：专门为Vue.js应用程序开发的状态管理模式，它采用集中式存储管理数据，以相应的规则保证状态，以一种可预测的方式发生变化。</p><p>vuex各个属性概念：（Vuex是集中管理项目公共数据的）</p><p>为什么要学？</p><p>非父子组件之间的通信</p><p>数据同步、集中管理、数据有迹可循、数据状态可追踪</p><p>Vuex中存的什么？</p><p>多个组件共享状态</p><p>Vue属性：</p><p>state属性：用来存储公共管理的数据。 </p><p>mutations 属性：定义改变state中数据的方法，注意:不要在mutation中的方法中写异步方法ajax，那样数据就不可跟踪了。</p><p>getters 属性：定义 store 的计算属性。就像计算属性一样，getter的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 </p><p>actions属性：类似于mutations，不同点：Actions提交的是mutations，而不是直接变更状态。actions可以包含任意异步操作。</p><p>moudle属性：将store分割成模块。每个模块拥有自己的state、mutation、action、getter、甚至是嵌套子模块从上至下进行同样方式的分割。</p><p>直接使用方法: </p><p>state：直接以对象方式添加属性this.$store.state.变量名</p><p>mutations：通过this.$store.commit(“mutations里函数名”, 具体值)调用</p><p>actions：通过this.$store.dispatch(“actions里函数名”)触发</p><p>getters：直接通过this.$store.getters.计算属性名调用</p><p>映射使用方法：</p><p>state: …mapState(“state里变量名”), 写在computed里面, 原地留下一个计算属性</p><p>mutations: …mapMutations([“mutations里函数名”]), 写在methods里面，原地留下一个方法</p><p>actions: …mapAction([“actions里函数名”]), 写在methods里面，原地留下一个方法</p><p>getters: …mapGetters([“变量名”]), 写在computed里面, 原地留下一个计算属性</p><h2 id="生命周期-袋鼠云笔试"><a href="#生命周期-袋鼠云笔试" class="headerlink" title="生命周期(袋鼠云笔试)"></a>生命周期(袋鼠云笔试)</h2><h3 id="beforeCreate（创建前）"><a href="#beforeCreate（创建前）" class="headerlink" title="beforeCreate（创建前）"></a>beforeCreate（创建前）</h3><p>这个时候，在实例被完成创建出来，el和data都没有初始化，不能访问data、method，一般在这个阶段不进行操作。</p><h3 id="created（创建后）"><a href="#created（创建后）" class="headerlink" title="created（创建后）"></a>created（创建后）</h3><p>这个时候，vue实例中的data、method已被初始化，属性也被绑定，但是此时还是虚拟dom，真实dom还没生成，$el还不可用。这个时候可以调用data和method的数据及方法，created钩子函数是最早可以调用data和method的，故一般在此对数据进行初始化。</p><h3 id="beforeMount（挂载前）"><a href="#beforeMount（挂载前）" class="headerlink" title="beforeMount（挂载前）"></a>beforeMount（挂载前）</h3><p>此时模板已经编译完成，但还没有被渲染至页面中（即为虚拟dom加载为真实dom），此时el存在则会显示el。在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取。</p><p>当vue实例中，el为挂载目标，未对el进行定义，则this.el显示undefined，但页面中存在template也能识别挂载目标，因为template可以被看成占位符。如果对其进行定义则显示<div id="app"></div>，故所以，beforeMount读取不了真实的el，在mounted才能读取到真实的el，因为el只有渲染完成后才会存在。这里讲的el是真实的el。在真实的el之前存在前，在beforeMount中的其实是页面中的#app，是挂载的目标。</p><h3 id="mounted（挂载后）"><a href="#mounted（挂载后）" class="headerlink" title="mounted（挂载后）"></a>mounted（挂载后）</h3><p>此时模板已经被渲染成真实DOM，用户已经可以看到渲染完成的页面，页面的数据也是通过双向绑定显示data中的数据。 这实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时，如果没有其它操作的话，这个实例，就静静的躺在我们的内存中，一动不动。</p><h3 id="beforeUpdate（更新前）"><a href="#beforeUpdate（更新前）" class="headerlink" title="beforeUpdate（更新前）"></a>beforeUpdate（更新前）</h3><p>更新前状态（view层的数据变化前，不是data中的数据改变前），重新渲染之前触发，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染。只有view上面的数据变化才会触发beforeUpdate和updated，仅属于data中的数据改变是并不能触发。</p><h3 id="updated（更新后）"><a href="#updated（更新后）" class="headerlink" title="updated（更新后）"></a>updated（更新后）</h3><p>数据已经更改完成，dom也重新render完成。</p><h3 id="beforeDestroy（销毁前）"><a href="#beforeDestroy（销毁前）" class="headerlink" title="beforeDestroy（销毁前）"></a>beforeDestroy（销毁前）</h3><p>销毁前执行（$destroy方法被调用的时候就会执行）,一般在这里善后:清除计时器、清除非指令绑定的事件等等…’)</p><h3 id="destroyed（销毁后）"><a href="#destroyed（销毁后）" class="headerlink" title="destroyed（销毁后）"></a>destroyed（销毁后）</h3><p>销毁后(Dom元素存在，只是不再受vue控制), 卸载watcher，事件监听，子组件</p><h2 id="v-if和v-show的区别"><a href="#v-if和v-show的区别" class="headerlink" title="v-if和v-show的区别"></a>v-if和v-show的区别</h2><p>v-if是通过添加和删除元素来进行显示或者隐藏</p><p>v-show是通过操作DOM修改display样式来修改元素的显示和隐藏</p><p>如果需要频繁的进行元素的显示和隐藏使用v-show性能更好</p><h2 id="scoped相关知识"><a href="#scoped相关知识" class="headerlink" title="scoped相关知识"></a>scoped相关知识</h2><p>scoped属性作用：让style里的选择器，只能选中当前组件的标签（为了保证样式的独立性，不影响别的组件）或者vue组件中，在style标签上添加scoped属性，表示它的样式只对当前组件生效，不会影响全局的样式，很好的实现了样式私有化的目的。</p><p>scoped原理：webpack打包的时候，会给组件标签上添加相同data-v-hash值，然后也会给所有选择器后面加上一个[data-v-hash]值的属性选择器（即：多加了一个data-v的属性选择器）</p><p>也就是比如：&lt;标签 data-v-822711 class&#x3D;”my_a”&gt;&lt;&#x2F;标签&gt;</p><p>运行时选择器会变成 .my_a[data-v-822711]</p><p>重要注意事项：scoped只会给当前组件所有原生标签添加data-v-hash值属性，还会给组件标签内根标签添加data-v-hash值属性，组件内的标签不会添加</p><p>一、为什么需要穿透scoped？</p><p>引用了第三方组件后，需要在组件中局部修改第三方组件的样式，而又不想去除scoped属性造成组件之间的样式污染。此时只能通过特殊的方式，穿透scoped。</p><p>二、样式穿透的方法</p><p>样式穿透的写法有三种：&gt;&gt;&gt;、&#x2F;deep&#x2F;、::v-deep</p><p>1、&gt;&gt;&gt;</p><p>如果项目使用的是css原生样式，那么可以直接使用 &gt;&gt;&gt; 穿透修改</p><p>2、&#x2F;deep&#x2F;</p><p>项目中用到了预处理器 scss 、sass、less 操作符 &gt;&gt;&gt; 可能会因为无法编译而报错 。可以使用 &#x2F;deep&#x2F;</p><p>注意：vue-cli3以上版本不可以</p><p>3、::v-deep</p><h2 id="v-for更新监测"><a href="#v-for更新监测" class="headerlink" title="v-for更新监测"></a>v-for更新监测</h2><p>真实dom和虚拟dom</p><p>真实DOM就是在document对象上面渲染到浏览器上显示的标签</p><p>虚拟DOM本质是保存节点信息，属性和内容的一个JS对象。</p><p>虚拟DOM更新时会在内存中比较变化部分，然后给真实DOM打补丁</p><p>diff算法</p><p>虚拟DOM中采用的算法，把树形结构按照层级分解，只比较同级元素，不同层级的节点只有创建和删除操作。</p><p>diff算法采用同级比较，如果根元素变化直接删除重新建立整个的DOM树，如果根元素没变，DOM复用，只更新属性</p><p>v-for中key的作用</p><p>无key时会最大限度尝试就地修改&#x2F;复用相同类型元素</p><p>有key，值为索引时，先产生新旧虚拟DOM，然后根据key比较，还是就地更新</p><p>有key，值为唯一不重复的字符串或数字时，先产生新旧虚拟DOM，然后根据key比较</p><p>​        </p><h2 id="打包后dist目录过大，解决办法？"><a href="#打包后dist目录过大，解决办法？" class="headerlink" title="打包后dist目录过大，解决办法？"></a>打包后dist目录过大，解决办法？</h2><p>1.dist打包生成的文件中有.map文件，可以删除。在vue.config.js文件中配置：productionSourceMap: false</p><p>2.组件和路由使用懒加载、按需引入等</p><p>3.对于文件和图片进行压缩。安装压缩组件：compression-webpack-plugin</p><p>安装后进行导入配置：</p><p>最小化代码minisize:true</p><p>分割代码：splitChunksl</p><p>超过限定值的文件进行压缩，threshold:文件大小（字节为单位）</p><h2 id="watch和computed的区别"><a href="#watch和computed的区别" class="headerlink" title="watch和computed的区别"></a>watch和computed的区别</h2><p>computed：计算属性，它具有缓存特性。</p><p>watch：侦听器，是Vue实例的一个属性，是用来响应数据的变化，需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。它可以监控一个变量，也可以是一个对象，一般用于监控路由、input输入框的值特殊处理等等，适用场景是一个数据影响多个数据，它不具有缓存性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-attr">computed</span>: &#123;<br>    计算属性名: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> xxx<br>    &#125;<br>  &#125;<br><span class="hljs-attr">watch</span>:&#123;<br>    被监听的数据:&#123;<br>        <span class="hljs-title function_">handler</span>(<span class="hljs-params">数据改变后的新值, 数据改变前的旧值</span>)&#123;<br>            逻辑代码<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>区别：</p><ul><li><p>功能上：computed是计算属性，watch是监听一个值的变化，然后执行对应的回调。</p></li><li><p>是否调用缓存：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调。</p></li><li><p>是否调用return：computed中的函数必须要用return返回，watch中的函数不是必须要用return。</p></li><li><p>computed默认第一次加载的时候就开始监听；watch默认第一次加载不做监听，如果需要第一次加载做监听，添加immediate属性，设置为true（immediate:true）</p></li></ul><h2 id="vue组件之间的数据传递"><a href="#vue组件之间的数据传递" class="headerlink" title="vue组件之间的数据传递"></a>vue组件之间的数据传递</h2><h3 id="父组件给子组件传递数据"><a href="#父组件给子组件传递数据" class="headerlink" title="父组件给子组件传递数据"></a>父组件给子组件传递数据</h3><p>通过给父组件身上绑定自定义属性，然后在子组件里使用props属性来接收即可 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 父组件：<br>&lt;Son :msg=&quot;message&quot;&gt;&lt;/Son&gt;<br>&lt;script&gt;<br>export default&#123;<br>    data()&#123;<br>        return &#123; message:&#x27;hello vuejs&#x27; &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br><br>// 子组件<br>&lt;template&gt;<br>&lt;div&gt;<br>        &lt;p&gt;父组件传递过来的msg值是：&#123;&#123; msg &#125;&#125;&lt;/p&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default&#123;<br>&lt;script&gt;<br>export default&#123;<br>    props: [&#x27;msg&#x27;]<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="子组件给父组件传递数据"><a href="#子组件给父组件传递数据" class="headerlink" title="子组件给父组件传递数据"></a>子组件给父组件传递数据</h3><p>通过父组件给子组件绑定一个自定义事件实现：子组件通过this.$emit给父组件传递数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 子组件<br>&lt;script&gt;<br>export default&#123;<br>    data()&#123;<br>        return &#123; count: 0 &#125;<br>    &#125;,<br>    methods:&#123;<br>        add()&#123;<br>            this.count += 1<br>            this.$emit(&#x27;numChangeEV&#x27;,this.count)<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br>// 父组件<br>&lt;Son @numChangeEV=&quot;getNewCount&quot;&gt;&lt;/Son&gt;<br><br>&lt;script&gt;<br>export default&#123;<br>    data()&#123;<br>        return &#123; countFromSon: 0 &#125;<br>    &#125;,<br>    methods:&#123;<br>        getNewCount()&#123;<br>            this,countFromSon = val<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="子组件需要调用父组件的方法"><a href="#子组件需要调用父组件的方法" class="headerlink" title="子组件需要调用父组件的方法"></a>子组件需要调用父组件的方法</h3><p>1.父组件中把方法作为属性传入子组件，在子组件里直接调用这个方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 父组件中<br>&lt;Son :setBillDetailEV=&quot;setBillDetail&quot;&gt;&lt;/Son&gt;<br><br>// 子组件中<br>&lt;span @click=&quot;setBillDetail(null)&quot;&gt;返回&lt;/span&gt;<br>&lt;script&gt;<br>export default&#123;<br>    props:&#123;<br>        setBillDetail:&#123;<br>            type: Function,<br>            default: null<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>2.直接在子组件中通过this.$parent.event来调用父组件的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 父组件中<br>&lt;Son :setBillDetailEV=&quot;setBillDetail&quot;&gt;&lt;/Son&gt;<br>&lt;script&gt;<br>export default&#123;<br>    methods:&#123;<br>        setBillDetail()&#123;&#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br>// 子组件中<br>&lt;span @click=&quot;setBill&quot;&gt;返回&lt;/span&gt;<br>&lt;script&gt;<br>export default&#123;<br>    methods:&#123;<br>        setBill()&#123;<br>            this.$parent.setBillDetail()<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>3.在子组件里用$emit向父组件触发一个事件，父组件监听这个事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 父组件中<br>&lt;Son :setBillDetailEV=&quot;setBillDetail&quot;&gt;&lt;/Son&gt;<br>&lt;script&gt;<br>export default&#123;<br>    methods:&#123;<br>        setBillDetail()&#123;&#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br>// 子组件中<br>&lt;span @click=&quot;setBill&quot;&gt;返回&lt;/span&gt;<br>&lt;script&gt;<br>export default&#123;<br>    methods:&#123;<br>        setBill()&#123;<br>            this.$emit(&#x27;setBillDetailEV&#x27;)<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="父组件调用子组件方法"><a href="#父组件调用子组件方法" class="headerlink" title="父组件调用子组件方法"></a>父组件调用子组件方法</h3><h4 id="emit、-on方式"><a href="#emit、-on方式" class="headerlink" title="$emit、$on方式"></a>$emit、$on方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 父组件中<br>&lt;template&gt;<br>&lt;div&gt;<br>        &lt;button @click=&quot;handleClick&quot;&gt;点击调用子组件方法&lt;/button&gt;<br>    &lt;Child ref=&quot;child&quot;&gt;&lt;/Child&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default&#123;<br>    methods:&#123;<br>        handleClick()&#123;<br>            this.$ref.child.$emit(&#x27;childmethods&#x27;)<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br><br>// 子组件中<br>&lt;template&gt;<br>&lt;div&gt;我是子组件&lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default&#123;<br>    mounted:&#123;<br>        this.$nextTick(function()&#123;<br>    this.$on(&#x27;childmethods&#x27;,function()&#123;<br>        console.log(&#x27;我是子组件方法&#x27;)<br>    &#125;)<br>&#125;)<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="通过ref直接调用子组件方法"><a href="#通过ref直接调用子组件方法" class="headerlink" title="通过ref直接调用子组件方法"></a>通过ref直接调用子组件方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 父组件中<br>&lt;template&gt;<br>&lt;div&gt;<br>        &lt;button @click=&quot;handleClick&quot;&gt;点击调用子组件方法&lt;/button&gt;<br>    &lt;Child ref=&quot;child&quot;&gt;&lt;/Child&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default&#123;<br>    methods:&#123;<br>        handleClick()&#123;<br>            this.$ref.child.sing()<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br><br>// 子组件中<br>&lt;template&gt;<br>&lt;div&gt;我是子组件&lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default&#123;<br>    methods:&#123;<br>        sing()&#123;<br>            console.log(&#x27;唱歌&#x27;)<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="管理准备（项目代码版本管理工具：git-svn）"><a href="#管理准备（项目代码版本管理工具：git-svn）" class="headerlink" title="管理准备（项目代码版本管理工具：git&#x2F;svn）"></a>管理准备（项目代码版本管理工具：git&#x2F;svn）</h2><h3 id="问题1：新旧项目，确保有什么文件夹？"><a href="#问题1：新旧项目，确保有什么文件夹？" class="headerlink" title="问题1：新旧项目，确保有什么文件夹？"></a>问题1：新旧项目，确保有什么文件夹？</h3><ol><li>项目文件夹下，有隐藏.git文件夹（它里面记录了你所有的版本提交，远程仓库相关配置）如果没有则运行git init命令，初始化一个</li><li>别人的&#x2F;克隆的项目，我们需要git init吗？不需要，因为项目已经拥有了git本地仓库</li></ol><h3 id="拿到项目"><a href="#拿到项目" class="headerlink" title="拿到项目"></a>拿到项目</h3><h4 id="问题2：如果旧项目（进公司第一件事）如何得到别人的项目代码？"><a href="#问题2：如果旧项目（进公司第一件事）如何得到别人的项目代码？" class="headerlink" title="问题2：如果旧项目（进公司第一件事）如何得到别人的项目代码？"></a>问题2：如果旧项目（进公司第一件事）如何得到别人的项目代码？</h4><ol><li><p>先知道git远程仓库的地址</p></li><li><p>本机创建空白的文件夹，敲击如下命令，第一次克隆</p><p>git clone 远程仓库git地址</p></li></ol><h4 id="问题3：克隆命令是做什么的呢？"><a href="#问题3：克隆命令是做什么的呢？" class="headerlink" title="问题3：克隆命令是做什么的呢？"></a>问题3：克隆命令是做什么的呢？</h4><p>把远程仓库git地址位置对应的代码＋它里面所有之前提交记录，都下载到本地</p><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ol><li><p>https开头的地址，如果是公开的仓库，可以直接克隆</p></li><li><p>https开头的地址，如果是私有的仓库，你必须要在git仓库网站注册账号，让管理员拉你进组，才能克隆</p></li><li><p>git@开头的地址，如果是公开的仓库，你必须要在git仓库网站注册账号，并把本机电脑和远程网站账号配置ssh密钥，才能克隆</p></li><li><p>git@开头的地址，如果是私有的仓库，你必须要在git仓库网站注册账号，并把本机电脑和远程网站账号配置ssh密钥，并且还要让管理员拉你进组，才能克隆</p></li></ol><h4 id="问题4：如果远程仓库有更新，如何拿到更新以后的内容到本地？"><a href="#问题4：如果远程仓库有更新，如何拿到更新以后的内容到本地？" class="headerlink" title="问题4：如果远程仓库有更新，如何拿到更新以后的内容到本地？"></a>问题4：如果远程仓库有更新，如何拿到更新以后的内容到本地？</h4><ol><li><p>如果本地无变更：git pull</p></li><li><p>如果本地有变更：</p><ol><li><code>git add .</code>  ：<strong>将工作区更改过的文件提交到暂存区</strong></li><li><code>git commit -m &quot;提交提示信息&quot;</code>：<strong>将暂存区内容添加到本地仓库</strong>。Ps:提交一次就会在本地git仓库里出现一次提交保存的记录（本时间节点的代码记录一次快照）。</li><li><code>git pull</code>  Ps: git pull以后会把远程更新和本地的更新合并到一个项目内，所以冲突很可能发生在这个命令后</li></ol></li></ol><h3 id="推送项目"><a href="#推送项目" class="headerlink" title="推送项目"></a>推送项目</h3><h4 id="问题6：本地git记录有很多次，一次性保存到远程仓库上？"><a href="#问题6：本地git记录有很多次，一次性保存到远程仓库上？" class="headerlink" title="问题6：本地git记录有很多次，一次性保存到远程仓库上？"></a>问题6：本地git记录有很多次，一次性保存到远程仓库上？</h4><ol><li><p>本地仓库第一次新建的，无远程仓库配置：</p><ol><li><p>git remote add origin 远程仓库git地址</p></li><li><p>git push -u origin master（即把本地master主分支所有提交记录，推送到远程仓库的master主分支上；-u配置一条通道以后直接本地在master分支时，可以直接git push）</p></li></ol></li><li><p>之前本地仓库已经配置好了，远程仓库的地址：git push</p></li></ol><h2 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">git init 初始化git仓库(mac中<span class="hljs-title class_">Command</span>+<span class="hljs-title class_">Shift</span>+.可以显示隐藏文件)<br>git remote add origin 远程仓库git地址<br>git status 查看文件状态<br>git add 文件列表 追踪文件<br>git commit -m 提交信息 向仓库中提交代码<br>git log 查看提交记录<br>git push -u origin master（即把本地master主分支所有提交记录，推送到远程仓库的master主分支上；-u配置一条通道,以后直接本地在master分支时，可以直接git push）<br></code></pre></td></tr></table></figure><h3 id="1-分支明细"><a href="#1-分支明细" class="headerlink" title="1.分支明细"></a>1.分支明细</h3><p>（1）主分支（master）：第一次向git仓库中提交更新记录时自动产生一个分支。</p><p>（2）开发分支（develop）：作为开发的分支，基于master分支创建。</p><p>（3）功能分支（feature）：作为开发具体功能的分支，基于开发分支创建</p><h3 id="2-分支命令"><a href="#2-分支命令" class="headerlink" title="2.分支命令"></a>2.分支命令</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">git branch查看分支<br>git branch分支名称 创建分支<br>git checkout分支名称 切换分支<br>git merge来源分支 合并分支(备注：必须在master分支上才能合并develop分支)<br>git branch -d分支名称删除分支（分支被合并后才允许删除）（-D强制删除）<br></code></pre></td></tr></table></figure><h3 id="3-暂时保存更改"><a href="#3-暂时保存更改" class="headerlink" title="3.暂时保存更改"></a>3.暂时保存更改</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">存储临时改动：git stash<br>恢复改动：git stash pop<br></code></pre></td></tr></table></figure><h2 id="Vue修饰符"><a href="#Vue修饰符" class="headerlink" title="Vue修饰符"></a>Vue修饰符</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">stop：阻止事件冒泡，顺序是执行顺序是div&gt;body&gt;<span class="hljs-variable language_">document</span>，<br>js默认开启事件冒泡。e.<span class="hljs-title function_">stopPropagation</span>()、e.<span class="hljs-title function_">stopImmediatePropagation</span>() 阻止改dom所有该类型事件的冒泡。<br><br>self：阻止事件冒泡&amp;&amp;阻止事件捕获,div&gt;body&gt;<span class="hljs-variable language_">document</span>,<span class="hljs-variable language_">document</span>&gt;body&gt;div,默认是冒泡。<br><br>capture：开启事件捕获，写在需要捕获的元素上，他会捕获内部元素的同类型事件 <span class="hljs-variable language_">document</span>&gt;body&gt;div <br><span class="hljs-comment">// 默认关闭事件捕获，开启事件冒泡。addEventListener(&quot;click&quot;, this.Parent, &#123;capture:true&#125;); capture，true开启，反之关闭</span><br><br>once：事件只触发一次就会被移除。<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">Parent</span>, &#123;<span class="hljs-attr">once</span>:<span class="hljs-literal">true</span>&#125;); once，<span class="hljs-literal">true</span>开启，反之关闭<br><br>prevent： 阻止事件的默认行为 e.<span class="hljs-title function_">preventDefault</span>() e.<span class="hljs-property">defaultPrevented</span> 查看默认阻止的状态，<span class="hljs-literal">true</span>：已阻止。<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">Parent</span>, &#123;<span class="hljs-attr">passive</span>:<span class="hljs-literal">true</span>&#125;); passive，<span class="hljs-literal">true</span>：阻止preventDefault函数调用，反之不阻止<br><br>native：事件直接绑定到组件的原生节点上，&lt;el-input @click.<span class="hljs-property">native</span>/&gt; click事件直接绑定在input元素上。<br><br>lazy： vue v-model 修饰符。修改语法糖的input事件为change。<br><br>number： vue 修饰符。把值转换为number类型。<br><br>trim： vue修饰符。去除数值前后空格。 <br></code></pre></td></tr></table></figure><h2 id="this-nextTick"><a href="#this-nextTick" class="headerlink" title="this.$nextTick()"></a>this.$nextTick()</h2><p>定义：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p><p>所以就衍生出了这个获取更新后的DOM的Vue方法。所以放在Vue.nextTick()回调函数中的执行的应该是会对DOM进行操作的 js代码；</p><p>理解：nextTick()，是将回调函数延迟在下一次dom更新数据后调用，简单的理解是：当数据更新了，在dom中渲染后，自动执行该函数</p><h3 id="使用原理："><a href="#使用原理：" class="headerlink" title="使用原理："></a>使用原理：</h3><p>Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要计算和DOM操作。而在下一个事件循环时，Vue会清空队列，并进行DOM更新。</p><p>当你设置 改变了一个新数据data，DOM 并不会马上更新，而是在异步队列被清空，也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中，原因是在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的DOM挂载已完成。</p><p>当项目中你想在改变DOM元素的数据后基于新的dom做点什么，对新DOM一系列的js操作都需要放进Vue.nextTick()的回调函数中；通俗的理解是：更改数据后当你想立即使用js操作新的视图的时候需要使用它</p><h2 id="route和-router"><a href="#route和-router" class="headerlink" title="$route和$router"></a>$route和$router</h2><h3 id="route"><a href="#route" class="headerlink" title="$route"></a>$route</h3><p>$route对象表示当前的路由信息，包含了当前 URL 解析得到的信息。包含当前的路径，参数，query对象等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">$route.<span class="hljs-property">path</span> 字符串，对应当前路由的路径，总是解析为绝对路径，如<span class="hljs-string">&quot;/foo/bar&quot;</span>。<br>$route.<span class="hljs-property">params</span> 一个 key/value 对象，包含了 动态片段 和 全匹配片段，如果没有路由参数，就是一个空对象。<br>$route.<span class="hljs-property">query</span>一个 key/value 对象，表示 <span class="hljs-variable constant_">URL</span> 查询参数。例如，对于路径 /foo?user=<span class="hljs-number">1</span>，则有$route.<span class="hljs-property">query</span>.<span class="hljs-property">user</span> == <span class="hljs-number">1</span>，如果没有查询参数，则是个空对象。<br>$route.<span class="hljs-property">hash</span> 当前路由的hash值(不带#) ，如果没有 hash 值，则为空字符串。锚点*<br>$route.<span class="hljs-property">fullPath</span> 完成解析后的 <span class="hljs-variable constant_">URL</span>，包含查询参数和hash的完整路径。<br>$route.<span class="hljs-property">matched</span> 数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。<br>$route.<span class="hljs-property">name</span> 当前路径名字<br>$route.<span class="hljs-property">meta</span> 路由元信息<br></code></pre></td></tr></table></figure><h3 id="router"><a href="#router" class="headerlink" title="$router"></a>$router</h3><p>$router对象是全局路由的实例，是router构造方法的实例。有push、go、replace方法实现路由跳转。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">导航钩子的参数：<br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span>, next</span>)=&gt;</span>&#123;<span class="hljs-comment">//to 和from都是 路由信息对象,后面使用路由的钩子函数就容易理解了&#125;)</span><br></code></pre></td></tr></table></figure><h2 id="Vue中hash和history的区别"><a href="#Vue中hash和history的区别" class="headerlink" title="Vue中hash和history的区别"></a>Vue中hash和history的区别</h2><ul><li>hash路由在地址栏URL上有#，用<code>window.location.hash</code> 读取。而history路由没有会好看一点</li><li>我们进行回车刷新操作，hash路由会加载到地址栏对应的页面，而history路由一般就404报错了（刷新是网络请求，没有后端准备时会报错）。</li><li>hash路由支持低版本的浏览器IE8，而history路由是HTML5新增的API，只能兼容到IE10。</li><li>hash的特点在于它虽然出现在了URL中，但是不包括在http请求中，所以对于后端是没有一点影响的，所以改变hash不会重新加载页面，所以这也是单页面应用的必备。</li><li>history运用了浏览器的历史记录栈，之前有back, forward, go方法，之后在HTML5中新增了pushState()和replaceState()方法，它们提供了对历史记录进行修改的功能，不过在进行修改时，虽然改变了当前的URL，但是浏览器不会马上向后端发送请求。</li><li>history的这种模式需要后台配置支持。比如：当我们进行项目的主页的时候，一切正常，可以访问，但是当我们刷新页面或者直接访问路径的时候就会返回404，那是因为在history模式下，只是动态的通过js操作window.history来改变浏览器地址栏里的路径，并没有发起http请求，但是当我直接在浏览器里输入这个地址的时候，就一定要对服务器发起http请求，但是这个目标在服务器上又不存在，所以会返回404</li><li>原理不同<ul><li>hash：通过监听浏览器的onhashchange()事件变化，查找对应的路由规则</li><li>history： 利用H5的 history中新增的两个API pushState() 和 replaceState() 和一个事件onpopstate监听URL变化</li></ul></li></ul><h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><p>大部分情况下应该遵循<strong>单向数据流</strong>原则，禁止子组件直接修改props，否则复杂环境下的数据流将变得混乱，极易出现bug且难排查</p><h2 id="Vue中父子组件生命周期"><a href="#Vue中父子组件生命周期" class="headerlink" title="Vue中父子组件生命周期"></a>Vue中父子组件生命周期</h2><p>父子组件的生命周期是一个嵌套的过程<br>渲染的过程<br><code>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</code><br>子组件更新过程<br><code>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</code><br>父组件更新过程<br><code>父beforeUpdate-&gt;父updated</code><br>销毁过程<br><code>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</code></p><h1 id="Vue面试题"><a href="#Vue面试题" class="headerlink" title="Vue面试题"></a>Vue面试题</h1><h2 id="vue中keep-alive组件的作用"><a href="#vue中keep-alive组件的作用" class="headerlink" title="vue中keep-alive组件的作用"></a>vue中keep-alive组件的作用</h2><p>keep-alive：主要是用于保留组件状态和避免组件重新渲染。</p><p>其是一个抽象组件（或称为功能性组件），实际上不会被渲染在DOM树中。它的作用是在内存中缓存组件（不让组件销毁），等到下次在渲染的时候，还会保持其中的所有状态，并且会触发 activated钩子函数。</p><p>属性：（属性表示要缓存的组件名，即组件定义时的name属性）</p><ul><li>include：字符串或正则表达式，只有匹配的组件会被缓存</li><li>exclude：字符串或正则表达式，任何匹配的组件都不会被缓存</li></ul><p>被包含在 keep-alive中创建的组件，会多出两个生命周期的钩子： activated与 decativated。</p><ul><li>activated：在组件被激活时调用，在组件第一次渲染时也会被调用，之后每次 keep-alive激活时被调用</li><li>decativated：在组件被停用时调用。</li></ul><p>注意：只有组件被 keep-alive 包裹时，这两个生命周期才会被调用，如果作为正常组件使用，是不会被调用，以及在 2.1.0 版本之后，使用 exclude 排除之后，就算被包裹在 keep-alive中，这两个钩子依然不会被调用！另外在服务端渲染时此钩子也不会被调用的。</p><p>在App.vue中修改为如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;keep-alive&gt;<br>    &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;<br>&lt;/keep-alive&gt;<br><br>&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;<br></code></pre></td></tr></table></figure><p>在router&#x2F;index.js中为每一个路由添加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">meta</span>:&#123;<br>    <span class="hljs-attr">keepAlive</span>:<span class="hljs-literal">true</span>/<span class="hljs-literal">false</span> <span class="hljs-comment">//true代表这个页面（组件）需要缓存，false代表不需要</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实际应用：（下面的写法是将组件在内存中进行缓存）"><a href="#实际应用：（下面的写法是将组件在内存中进行缓存）" class="headerlink" title="实际应用：（下面的写法是将组件在内存中进行缓存）"></a>实际应用：（下面的写法是将组件在内存中进行缓存）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 基本 --&gt;<br>&lt;keep-alive&gt;<br>    &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;<br>&lt;/keep-alive&gt;<br><br>&lt;!-- 多个条件判断的子组件 --&gt;<br>&lt;keep-alive&gt;<br>    &lt;comp-a v-if=&quot;a &gt; 1&quot;&gt;&lt;/comp-a&gt;<br>    &lt;comp-b v-else&gt;&lt;/comp-b&gt;<br>&lt;/keep-alive&gt;<br><br>&lt;!-- 和 `&lt;transition&gt;` 一起使用 --&gt;<br>&lt;transition&gt;<br>    &lt;keep-alive&gt;<br>        &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;<br>    &lt;/keep-alive&gt;<br>&lt;/transition&gt;<br></code></pre></td></tr></table></figure><p>注意：<code>&lt;keep-alive&gt;</code>是用在其一个直属的子组件被开关的情形。如果你在其中有 v-for 则不会工作。如果有上述的多个条件性的子元素，<code>&lt;keep-alive&gt; </code>要求同时只有一个子元素被渲染。</p><h3 id="include-和-exclude-属性的使用"><a href="#include-和-exclude-属性的使用" class="headerlink" title="include 和 exclude 属性的使用"></a>include 和 exclude 属性的使用</h3><p>include 和 exclude 属性允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">  &lt;!-- 逗号分隔字符串 --&gt;<br>&lt;keep-alive include=&quot;a,b&quot;&gt;<br>    &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;<br>&lt;/keep-alive&gt;<br><br><br>&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;<br>&lt;keep-alive :include=&quot;/a|b/&quot;&gt;<br>    &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;<br>&lt;/keep-alive&gt;<br><br><br>&lt;!-- 数组 (使用 `v-bind`) --&gt;<br>&lt;keep-alive :include=&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;&gt;<br>    &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;<br>&lt;/keep-alive&gt;<br></code></pre></td></tr></table></figure><p>匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件components 选项的键值)。匿名组件不能被匹配。 不会在函数式组件中正常工作，因为它们没有缓存实例。</p><h2 id="Vue中如何编写可复用的组件"><a href="#Vue中如何编写可复用的组件" class="headerlink" title="Vue中如何编写可复用的组件"></a>Vue中如何编写可复用的组件</h2><p>在编写组件的时候，时刻考虑组件是否可复用是有好处的。一次性组件跟其他组件紧密耦合没关系，但是可复用组件一定要定义一个清晰的公开接口。</p><p>Vue.js组件 API 来自 三部分：prop、事件、slot：</p><ul><li>prop 允许外部环境传递数据给组件，在vue-cli工程中也可以使用vuex等传递数据。</li><li>事件允许组件触发外部环境的 action。</li><li>slot 允许外部环境将内容插入到组件的视图结构内。</li></ul><h2 id="如何解决非工程化项目，网速慢时初始化页面闪动问题"><a href="#如何解决非工程化项目，网速慢时初始化页面闪动问题" class="headerlink" title="如何解决非工程化项目，网速慢时初始化页面闪动问题"></a>如何解决非工程化项目，网速慢时初始化页面闪动问题</h2><p>使用 v-cloak指令，v-cloak不需要表达式，它会在Vue实例结束编译时从绑定的HTML元素上移除，经常和CSS的display:none配合使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div id=&quot;app&quot; v-cloak&gt;<br>    &#123;&#123;message&#125;&#125;<br>&lt;/div&gt;<br>&lt;script&gt;<br>var app = new Vue(&#123;<br>    el:&quot;#app&quot;,<br>    data:&#123;<br>        message:&quot;这是一段文本&quot;<br>    &#125;<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>这时虽然已经加了指令v-cloak，但其实并没有起到任何作用，当网速较慢、Vue.js 文件还没加载完时，在页面上会显示的字样，直到Vue创建实例、编译模版时，DOM才会被替换，所以这个过程屏幕是有闪动的。只要加一句CSS就可以解决这个问题了：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;!--属性选择器--&gt;<br><span class="hljs-selector-attr">[v-cloak]</span>&#123;<br>    <span class="hljs-attribute">display</span>:none;<br>&#125;<br></code></pre></td></tr></table></figure><p>在一般情况下，v-cloak是一个解决初始化慢导致页面闪动的最佳实践，对于简单的项目很实用。</p><h2 id="组件之间双向绑定"><a href="#组件之间双向绑定" class="headerlink" title="组件之间双向绑定"></a>组件之间双向绑定</h2><p>大家都知道 Vue2 中组件的双向绑定采用的是 v-model 或 .snyc 修饰符，两种写法多少显得有点重复，于是在 Vue3 中合成了一种。Vue3 统一使用 v-model 进行处理，并且可以和多个数据进行绑定，如 v-model:foo、v-model:bar。</p><p>v-model 等价于 :model-value&#x3D;”someValue” 和 @update:model-value&#x3D;”someValue &#x3D; $event”。</p><p>v-model:foo 等价于 :foo&#x3D;”someValue” 和 @update:foo&#x3D;”someValue &#x3D; $event”</p><p>下面就是一个父子组件之间双向绑定的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 父组件 --&gt;<br>&lt;script setup&gt;<br>import ChildView from &#x27;./ChildView.vue&#x27;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const msg = ref(&#x27;hello vue3!&#x27;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;ChildView v-model=&quot;msg&quot; /&gt;<br>&lt;/template&gt;<br>&lt;!-- 子组件 --&gt;<br>&lt;script setup&gt;<br>defineProps([&#x27;modelValue&#x27;])<br>const emit = defineEmits([&#x27;update:modelValue&#x27;])<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;div @click=&quot;emit(&#x27;update:modelValue&#x27;, &#x27;hi vue3！&#x27;)&quot;&gt;&#123;&#123; modelValue &#125;&#125;&lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>子组件可以结合input使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 子组件 --&gt;<br>&lt;script setup&gt;<br>defineProps([&#x27;modelValue&#x27;])<br>const emit = defineEmits([&#x27;update:modelValue&#x27;])<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input :value=&quot;modelValue&quot; @input=&quot;emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot; /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>如果你觉得上面的模板比较繁琐，也可以结合 computed 一起使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 子组件 --&gt;<br>&lt;script setup&gt;<br>import &#123; computed &#125; from &#x27;vue&#x27;<br><br>const props = defineProps([&#x27;modelValue&#x27;])<br>const emit = defineEmits([&#x27;update:modelValue&#x27;])<br>const newValue = computed(&#123;<br>  get() &#123;<br>    return props.modelValue<br>  &#125;,<br>  set(value) &#123;<br>    emit(&#x27;update:modelValue&#x27;, value)<br>  &#125;<br>&#125;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input v-model=&quot;newValue&quot; /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h2 id="Scoped-CSS的原理"><a href="#Scoped-CSS的原理" class="headerlink" title="Scoped CSS的原理"></a>Scoped CSS的原理</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>先带大家看一下无设置<code>Scoped</code>与设置<code>Scoped</code>的区别在哪</p><p><strong>「无设置<code>Scoped</code>」</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;login&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.login</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span></span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>打包之后的结果是跟我们的代码一摸一样的，没有区别。</p><p><strong>「设置<code>Scoped</code>」</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;login&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.login</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span></span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>打包之后的结果是跟我们的代码就有所区别了。如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-v-257dda99b</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;login&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.login</span><span class="hljs-selector-attr">[data-v-257dda99b]</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span></span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们通过上面的例子，不难发现多了一个data-v-hash属性，也就是说加了scoped，PostCSS给一个组件中的所有dom添加了一个独一无二的动态属性，然后，给CSS选择器额外添加一个对应的属性选择器来选择该组件中dom，这种做法使得样式只作用于含有该属性的dom——组件内部dom，可以使得组件之间的样式不互相污染。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Vue的作用域样式 Scoped CSS 的实现思路如下：</p><ol><li>为每个组件实例（注意：是组件的实例，不是组件类）生成一个能唯一标识组件实例的标识符，我称它为组件实例标识，简称实例标识，记作 InstanceID；</li><li>给组件模板中的每一个标签对应的Dom元素（组件标签对应的Dom元素是该组件的根元素）添加一个标签属性，格式为 <code>data-v-实例标识</code>，示例：<code>&lt;div data-v-e0f690c0=&quot;&quot; &gt;</code>；</li><li>给组件的作用域样式 <code>&lt;style scoped&gt;</code> 的每一个选择器的最后一个选择器单元增加一个属性选择器 <code>原选择器[data-v-实例标识]</code> ，示例：假设原选择器为 <code>.cls #id &gt; div</code>，则更改后的选择器为 <code>.cls #id &gt; div[data-v-e0f690c0]</code>；</li></ol><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>将组件的样式的作用范围限制在了组件自身的标签，即：组件内部，包含子组件的根标签，但不包含子组件的除根标签之外的其它标签；所以 组件的css选择器也不能选择到子组件及后代组件的中的元素（子组件的根元素除外）；<ul><li>因为它给选择器的最后一个选择器单元增加了属性选择器 <code>[data-v-实例标识]</code> ，而该属性选择器只能选中当前组件模板中的标签；而对于子组件，只有根元素 即有 能代表子组件的标签属性 <code>data-v-子实例标识</code>，又有能代表当前组件（父组件）的 签属性 <code>data-v-父实例标识</code>，子组件的其它非根元素，仅有能代表子组件的标签属性 <code>data-v-子实例标识</code>；</li></ul></li><li>如果递归组件有后代选择器，则该选择器会打破特性1中所说的子组件限制，从而选中递归子组件的中元素；<ul><li>原因：假设递归组件A的作用域样式中有选择器有后代选择器 <code>div p</code> ，则在每次递归中都会为本次递归创建新的组件实例，同时也会为该实例生成对应的选择器 <code>div p[data-v-当前递归组件实例的实例标识]</code>，对于递归组件的除了第一个递归实例之外的所有递归实例来说，虽然 <code>div p[data-v-当前递归组件实例的实例标识]</code> 不会选中子组件实例（递归子组件的实例）中的 p 元素（具体原因已在特性1中讲解），但是它会选中当前组件实例中所有的 p 元素，因为 父组件实例（递归父组件的实例）中有匹配的 div 元素；</li></ul></li></ol><h3 id="、-deep-、-v-deep深度选择器的原理"><a href="#、-deep-、-v-deep深度选择器的原理" class="headerlink" title="&gt;&gt;&gt;、&#x2F;deep&#x2F;、::v-deep深度选择器的原理"></a>&gt;&gt;&gt;、&#x2F;deep&#x2F;、::v-deep深度选择器的原理</h3><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>实际开发中遇到的例子：当我们开发一个页面使用了子组件的时候，如果这时候需要改子组件的样式，但是又不影响其他页面使用这个子组件的样式的时候。比如：</p><p><strong>「父组件：Parent.vue」</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;parent&quot; id=&quot;app&quot;&gt;<br>    &lt;h1&gt;我是父组件&lt;/h1&gt;<br>    &lt;div class=&quot;gby&quot;&gt;<br>      &lt;p&gt;我是一个段落&lt;/p&gt;<br>    &lt;/div&gt;<br><br>    &lt;child&gt;&lt;/child&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>  .parent &#123;<br>    background-color: green;<br>  &#125;<br><br>  .gby p &#123;<br>    background-color: red;<br>  &#125;<br>  // 把子组件的背景变成红色，原组件不变<br>  .child .dyx p &#123;<br>    background-color: red;<br>  &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><strong>「子组件：Child.vue」</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div class=&quot;child&quot;&gt;<br>        &lt;h1&gt;我是子组件&lt;/h1&gt;<br>        &lt;div class=&quot;dyx&quot;&gt;<br>            &lt;p&gt;我是子组件的段落&lt;/p&gt;<br>        &lt;/div&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>    .child .dyx p &#123;<br>        background-color: blue;<br>    &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>这时候我们就会发现没有效果。但是如果我们使用<code>&gt;&gt;&gt;</code>、<code>/deep/</code>、<code>::v-deep</code>三个深度选择器其中一个就能实现了。看代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;parent&quot; id=&quot;app&quot;&gt;<br>    &lt;h1&gt;我是父组件&lt;/h1&gt;<br>    &lt;div class=&quot;gby&quot;&gt;<br>      &lt;p&gt;我是一个段落&lt;/p&gt;<br>    &lt;/div&gt;<br><br>    &lt;child&gt;&lt;/child&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>  .parent &#123;<br>    background-color: green;<br>  &#125;<br><br>  .gby p &#123;<br>    background-color: red;<br>  &#125;<br>  // 把子组件的背景变成红色，原组件不变<br>  ::v-deep .child .dyx p &#123;<br>    background-color: red;<br>  &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>如果你希望 scoped 样式中的一个选择器能够选择到子组 或 后代组件中的元素，我们可以使用 <code>深度作用选择器</code>，它有三种写法：</p><ul><li><code>&gt;&gt;&gt;</code>，示例： <code>.gby div &gt;&gt;&gt; #dyx p</code></li><li><code>/deep/</code>，示例： <code>.gby div /deep/ #dyx p</code> 或 <code>.gby div/deep/ #dyx p</code></li><li><code>::v-deep</code>，示例： <code>.gby div::v-deep #dyx p</code> 或 <code>.gby div::v-deep #dyx p</code></li></ul><p>它的原理与 Scoped CSS 的原理基本一样，只是第3步有些不同（前2步一样），具体如下：</p><ol><li>为每个组件实例（注意：是组件的实例，不是组件类）生成一个能唯一标识组件的标识符，我称它为实例标识，记作 InstanceID；</li><li>给组件模板中的每一个标签对应的Dom元素（组件标签对应的Dom元素是该组件的根元素）添加一个标签属性，格式为 <code>data-v-实例标识</code>，示例：<code>&lt;div data-v-e0f690c0=&quot;&quot; &gt;</code>；</li><li>给组件的作用域样式 <code>&lt;style scoped&gt;</code> 的每一个深度作用选择器前面的一个选择器单元增加一个属性选择器<code>[data-v-实例标识]</code> ，示例：假设原选择器为 <code>.cls #id &gt;&gt;&gt; div</code>，则更改后的选择器为 <code>.cls #id[data-v-e0f690c0] div</code>；</li></ol><p>因为Vue不会为深度作用选择器后面的选择器单元增加 属性选择器<code>[data-v-实例标识]</code>，所以，后面的选择器单元能够选择到子组件及后代组件中的元素；</p><h1 id="中标慧安"><a href="#中标慧安" class="headerlink" title="中标慧安"></a>中标慧安</h1><h2 id="怎么设置6px大小？"><a href="#怎么设置6px大小？" class="headerlink" title="怎么设置6px大小？"></a>怎么设置6px大小？</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box1</span>&#123;<br><span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;<br>-webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.50</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法是利用了CSS3的缩放属性，即：将文字大小整体缩小为原来的0.5倍，但是有一个硬伤，他只是缩小了文字的大小，并不能将文字所占的区域大小缩小，即无法缩小元素的width和height。</p><h2 id="文字溢出显示省略号"><a href="#文字溢出显示省略号" class="headerlink" title="文字溢出显示省略号"></a>文字溢出显示省略号</h2><h3 id="单行文本溢出"><a href="#单行文本溢出" class="headerlink" title="单行文本溢出"></a>单行文本溢出</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>: hidden;（文字长度超出限定宽度，则隐藏超出的内容）<br><span class="hljs-attribute">white-space</span>: nowrap;（设置文字在一行显示，不能换行）<br><span class="hljs-attribute">text-overflow</span>: ellipsis;（规定当文本溢出时，显示省略符号来代表被修剪的文本）<br></code></pre></td></tr></table></figure><h3 id="多行文本溢出"><a href="#多行文本溢出" class="headerlink" title="多行文本溢出"></a>多行文本溢出</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">display</span>: -webkit-box; //元素转换为弹性容器,在一行排列<br>-webkit-<span class="hljs-attribute">box-orient</span>: vertical; //表示盒子对象的子元素的排列方式<br>-webkit-<span class="hljs-selector-tag">line</span>-clamp: <span class="hljs-number">3</span>; //限制文本的行数，表示文本第多少行省略<br><span class="hljs-attribute">text-overflow</span>: ellipsis;//打点展示<br><span class="hljs-attribute">overflow</span>: hidden;//超出部分进行隐藏 <br></code></pre></td></tr></table></figure><h2 id="css实现三角形"><a href="#css实现三角形" class="headerlink" title="css实现三角形"></a>css实现三角形</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css">// 等腰三角形<br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">20px</span> solid transparent;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">20px</span> solid red;<br>  <span class="hljs-attribute">border-left</span>: <span class="hljs-number">20px</span> solid transparent;<br>  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">20px</span> solid transparent;<br>&#125;<br><br>// 直角三角形<br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">0px</span> solid transparent;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">20px</span> solid red;<br>  <span class="hljs-attribute">border-left</span>: <span class="hljs-number">10px</span> solid transparent;<br>  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">0px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><ol><li><p>父级div定义overflow: hidden</p></li><li><p>额外标签法：在父元素最后一个浮动子元素后面添加一个空标签div设置样式clear: both</p></li><li><p>给父元素添加after伪元素</p></li><li><p>给父元素添加before和after双伪元素</p></li></ol><h2 id="html5新增了什么"><a href="#html5新增了什么" class="headerlink" title="html5新增了什么"></a>html5新增了什么</h2><h3 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h3><p>header footer nav aside section menu template article audio video canvas 等</p><h3 id="webStorage-储存机制-sessionStorage-和-localStorage"><a href="#webStorage-储存机制-sessionStorage-和-localStorage" class="headerlink" title="webStorage 储存机制 sessionStorage 和 localStorage"></a>webStorage 储存机制 sessionStorage 和 localStorage</h3><p>webStorage: 使用HTML5可以在本地存储用户的浏览数据。早些时候,本地存储使用的是 cookie。但是Web 存储需要更加的安全与快速，这些数据不会被保存在服务器上，但是这些数据只用于用户请求网站数据上。它也可以存储大量的数据，而不影响网站的性能。数据以 键&#x2F;值对存在, web网页的数据只允许该网页访问使用。</p><p>Web Storage又分为两种： sessionStorage 和localStorage ，即这两个是Storage的一个实例。其API提供的方法有以下几种：</p><p>setItem (key, value) —— 保存数据，以键值对的方式储存信息。</p><p>getItem (key) —— 获取数据，将键值传入，即可获取到对应的value值。</p><p>removeItem (key) —— 删除单个数据，根据键值移除对应的信息。</p><p>clear () —— 删除所有的数据</p><p>key (index) —— 获取某个索引的key</p><p>localStorage：没有时间限制的数据存储</p><p>localStorage的生命周期是永久性的。假若使用localStorage存储数据，即使关闭浏览器，也不会让数据消失，除非主动的去删除数据，使用的方法如上所示。</p><p>sessionStorage：针对一个 session 的数据存储</p><p>sessionStorage 的生命周期是在浏览器关闭前。也就是说，在整个浏览器未关闭前，其数据一直都是存在的。sessionStorage也有length属性，其基本的判断和使用方法和localStorage的使用是一致的。需要注意的有以下几点：</p><p>(1) 页面刷新不会消除数据;</p><p>(2) 只有在当前页面打开的链接，才可以访sessionStorage的数据；</p><p>(3) 使用window.open打开页面和改变localtion.href方式都可以获取到sessionStorage内部的数据;</p><h3 id="history-对象"><a href="#history-对象" class="headerlink" title="history 对象"></a>history 对象</h3><p>history 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。</p><p>history.go( ) 方法可以在用户的历史记录中任意跳转，可以向后，也可以向前。</p><p>history.back() &#x2F;&#x2F; 后退一页</p><p>history.forward() &#x2F;&#x2F; 前进一页</p><h3 id="表单元素input新增的属性"><a href="#表单元素input新增的属性" class="headerlink" title="表单元素input新增的属性"></a>表单元素input新增的属性</h3><p>placeholder(输入框的占位文字)multiple(多个值)autofocus(最多输入的内容)；新增type值：datalist datetime date month week time color number email address range tel url search 等</p><h3 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h3><p>用于回放的 video 和 audio 元素</p><h3 id="用于绘画的-canvas"><a href="#用于绘画的-canvas" class="headerlink" title="用于绘画的 canvas"></a>用于绘画的 canvas</h3><h2 id="css隐藏元素的方法"><a href="#css隐藏元素的方法" class="headerlink" title="css隐藏元素的方法"></a>css隐藏元素的方法</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">display</span>: none;<br><span class="hljs-attribute">visibility</span>: hidden/collapse<br>opacity: <span class="hljs-number">0</span><br>transform: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>color: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>transform: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0</span>)<br>transform: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">9999px</span>, <span class="hljs-number">0px</span>)<br>position: absolute; <span class="hljs-attribute">left</span>: -<span class="hljs-number">9999px</span>;<br><span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>; <span class="hljs-attribute">border</span>:<span class="hljs-number">0</span>; <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>; <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>; <span class="hljs-attribute">width</span>:<span class="hljs-number">0</span>; <span class="hljs-attribute">overflow</span>: hidden;<br></code></pre></td></tr></table></figure><h2 id="webpack热更新"><a href="#webpack热更新" class="headerlink" title="webpack热更新"></a>webpack热更新</h2><p>Hot Module Replacement，简称HMR，在不需要刷新整个页面的同时更新模块，能够提升开发的效率和体验。热更新时只会局部刷新页面上发生了变化的模块，同时可以保留当前页面的状态，比如复选框的选中状态等。</p><p>webpack热更新开启</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">devServer</span>: &#123;<br><span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,<br>&#125;,<br></code></pre></td></tr></table></figure><p>通过webpack-dev-server，在我们修改了项目代码之后，webpack 会监听到文件内容的变化，并且重新进行编译等工作，然后会把新的代码通过 websocket 发送给浏览器。</p><p>浏览器获取到新的代码之后会重新执行模块代码，并且替换模块的内容</p><p>在 vue-cli 工程中，webpack 默认是自动启动热更新。</p><h2 id="用到的webpack属性"><a href="#用到的webpack属性" class="headerlink" title="用到的webpack属性"></a>用到的webpack属性</h2><p>css-loader、less-loader、babel-loader(ES6-ES5)、eslint-loader(格式检查)</p><p>proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器，在devServer中配置proxy解决跨域问题</p><p>当请求地址是以api开头是会命中这里进行代理转发，从而解决跨域问题</p><h2 id="原型和原型链-1"><a href="#原型和原型链-1" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><p>原型对象是函数的一个属性prototype，叫做原型，这个属性的值是个对象，也叫原型对象。</p><p>对象原型每个对象都有<code>__proto__</code>属性，指向它构造函数的原型对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span>  <span class="hljs-title function_">A</span>()<br>a.<span class="hljs-property">__proto__</span> = A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>原型链是 js 对象一种查找机制，遵循就近原则。当我们访问一个对象中的成员的时候，会优先访问自己的，如果自己没有就访问<code>__proto__</code>属性，也就是构造函数的原型对象，查看是否有该属性，如果也没有就会访问<code>__proto__</code>属性，直到原型链的终点 null. 如果还没有，此时属性就会获取 undefined，方法就会报错 xxx is not a function。</p><h2 id="vue组件通信"><a href="#vue组件通信" class="headerlink" title="vue组件通信"></a>vue组件通信</h2><p>父传子：</p><p>父组件绑定动态属性，接收要传递的变量，子组件使用props接收这个动态属性</p><p>子传父：</p><p>子组件调用this.$emit(“自定义事件”, 值)，父组件绑定自定义事件，触发回调函数</p><p>vuex：非父子组件通信</p><p>this.$refs可以直接在父组件修改子组件值</p><p>在子组件中通过this.$parent来调用父组件的方法</p><h2 id="常用git命令"><a href="#常用git命令" class="headerlink" title="常用git命令"></a>常用git命令</h2><p>git init 初始化本地git仓库</p><p>git clone 地址 克隆远程仓库</p><p>git add . 将所有文件放到暂存区</p><p>git commit -m “说明” 将暂存区文件提交到仓库</p><p>git log 查看提交记录</p><p>git remote add origin 地址 添加远程仓库地址</p><p>git push -u origin master 第一次向远程仓库推送代码</p><p>git branch 查看本地分支</p><p>git branch 分支名 新建分支</p><p>git branch -b 分支名 新建并切换到对应分支</p><p>git checkout分支名 切换到该分支</p><p>git branch -d 分支名 删除分支</p><p>git pull 拉取远程仓库最新代码</p><h3 id="将代码推送至master主分支"><a href="#将代码推送至master主分支" class="headerlink" title="将代码推送至master主分支"></a>将代码推送至master主分支</h3><ul><li><p>先切换到分支次分支：git checkout xxx (要合并到主分支上的次分支)</p></li><li><p>使用git pull 拉这条分支的最新的代码下来：git pull</p></li><li><p>切换到主分支：git checkout master</p></li><li><p>把次分支的代码推送到marster主分支：git merge xxx </p></li><li><p>拉取主分支最新代码下来，防止冲突：git pull</p></li><li><p>git push推送上去：git push</p></li></ul><h3 id="git-把master分支代码合并到自己的分支"><a href="#git-把master分支代码合并到自己的分支" class="headerlink" title="git 把master分支代码合并到自己的分支"></a>git 把master分支代码合并到自己的分支</h3><ul><li>首先切换到主分支：git checkout master</li><li>使用git pull 把领先的主分支代码pull下来：git pull</li><li>切换到自己的分支：git checkout xxx(自己的分支)</li><li>把主分支的代码merge到自己的分支：git merge master</li><li>拉取主分支最新代码下来，防止冲突：git pull</li><li>git push推上去ok完成,现在你自己分支的代码就和主分支的代码一样了</li></ul><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域一般可以理解为<strong>函数或变量的生效范围</strong>,我们一般把作用域分成全局作用域,函数(局部)作用域,块级作用域。</p><p><strong>全局作用域</strong>：任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问。</p><p>函数作用域也叫<strong>局部作用域</strong>，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问。</p><p><strong>块级作用域</strong>：ES6 引入了let和const关键字,和var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量</p><h2 id="for和forEach如何中断循环"><a href="#for和forEach如何中断循环" class="headerlink" title="for和forEach如何中断循环"></a>for和forEach如何中断循环</h2><p><strong>for循环</strong></p><ul><li>通过continue会跳过当前循环</li><li>使用break会中断循环</li><li>return只能用在函数体里</li></ul><p><strong>forEach循环</strong></p><ul><li>通过try+catch和throw new Error()中断循环</li><li>使用continue和break会报错</li><li>使用return会跳过当前循环</li></ul><h2 id="vue中watch和computed的区别"><a href="#vue中watch和computed的区别" class="headerlink" title="vue中watch和computed的区别"></a>vue中watch和computed的区别</h2><p>computed：计算属性，它具有缓存特性。</p><p>watch：侦听器，是Vue实例的一个属性，是用来响应数据的变化，需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。它可以监控一个变量，也可以是一个对象，一般用于监控路由、input输入框的值特殊处理等等，适用场景是一个数据影响多个数据，它不具有缓存性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-attr">computed</span>: &#123;<br>    计算属性名: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> xxx<br>    &#125;<br>  &#125;<br><span class="hljs-attr">watch</span>:&#123;<br>    被监听的数据:&#123;<br>        <span class="hljs-title function_">handler</span>(<span class="hljs-params">数据改变后的新值, 数据改变前的旧值</span>)&#123;<br>            逻辑代码<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>区别：</p><p>watch：监控vue实例的变化，它监控的变量必须在data里面声明才可以；监控的是属性值，只要属性值发生变化，其都会触发执行回调函数来执行一系列操作，它不具有缓存性。</p><p>computed：用来监控自己定义的变量，该变量不在data里面定义，直接在computed里面定义；监测的是依赖值，依赖值不变的情况下其会直接读取缓存进行复用，变化的情况下才会重新计算，具有缓存特性。</p><h2 id="RBAC权限设计"><a href="#RBAC权限设计" class="headerlink" title="RBAC权限设计"></a>RBAC权限设计</h2><p>先将权限分配给角色，再将角色分配给员工</p><p>项目是基于vue-admin-template模板进行二次开发的，侧边栏是通过根据路由表进行渲染的。在全局路由前置守卫中获取当前登录用户的信息，里面有一个包含权限点标识的数组，预先定义好的动态路由对象调用filter方法，拿到路由对象中权限标识对应的字符，如果当前用户拥有的权限标识包含的路由对象定义好的字符，然后使用router.addRoutes()添加到路由表里面。这个路由表会存到vuex中一份，渲染侧边栏时将vuex中的路由对象通过计算属性自动获取到然后渲染侧边栏</p><h2 id="Promise-1"><a href="#Promise-1" class="headerlink" title="Promise"></a>Promise</h2><p>Promise 是异步编程的一种解决方案，Promise是一个对象或者说是构造函数，用来封装异步操作并可以获取其成功或失败的结果，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。</p><h3 id="三种状态：-1"><a href="#三种状态：-1" class="headerlink" title="三种状态："></a>三种状态：</h3><ol><li>pending: 等待中，或者进行中，表示还没有得到结果</li><li>resolved(Fulfilled): 已经完成，表示得到了我们想要的结果，可以继续往下执行</li><li>rejected: 也表示得到结果，但是由于结果并非我们所愿，因此拒绝执行</li></ol><p>这三种状态不受外界影响，而且状态只能从pending改变为resolved或者rejected，不可逆。</p><h3 id="用法：-1"><a href="#用法：-1" class="headerlink" title="用法："></a>用法：</h3><p>promise的实例方法</p><ol><li>then()得到异步任务的正确结果；</li><li>catch()获取异常信息；</li><li>finally()成功与否都会执行(尚且不是正式标准)。</li></ol><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>可以避免多层异步调用嵌套问题(回调地狱)</li><li>Promise 对象提供了简洁的API，使得控制异步操作更加容易</li></ul><p>缺点：</p><ul><li>promise一旦新建就会立即执行，无法中途取消</li><li>当处于pending状态时，无法得知当前处于哪一个状态</li><li>如果不设置回调函数，promise内部的错误就无法反映到外部</li><li>promise封装ajax时，由于promise是异步任务，发送请求的三步会被延后到整个脚本同步代码执行完，并且将响应回调函数延迟到现有队列的最后，如果大量使用会大大降低了请求效率。</li></ul><h2 id="ES6新增"><a href="#ES6新增" class="headerlink" title="ES6新增"></a>ES6新增</h2><p>Symbol、let和const、解构赋值、新对象Map和Set、扩展运算符…、Object.assign()&#x2F;Object.is()、Array.of()&#x2F;Array.from()、箭头函数、import模块导入、export default默认导出、export const 命名导出、Promise</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是一个可以访问其他函数内部变量的函数</p><p>主要作用</p><ul><li>解决变量污染问题</li><li>延长局部变量的生命周期。</li></ul><h1 id="小沩科技"><a href="#小沩科技" class="headerlink" title="小沩科技"></a>小沩科技</h1><h2 id="http请求报文-1"><a href="#http请求报文-1" class="headerlink" title="http请求报文"></a>http请求报文</h2><p>http请求包括请求行、请求头、空行和请求体组成。</p><p>请求行包括请求方法、URL地址和协议版本，用空格隔开。</p><p>请求头用于指定服务器要使用的附加信息。请求头包括：</p><p>Accept：向服务器申明客户端可以接收的媒体类型（MIME）的资源</p><p>Accept-Encoding：客户端所能够支持的压缩格式</p><p>Accept-Language：指定http请求返回信息时优先选择的语言</p><p>Connection：是否需要持久连接</p><p>Content-Length：是请求体内容的长度</p><p>Content-Type：表示http请求提交的内容类型，只有在POST方法提交时才需要设置此属性</p><p>Cookie：存放用户身份的数据</p><p>Host：请求地址</p><p>User-Agent：记录客户端的详细信息</p><p>空行就是用于分割POST请求的请求头和请求体。</p><p>请求体主要封装的是POST请求消息的请求参数。</p><h2 id="http响应报文-1"><a href="#http响应报文-1" class="headerlink" title="http响应报文"></a>http响应报文</h2><p>http请求包括状态行、响应头、空行和响应体组成。</p><p>状态行包括报文协议及版本、状态码以及状态描述。</p><p>响应头用于描述服务器的基本信息。</p><p>空行就是用于分割POST请求的响应头和响应体。</p><p>响应体主要存放服务器响应给客户端的资源内容。</p><h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>https：是以安全为目标的http通道，简单讲是http的安全版，即http下加入SSL层，https的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>https的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><h3 id="https设计目标："><a href="#https设计目标：" class="headerlink" title="https设计目标："></a>https设计目标：</h3><p>(1)数据保密性：保证数据内容在传输的过程中不会被第三方查看</p><p>(2)数据完整性：及时发现被第三方篡改的传输内容。</p><p>(3)身份校验安全性：保证数据到达用户期望的目的地。</p><h3 id="https优点："><a href="#https优点：" class="headerlink" title="https优点："></a>https优点：</h3><ul><li>使用https可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li><li>https是由SSL+http构建的可进行加密传输、身份认证的网络协议，要比http安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li><li>https是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li><li>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等http网站，采用https加密的网站在搜索结果中的排名将会更高”。</li></ul><h3 id="https缺点："><a href="#https缺点：" class="headerlink" title="https缺点："></a>https缺点：</h3><ul><li>https握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</li><li>https连接缓存不如http高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</li><li>SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</li><li>SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</li><li>https的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</li></ul><h3 id="http和https区别"><a href="#http和https区别" class="headerlink" title="http和https区别"></a>http和https区别</h3><p>http：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从www服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p>https：是以安全为目标的http通道，简单讲是http的安全版，即http下加入SSL层，https的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>https的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><p>https设计目标：</p><p>(1)数据保密性：保证数据内容在传输的过程中不会被第三方查看</p><p>(2)数据完整性：及时发现被第三方篡改的传输内容。</p><p>(3)身份校验安全性：保证数据到达用户期望的目的地。</p><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p><p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>4、http的连接很简单，是无状态的。https协议是由SSL+http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息)</p><p>5、https由于需要设计加密以及多次握手，性能方面不如http</p><h2 id="http请求"><a href="#http请求" class="headerlink" title="http请求"></a>http请求</h2><p>get：用来获取数据的，只是用来查询数据，不对服务器的数据做任何的修改，新增，删除等操作，对应select操作</p><p>post：数据发送到服务器以创建或更新资源，侧重于更新数据，对应update操作</p><p>put：数据发送到服务器以创建或更新资源，侧重于创建数据，对应insert操作</p><p>delete：用来删除指定的资源，它会删除URI给出的目标资源的所有当前内容，对应delete操作</p><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>操作系统中最核心的概念是进程，<strong>进程</strong>是对正在运行中的程序的一个抽象，是系统进行资源分配和调度的基本单位</p><p>操作系统的其他所有内容都是围绕着进程展开的，负责执行这些任务的是CPU</p><p><strong>线程</strong>（thread）是操作系统能够进行运算调度的最小单位，其是进程中的一个执行任务（控制单元），负责当前进程中程序的执行</p><p> 一个进程至少有一个线程，一个进程可以运行多个线程，这些线程共享同一块内存，线程之间可以共享对象、资源，如果有冲突或需要协同，还可以随时沟通以解决冲突或保持同步</p><p> <strong>本质区别</strong>：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</p><p><strong>在开销方面</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小</p><p> <strong>所处环境</strong>：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p><p> <strong>内存分配方面</strong>：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源</p><p> <strong>包含关系</strong>：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程</p><h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>概念：系统进程不再用到的内存，没有及时释放，就叫做<strong>内存泄漏</strong>（memory leak）。当内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p><h3 id="引起内存泄漏的原因："><a href="#引起内存泄漏的原因：" class="headerlink" title="引起内存泄漏的原因："></a>引起内存泄漏的原因：</h3><h4 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h4><p>由于 js 对未声明变量的处理方式是在全局对象上创建该变量的引用。如果在浏览器中，全局对象就是 window 对象。变量在窗口关闭或重新刷新页面之前都不会被释放，如果未声明的变量缓存大量的数据，就会导致内存泄露。</p><ul><li>未声明变量</li><li>使用 this 创建的变量(this 的指向是 window)。</li></ul><p>解决方法：</p><ul><li>避免创建全局变量</li><li>使用严格模式,在 JavaScript 文件头部或者函数的顶部加上 use strict</li></ul><h4 id="闭包引起的内存泄漏"><a href="#闭包引起的内存泄漏" class="headerlink" title="闭包引起的内存泄漏"></a>闭包引起的内存泄漏</h4><p>由于闭包可以读取函数内部的变量，然后让这些变量始终保存在内存中。如果在使用结束后没有将局部变量清除，就可能导致内存泄露。</p><p>解决方法：将事件处理函数定义在外部，解除闭包，或者在定义事件处理函数的外部函数中。</p><p>比如：在循环中的函数表达式，能复用最好放到循环外面。</p><h4 id="没有清理的DOM元素引用"><a href="#没有清理的DOM元素引用" class="headerlink" title="没有清理的DOM元素引用"></a>没有清理的DOM元素引用</h4><p>虽然在某个地方删除了元素，但是对象中还存在对dom的引用。</p><p>解决方法：手动删除，elements.btn &#x3D; null</p><h4 id="被遗忘的定时器或者回调"><a href="#被遗忘的定时器或者回调" class="headerlink" title="被遗忘的定时器或者回调"></a>被遗忘的定时器或者回调</h4><p>定时器中有 dom 的引用，即使 dom 删除了，但是定时器还在，所以内存中还是有这个 dom。</p><p>解决方法：</p><p>手动删除定时器和 dom</p><p>removeEventListener 移除事件监听</p><h3 id="vue中容易出现内存泄漏的几种情况"><a href="#vue中容易出现内存泄漏的几种情况" class="headerlink" title="vue中容易出现内存泄漏的几种情况"></a>vue中容易出现内存泄漏的几种情况</h3><p>在 Vue单页面开发应用，那么就更要当心内存泄漏的问题。因为在 SPA 的设计中，用户使用它是不需要刷新浏览器的，所以JavaScript应用需要自行清理组件来确保垃圾回收以预期的方式生效。因此开发过程中，需要时刻警惕内存泄漏的问题。</p><h4 id="全局变量造成的内存泄露"><a href="#全局变量造成的内存泄露" class="headerlink" title="全局变量造成的内存泄露"></a>全局变量造成的内存泄露</h4><p>声明的全局变量在切换页面的时候没有清空</p><h4 id="监听在-window-body-等事件没有解绑"><a href="#监听在-window-body-等事件没有解绑" class="headerlink" title="监听在 window&#x2F;body 等事件没有解绑"></a>监听在 window&#x2F;body 等事件没有解绑</h4><p>特别注意 window.addEventListener 之类的时间监听</p><p>解决：在页面销毁的时候将全局变量设置为null、移除事件绑定</p><h1 id="连帆科技"><a href="#连帆科技" class="headerlink" title="连帆科技"></a>连帆科技</h1><h2 id="匿名函数和箭头函数的区别"><a href="#匿名函数和箭头函数的区别" class="headerlink" title="匿名函数和箭头函数的区别"></a>匿名函数和箭头函数的区别</h2><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>匿名函数也叫函数表达式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> fun = <span class="hljs-keyword">function</span>(<span class="hljs-params">x,y</span>)&#123;<br>    <span class="hljs-keyword">return</span> x + y<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="箭头函数-1"><a href="#箭头函数-1" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>当函数体只有一条语句时，可以省略return</p><p>当参数只有一个时，可以省略()</p><p>缺点：IE11 或更早的版本不支持箭头函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fun</span> = (<span class="hljs-params">x,y</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> x+y<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-title function_">fun</span> = (<span class="hljs-params">x,y</span>) =&gt; x + y<br><span class="hljs-keyword">let</span> <span class="hljs-title function_">fun</span> = x =&gt; <span class="hljs-keyword">return</span> x * x<br></code></pre></td></tr></table></figure><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a><strong>区别：</strong></h3><p>匿名函数的this指向全局对象window</p><p>箭头函数的this指向所在作用域的this</p><h2 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h2><ol><li>以函数的形式（包括普通函数、定时器函数、立即执行函数）调用时，this的指向永远都是window。比如fun();相当于window.fun();匿名函数具有全局性，匿名函数的this指向window对象</li><li>以方法的形式调用时，this指向调用方法的那个对象</li><li>以构造函数的形式调用时，this指向实例对象</li><li>以事件绑定函数的形式调用时，this指向绑定事件的对象</li><li>使用call、apply和bind调用时，this指向指定的那个对象</li><li>箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象)，此处指父级作用域</li><li>严格模式下变量必须用关键字声明后才能使用<ul><li>严格模式下，普通函数的this指向undefined</li><li>严格模式下，立即执行函数的this指向undefined</li><li>严格模式下，setTimeout中函数的this指向的window（与普通函数不同）</li><li>严格模式下，构造函数的this指向undefined，但是构造函数实例化对象的this指向的是实例化对象本身</li></ul></li></ol><h2 id="改变this的指向"><a href="#改变this的指向" class="headerlink" title="改变this的指向"></a>改变this的指向</h2><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> person = &#123;<br>  <span class="hljs-attr">fullName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">city, country</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> + <span class="hljs-string">&quot;,&quot;</span> + city + <span class="hljs-string">&quot;,&quot;</span> + country;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> person1 = &#123;<br>  <span class="hljs-attr">firstName</span>:<span class="hljs-string">&quot;Bill&quot;</span>,<br>  <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Gates&quot;</span><br>&#125;<br>person.<span class="hljs-property">fullName</span>.<span class="hljs-title function_">call</span>(person1, <span class="hljs-string">&quot;Oslo&quot;</span>, <span class="hljs-string">&quot;Norway&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> person = &#123;<br>  <span class="hljs-attr">fullName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">city, country</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> + <span class="hljs-string">&quot;,&quot;</span> + city + <span class="hljs-string">&quot;,&quot;</span> + country;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> person1 = &#123;<br>  <span class="hljs-attr">firstName</span>:<span class="hljs-string">&quot;Bill&quot;</span>,<br>  <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Gates&quot;</span><br>&#125;<br>person.<span class="hljs-property">fullName</span>.<span class="hljs-title function_">apply</span>(person1, [<span class="hljs-string">&quot;Oslo&quot;</span>, <span class="hljs-string">&quot;Norway&quot;</span>]);<br></code></pre></td></tr></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;WuXiaoDi&#x27;</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printName</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>&#125;<br><span class="hljs-keyword">var</span> wuXiaoDi = printName.<span class="hljs-title function_">bind</span>(obj)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(wuXiaoDi)<span class="hljs-comment">//function()&#123;...&#125;</span><br><span class="hljs-title function_">wuXiaoDi</span>()<span class="hljs-comment">//WuXiaoDi</span><br><br></code></pre></td></tr></table></figure><h3 id="区别：-1"><a href="#区别：-1" class="headerlink" title="区别："></a>区别：</h3><p><strong>call和apply接收的参数不同</strong><br>apply()方法接收俩个参数，一个是函数运行的作用域（this），另一个是参数数组。<br>call()方法第一个参数和apply()方法的一样，但是传递给函数的参数必须一 一列举出来。</p><p><strong>返回值区别</strong></p><p>bind的返回值是一个函数，而call和apply是立即调用。</p><h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><p><strong><code>链表</code></strong> 是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> reversePrint = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-comment">// 方法一：使用循环读取对于内容</span><br>    <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> []<br>    <span class="hljs-keyword">let</span> result = []<br>    <span class="hljs-keyword">while</span>(head) &#123;<br>        result.<span class="hljs-title function_">push</span>(head.<span class="hljs-property">val</span>)<br>        head = head.<span class="hljs-property">next</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> result.<span class="hljs-title function_">reverse</span>()<br>&#125;;<br><br><span class="hljs-keyword">var</span> reversePrint = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-comment">// 方法二： 使用递归读取内容</span><br>    <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> []<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-title function_">reversePrint</span>(head.<span class="hljs-property">next</span>)<br>    result.<span class="hljs-title function_">push</span>(head.<span class="hljs-property">val</span>)<br>    <span class="hljs-keyword">return</span> result<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="补全sum函数"><a href="#补全sum函数" class="headerlink" title="补全sum函数"></a>补全sum函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// sum(2,3)    // 5</span><br><span class="hljs-comment">// sum(2)(3)   // 5</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">...arg</span>) &#123;<br>    <span class="hljs-keyword">var</span> tmp = [...arg];<span class="hljs-comment">//第一个括号传入的参数</span><br>    <span class="hljs-keyword">var</span> _add = <span class="hljs-keyword">function</span> (<span class="hljs-params">...innerArg</span>) &#123;<br>        <span class="hljs-keyword">if</span> (innerArg.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> tmp.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123; <span class="hljs-keyword">return</span> a + b &#125;)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            [].<span class="hljs-property">push</span>.<span class="hljs-title function_">apply</span>(tmp, innerArg)<br>            <span class="hljs-comment">//Array.prototype.push.apply(arr1,arr2): 在原型上连接数组，将arr2连接在arr1的尾部，参数只能为2个，</span><br>            <span class="hljs-keyword">return</span> _add;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> _add<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)())    <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><h2 id="实现一个按钮"><a href="#实现一个按钮" class="headerlink" title="实现一个按钮"></a>实现一个按钮</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.button</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">20px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">line-height</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: white;</span><br><span class="language-css">            <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">            <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.5s</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.button</span><span class="hljs-selector-pseudo">:hover</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: yellow;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="language-css">            <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0px</span> <span class="hljs-number">3px</span> <span class="hljs-number">5px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.8</span>);</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.button&#x27;</span>)</span><br><span class="language-javascript">    btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        btn.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;按钮被点击了&#x27;</span>;</span><br><span class="language-javascript">        btn.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = <span class="hljs-string">&quot;20px&quot;</span>;</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">    btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mouseleave&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        btn.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;鼠标离开按钮了&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">    btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mouseover&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        btn.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;鼠标在按钮上面了&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="ES6新增了什么"><a href="#ES6新增了什么" class="headerlink" title="ES6新增了什么"></a>ES6新增了什么</h2><p>Symbol、let和const、解构赋值、Map和Set、扩展运算符…、Object.assign()&#x2F;Object.is()、Array.of()&#x2F;Array.from()、箭头函数、import模块导入、export default默认导出、export const 命名导出、Promise</p><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它属于 JavaScript 语言的原生数据类型之一，其他数据类型是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、大整数（BigInt）、对象（Object）。</p><p>Symbol 值通过<code>Symbol()</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 没有参数的情况</span><br><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>();<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>();<br><br>s1 === s2 <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 有参数的情况</span><br><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><br>s1 === s2 <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="var、let和const"><a href="#var、let和const" class="headerlink" title="var、let和const"></a>var、let和const</h3><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">1</span>;<br>&#125;<br><br>a <span class="hljs-comment">// ReferenceError: a is not defined.</span><br>b <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p><code>var</code>命令会发生“变量提升”现象，即变量可以在声明之前使用，值为<code>undefined</code>。</p><p><code>let</code>命令所声明的变量一定要在声明后使用，否则报错。</p><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p><p><code>let</code>实际上为 JavaScript 新增了块级作用域。</p><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p><p><code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。</p><p><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。</p><p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p><p>如果解构不成功，变量的值就等于<code>undefined</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [foo, [[bar], baz]] = [<span class="hljs-number">1</span>, [[<span class="hljs-number">2</span>], <span class="hljs-number">3</span>]];<br>foo <span class="hljs-comment">// 1</span><br>bar <span class="hljs-comment">// 2</span><br>baz <span class="hljs-comment">// 3</span><br><br><span class="hljs-keyword">let</span> [ , , third] = [<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-string">&quot;baz&quot;</span>];<br>third <span class="hljs-comment">// &quot;baz&quot;</span><br><br><span class="hljs-keyword">let</span> [x, , y] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>x <span class="hljs-comment">// 1</span><br>y <span class="hljs-comment">// 3</span><br><br><span class="hljs-keyword">let</span> [head, ...tail] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>head <span class="hljs-comment">// 1</span><br>tail <span class="hljs-comment">// [2, 3, 4]</span><br><br><span class="hljs-keyword">let</span> [x, y, ...z] = [<span class="hljs-string">&#x27;a&#x27;</span>];<br>x <span class="hljs-comment">// &quot;a&quot;</span><br>y <span class="hljs-comment">// undefined</span><br>z <span class="hljs-comment">// []</span><br></code></pre></td></tr></table></figure><h3 id="Set和Map-1"><a href="#Set和Map-1" class="headerlink" title="Set和Map"></a>Set和Map</h3><h4 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h4><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> defaultSet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-number">12</span>,<span class="hljs-literal">true</span>])<br><span class="hljs-title class_">Set</span>(<span class="hljs-number">3</span>) &#123;<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-number">12</span>, <span class="hljs-literal">true</span>&#125;<br><span class="hljs-comment">// [[Entries]]</span><br><span class="hljs-comment">// 0: &quot;name&quot;</span><br><span class="hljs-comment">// 1: 12</span><br><span class="hljs-comment">// 2: true</span><br><span class="hljs-comment">// size: 3</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br>[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> s.<span class="hljs-title function_">add</span>(x));<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> s) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>&#125;<br><span class="hljs-comment">// 2 3 5 4</span><br></code></pre></td></tr></table></figure><ul><li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">s.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 注意2被加入了两次</span><br><br>s.<span class="hljs-property">size</span> <span class="hljs-comment">// 2</span><br><br>s.<span class="hljs-title function_">has</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// true</span><br>s.<span class="hljs-title function_">has</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// true</span><br>s.<span class="hljs-title function_">has</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// false</span><br><br>s.<span class="hljs-title function_">delete</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// true</span><br>s.<span class="hljs-title function_">has</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h4 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h4><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> defaultMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;zs&#x27;</span>],[<span class="hljs-string">&#x27;age&#x27;</span>,<span class="hljs-number">20</span>]])<br><span class="hljs-comment">// Map(2) &#123; &#x27;name&#x27; =&gt; &#x27;zs&#x27;, &#x27;age&#x27; =&gt; 20 &#125;</span><br><span class="hljs-comment">// 0: &#123; &#x27;name&#x27; =&gt; &#x27;zs&#x27; &#125; key:&#x27;name&#x27;, value:&#x27;zs&#x27;</span><br><span class="hljs-comment">// 1: &#123; &#x27;age&#x27; =&gt; 20 &#125; key:&#x27;age&#x27;, value: 20</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> data = &#123;&#125;;<br><span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myDiv&#x27;</span>);<br><br>data[element] = <span class="hljs-string">&#x27;metadata&#x27;</span>;<br>data[<span class="hljs-string">&#x27;[object HTMLDivElement]&#x27;</span>] <span class="hljs-comment">// &quot;metadata&quot;</span><br></code></pre></td></tr></table></figure><p>Map 结构的实例有以下属性和操作方法。</p><ul><li><strong>size 属性</strong>：<code>size</code>属性返回 Map 结构的成员总数。</li><li>**Map.prototype.set(key, value)**：<code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</li><li>**Map.prototype.get(key)**：<code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</li><li>**Map.prototype.has(key)**：<code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</li><li>**Map.prototype.delete(key)**：<code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</li><li>**Map.prototype.clear()**：<code>clear</code>方法清除所有成员，没有返回值</li></ul><h2 id="Promise-2"><a href="#Promise-2" class="headerlink" title="Promise"></a>Promise</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p><code>Promise</code>对象有以下两个特点。</p><p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</p><p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。</p><p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p><p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><h1 id="笛佛软件笔试"><a href="#笛佛软件笔试" class="headerlink" title="笛佛软件笔试"></a>笛佛软件笔试</h1><h2 id="哪些数据结构不能被for…of…遍历"><a href="#哪些数据结构不能被for…of…遍历" class="headerlink" title="哪些数据结构不能被for…of…遍历"></a>哪些数据结构不能被for…of…遍历</h2><p>ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被<code>for...of</code>循环遍历。原因在于，这些数据结构原生部署了<code>Symbol.iterator</code>属性（详见下文），另外一些数据结构没有（比如对象）。凡是部署了<code>Symbol.iterator</code>属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p><p>原生具备 Iterator 接口的数据结构如下。</p><p>Array、Map、Set、String、TypedArray、函数的 arguments 对象、NodeList 对象</p><h2 id="CSS属性书写顺序"><a href="#CSS属性书写顺序" class="headerlink" title="CSS属性书写顺序"></a>CSS属性书写顺序</h2><ol><li>布局定位属性：display &#x2F; position &#x2F; float &#x2F; clear &#x2F; visibility &#x2F; overflow（建议 display 第一个写，毕竟关系到模式）</li><li>自身属性：width &#x2F; height &#x2F; margin &#x2F; padding &#x2F; border &#x2F; background</li><li>文本属性：color &#x2F; font &#x2F; text-decoration &#x2F; text-align &#x2F; vertical-align &#x2F; white- space &#x2F; break-word</li><li>其他属性（CSS3）：content &#x2F; cursor &#x2F; border-radius &#x2F; box-shadow &#x2F; text-shadow &#x2F; background:linear-gradient …</li></ol><h2 id="JS获取对象属性key的方法"><a href="#JS获取对象属性key的方法" class="headerlink" title="JS获取对象属性key的方法"></a>JS获取对象属性key的方法</h2><p>for in：遍历自身的和继承的全部可枚举属性。不包括不可枚举属性和Symbol属性</p><p>Object.keys()：返回一个数组；获取自身（不含继承）可枚举属性。不包括不可枚举属性、Symbol属性</p><p>Object.getOwnPropertyNames：返回一个数组；获取自身全部（不含继承）属性名称，包括不可枚举属性，不包括Symbol属性</p><p>Object.getOwnPropertySymbols：返回一个数组，遍历了对象自身的所有Symbol属性</p><p>Reflect.ownKeys：返回一个数组；获取自身（不含继承）全部属性名称，包括不可枚举属性、Symbol。其实就是Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和</p><p>只有for in 包含继承的可枚举属性；</p><p>只有Object.getOwnPropertySymbols和Reflect.ownKeys可以包含Symbol属性；</p><p>只有Object.getOwnPropertyNames和Reflect.ownKeys包含不可枚举属性；</p><h2 id="JS全局函数"><a href="#JS全局函数" class="headerlink" title="JS全局函数"></a>JS全局函数</h2><p>decodeURI()解码某个编码的 URI。<br>decodeURIComponent()解码一个编码的 URI 组件。<br>encodeURI()把字符串编码为 URI。<br>encodeURIComponent()把字符串编码为 URI 组件。<br>escape()对字符串进行编码。<br>eval()计算 JavaScript 字符串，并把它作为脚本代码来执行。<br>isFinite()检查某个值是否为有穷大的数。<br>isNaN()检查某个值是否是数字。<br>Number()把对象的值转换为数字。<br>parseFloat()解析一个字符串并返回一个浮点数。<br>parseInt()解析一个字符串并返回一个整数。<br>String()把对象的值转换为字符串。<br>unescape()对由 escape() 编码的字符串进行解码。</p><h1 id="笛佛软件面试"><a href="#笛佛软件面试" class="headerlink" title="笛佛软件面试"></a>笛佛软件面试</h1><h2 id="window的onload事件"><a href="#window的onload事件" class="headerlink" title="window的onload事件"></a>window的onload事件</h2><ol><li><p>onload事件会在整个页面加载完成后才会触发</p></li><li><p>window绑定一个onload事件</p><p>该事件对应的响应函数将会在页面加载完成之后执行</p><p>这样可以确保代码执行时所有的DOM对象已经加载完毕</p><p>html执行顺序从上到下（js代码在body前面，会导致先执行js代码，再加载dom对象），window.onload()可以解决这个问题</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.οnlοad=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>---函数中放js代码<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="window对象常见事件"><a href="#window对象常见事件" class="headerlink" title="window对象常见事件"></a>window对象常见事件</h3><h4 id="窗口加载事件"><a href="#窗口加载事件" class="headerlink" title="窗口加载事件"></a>窗口加载事件</h4><p>(1)window.onload<br><code>window.onload = function()&#123;&#125; ; </code><br>当页面内容完全加载完成之后会触发该事件(含图像,脚本文件,css,文件等),就调用的处理函数<br>传统注册事件方式,只能写一次,若有多个,以最后一个 window.onload 为准,前边的都会被覆盖<br>(2)addEventListener<br><code>window.addEventListener(&quot;load&quot;,function()&#123;&#125;); </code><br>不会被覆盖,多个也可生效,无限制<br>(3)DOMContentLoaded<br><code>document.addEventListener(&#39;DOMContentLoaded&#39;,function()&#123;&#125;); </code><br>事件触发时,仅当DOM加载完成,不包括样式表,图片,flash等. Ie9以上才支持<br>若页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间, 交互效果就不能实现，必然影响用户的体验，此时用 DOMContentLoaded 事件比较合适</p><h4 id="调整窗口大小事件"><a href="#调整窗口大小事件" class="headerlink" title="调整窗口大小事件"></a>调整窗口大小事件</h4><p>(1)window.onresize<br><code>window.onresize = function()&#123;&#125;</code>                                                                                                                                                        调整窗口大小加载事件,当触发时就调用的处理函数<br>只要窗口大小发生像素变化,就会触发这事件<br>响应式布局,  window.innerWidth 当前屏幕的宽度;  window.innerHeight 当前屏幕的高度<br>(2)resize<br><code>window.addEventListener(&quot;resize&quot;,function()&#123;&#125;);</code></p><h2 id="BOM和DOM"><a href="#BOM和DOM" class="headerlink" title="BOM和DOM"></a>BOM和DOM</h2><p>DOM（Document Object Model）即文档对象模型，用于操作页面元素，其核心对象是 document</p><p>BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。BOM包含DOM</p><p>BOM包含document、location、navigation、screen、history等对象。</p><h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><p>定义：用于获取或设置窗体的 URL,并且可以用于解析 URL</p><p>URL：统一资源定位符 (Uniform Resource Locator, URL) 是互联网上标准资源的地址<br>互联网上的每个文件都有一个唯一的 URL,包含的信息指出文件的位置以及浏览器应该怎么处理它<br>URL 的一般语法格式为：  protocol:&#x2F;&#x2F;host[:port]&#x2F;path&#x2F;[?query]#fragment   e.g: <a href="http://www.itcast.cn/index.html?name=andy&age=18#link">http://www.itcast.cn/index.html?name=andy&amp;age=18#link</a></p><p>protocol：通信协议，http、ftp、maito等</p><p>host：主机（域名）</p><p>port：端口号，省略时使用方案的默认端口</p><p>path：路径，有零或多个”&#x2F;“符号隔开的字符串，一般用于表示主机上的一个目录或文件地址</p><p>query：参数，以键值对形式，通过&amp;符号分隔开</p><p>fragment：片段，#后面内容，常见于链接锚点</p><h4 id="location对象属性"><a href="#location对象属性" class="headerlink" title="location对象属性"></a>location对象属性</h4><p>location.href：获取或设置整个URL</p><p>location.host：返回主机（域名）</p><p>location.port：返回端口号，如果未写返回空字符串</p><p>location.pathname：返回路径</p><p>location.search：返回参数</p><p>location.hash：返回片段，#后面内容，常见于链接锚点</p><h3 id="navigation对象"><a href="#navigation对象" class="headerlink" title="navigation对象"></a>navigation对象</h3><p>包含有关浏览器的信息,它有很多属性, 最常用userAgent,该属性可以返回由客户机发送服务器的 user-agent 头部的值</p><h3 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h3><p>与浏览器历史记录进行交互（模拟前进后退按钮），该对象包含用户（在浏览器窗口中）访问过的URL。</p><h2 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h2><p>computed：计算属性，它具有缓存特性。</p><p>watch：侦听器，是Vue实例的一个属性，是用来响应数据的变化，需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。它可以监控一个变量，也可以是一个对象，一般用于监控路由、input输入框的值特殊处理等等，适用场景是一个数据影响多个数据，它不具有缓存性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-attr">computed</span>: &#123;<br>    计算属性名: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> xxx<br>    &#125;<br>  &#125;<br><span class="hljs-attr">watch</span>:&#123;<br>    被监听的数据:&#123;<br>        <span class="hljs-title function_">handler</span>(<span class="hljs-params">数据改变后的新值, 数据改变前的旧值</span>)&#123;<br>            逻辑代码<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>区别：</p><ul><li><p>功能上：computed是计算属性，watch是监听一个值的变化，然后执行对应的回调。</p></li><li><p>是否调用缓存：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调。</p></li><li><p>是否调用return：computed中的函数必须要用return返回，watch中的函数不是必须要用return。</p></li><li><p>computed默认第一次加载的时候就开始监听；watch默认第一次加载不做监听，如果需要第一次加载做监听，添加immediate属性，设置为true（immediate:true）</p></li></ul><h2 id="js事件委托的原理"><a href="#js事件委托的原理" class="headerlink" title="js事件委托的原理"></a>js事件委托的原理</h2><p><strong>事件委托</strong>也称为事件代理。就是利用<strong>事件冒泡</strong>，把子元素的事件都绑定到父元素上。如果子元素阻止了事件冒泡，那么委托就无法实现。</p><p><strong>事件冒泡</strong>：即一个元素的事件触发后，会依次一级一级往上调用父级元素的同名事件，直到window(注：IE8和之前的浏览器只到document)</p><p><strong>作用</strong>：</p><ol><li>节约内存</li><li>能为之后新增的DOM元素依然添加事件</li></ol><h2 id="节流和防抖"><a href="#节流和防抖" class="headerlink" title="节流和防抖"></a>节流和防抖</h2><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p><strong>定义</strong>：触发事件后，在n秒内，事件只执行一次，如果在n秒内又触发了事件，则会重新计算函数的执行时间。(注意，下面代码let timer&#x3D;null只执行一次)</p><p>比如点击按钮，2秒后调用函数，结果在1.5秒的时候又点了，则会重新计算2秒后在调用函数。</p><p><strong>应用场景</strong>：</p><ol><li><p>调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖；</p></li><li><p>文本编辑器实时保存，当无任何更改操作一秒后进行保存。</p></li><li><p>搜索框输入时，n秒后再请求后台数据，如果不到n秒又输入就重新等待n秒</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn,delay</span>)&#123;<br>    <span class="hljs-keyword">let</span> timer=<span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">let</span> arg=<span class="hljs-variable language_">arguments</span><br>        <span class="hljs-keyword">if</span>(timer) <span class="hljs-title function_">clearTimerout</span>(timer)<br>        timer=<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,arg)<br>        &#125;,delay)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p><strong>定义</strong>：连续发生的事件在n秒内，只执行为一次</p><p><strong>应用场景</strong>：</p><ol><li><p>鼠标连续不断地触发某事件（如点击），单位时间内只触发一次；</p></li><li><p>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断。例如：懒加载；</p></li><li><p>浏览器播放事件，每个一秒计算一次进度信息等。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn,delay</span>)&#123;<br>    <span class="hljs-keyword">let</span> timer=<span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">let</span> arg=<span class="hljs-variable language_">arguments</span><br>        <span class="hljs-keyword">if</span>(!timer) &#123;<br>            timer=<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,arg)<br>                timer=<span class="hljs-literal">null</span><br>            &#125;,delay)     <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="路由导航守卫"><a href="#路由导航守卫" class="headerlink" title="路由导航守卫"></a>路由导航守卫</h2><p>当路由发生跳转的时候，会触发一个钩子函数，在函数中可以通过跳转或取消或强制切换跳转地址来守卫导航，路由守卫里面必须要有一个next()调用作为出口，让路由页面跳转。</p><h3 id="路由前置守卫"><a href="#路由前置守卫" class="headerlink" title="路由前置守卫"></a>路由前置守卫</h3><ol><li>开启进度条</li><li>判断本地或vuex中有没有token<ol><li>有token，如果要去的页面是登录页，不放行，跳转首页，关闭进度条；否则放行，执行下面的逻辑代码；</li><li>没有token，如果要去的页面在白名单数组里面，放行；否则跳转登录页面，关闭进度条。</li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-title function_">async</span>(to, <span class="hljs-keyword">from</span>, next) =&gt; &#123;<br>  <span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">start</span>()<br>  <span class="hljs-comment">// 进入路由前置守卫就打开进度条 如果中断导航要关闭进度条，正常跳转后会走路由后置守卫关闭进度条</span><br>  <span class="hljs-keyword">const</span> token = store.<span class="hljs-property">getters</span>.<span class="hljs-property">token</span><br>  <span class="hljs-comment">// 登录了不能去的登录页</span><br>  <span class="hljs-comment">// 不登录只能去登录页</span><br>  <span class="hljs-keyword">if</span> (token) &#123; <span class="hljs-comment">// 登录了</span><br>    <span class="hljs-keyword">if</span> (to.<span class="hljs-property">path</span> === <span class="hljs-string">&#x27;/login&#x27;</span>) &#123; <span class="hljs-comment">// 去登录页</span><br>      <span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;/&#x27;</span>) <span class="hljs-comment">// 跳转首页</span><br>      <span class="hljs-comment">// 如果中断导航，需要自己关闭正常流程进度条</span><br>      <span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">done</span>()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">next</span>()<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果没有登录</span><br>    <span class="hljs-keyword">if</span> (whiteList.<span class="hljs-title function_">includes</span>(to.<span class="hljs-property">path</span>)) &#123; <span class="hljs-comment">// 要去的路由地址字符串是否在白名单数组里出现</span><br>      <span class="hljs-comment">// 如果出现过放行</span><br>      <span class="hljs-title function_">next</span>()<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 去别的页面不放行，并跳转登录页</span><br>      <span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;/login&#x27;</span>)<br>      <span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">done</span>()<br>    &#125;<br>  &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure><h3 id="路由后置守卫"><a href="#路由后置守卫" class="headerlink" title="路由后置守卫"></a>路由后置守卫</h3><p>正常next()放行跳转了，才会走后置守卫，关闭正常流程进度条</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><br>router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-title function_">getPageTitle</span>(to.<span class="hljs-property">meta</span>.<span class="hljs-property">title</span>)<br>  <span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">done</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="请求拦截器"><a href="#请求拦截器" class="headerlink" title="请求拦截器"></a>请求拦截器</h3><p>目的：在发起请求时统一携带token值</p><p>实现：判断本地localStorage或vuex中是否有token值，如果有值就将token携带在请求头中发送给后台</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">service.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> token = store.<span class="hljs-property">getters</span>.<span class="hljs-property">token</span> || <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;token&#x27;</span>)<br>    <span class="hljs-keyword">if</span> (token) &#123;<br>      config.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;Authorization&#x27;</span>] = <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;token&#125;</span>`</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> config<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>  &#125;<br>)<br></code></pre></td></tr></table></figure><h3 id="响应拦截器"><a href="#响应拦截器" class="headerlink" title="响应拦截器"></a>响应拦截器</h3><p>目的：对请求回来的数据进行判断</p><p>实现：</p><ul><li>状态码2xx和3xx时执行第一个回调函数，如果成功success就返回响应的数据response，否则提示错误信息message并返回Promise的reject状态</li><li>状态码4xx和5xx时执行第二个回调函数，如果状态码为401或code逻辑码为10002，证明当前身份验证失败，token过期，然后需要清除本地token和vuex中数据，然后跳转登录页面，并返回Promise的reject状态</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js">service.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 2xx和3xx的响应状态进入这里</span><br>    <span class="hljs-comment">// response参数是axios响应对象(里面config/header/status/data)</span><br>    <span class="hljs-comment">// data字段里对应的才是后台返回的全部的数据 也是一个对象</span><br>    <span class="hljs-comment">// 第一个data是axios自带的</span><br>    <span class="hljs-comment">// console.log(response)</span><br>    <span class="hljs-keyword">const</span> &#123; success, message &#125; = response.<span class="hljs-property">data</span><br>    <span class="hljs-keyword">if</span> (success) &#123;<br>      <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 逻辑失败 把后台返回message提示文字返回到逻辑页面</span><br>      <span class="hljs-comment">// 返回Promise的reject拒绝状态 await无法接收 如果有try+catch进catch里</span><br>      <span class="hljs-title class_">Message</span>.<span class="hljs-title function_">error</span>(message)<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(message)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// console.dir(error)</span><br>    <span class="hljs-comment">// 4xx和5xx的响应状态进入这里</span><br>    <span class="hljs-comment">// &amp;&amp; 为了防止null.data报错</span><br>    <span class="hljs-title class_">Message</span>.<span class="hljs-title function_">error</span>((error.<span class="hljs-property">response</span> &amp;&amp; error.<span class="hljs-property">response</span>.<span class="hljs-property">data</span> &amp;&amp; error.<span class="hljs-property">response</span>.<span class="hljs-property">data</span>.<span class="hljs-property">message</span>) || error.<span class="hljs-property">message</span>)<br>    <span class="hljs-comment">// 上面是报错就提示，下面是具体分析</span><br>    <span class="hljs-comment">// 可以用http状态码老判断 error.response.status === 401</span><br>    <span class="hljs-comment">// 或者可以用code逻辑码判断</span><br>    <span class="hljs-keyword">if</span> (error?.<span class="hljs-property">response</span>?.<span class="hljs-property">data</span>?.<span class="hljs-property">code</span> === <span class="hljs-number">10002</span>) &#123;<br>      <span class="hljs-comment">// token过期：</span><br>      <span class="hljs-comment">// 1.清除本地token，</span><br>      <span class="hljs-comment">// 2.清除vuex，</span><br>      store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;user/logoutActions&#x27;</span>)<br>      <span class="hljs-comment">// 3.强制跳转登录页（也要把被动退出时 所在页面路由地址字符串传递给登录页）</span><br>      router.<span class="hljs-title function_">replace</span>(<span class="hljs-string">`/login?redirect=<span class="hljs-subst">$&#123;router.currentRoute.fullPath&#125;</span>`</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>  &#125;<br>)<br></code></pre></td></tr></table></figure><h2 id="按钮的权限管理"><a href="#按钮的权限管理" class="headerlink" title="按钮的权限管理"></a>按钮的权限管理</h2><p>前提：用户登录时返回的数据中有一个权限标识数组，包含当前用户拥有的权限</p><p>实现：封装自定义指令绑定到按钮标签上，传入权限点标识，如果标签要传入的标识，在当前登录的用户权限标识数组中没有找到，就移除当前标签</p><p>inserted()是被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)，el是指令所绑定的标签，binding.value是指令绑定的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// @/dirctives/power.js</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/store&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; <span class="hljs-comment">// 自定义指令规则对象</span><br>  <span class="hljs-title function_">inserted</span>(<span class="hljs-params">el, binding</span>) &#123; <span class="hljs-comment">// 自定义指令固定名字配置项inserted(指令所在标签，第一次被插入到真实DOM网页上的时候，此函数自动执行)</span><br>    <span class="hljs-comment">// 参数1：指令所在的标签(原生)</span><br>    <span class="hljs-comment">// 参数2：指令关联的信息对象(包含给指令传入的值)</span><br>    <span class="hljs-keyword">const</span> points = store.<span class="hljs-property">state</span>.<span class="hljs-property">user</span>.<span class="hljs-property">userInfo</span>.<span class="hljs-property">roles</span>.<span class="hljs-property">points</span> <span class="hljs-comment">// 按钮权限点英文字符串数组</span><br>    <span class="hljs-keyword">if</span> (!points.<span class="hljs-title function_">includes</span>(binding.<span class="hljs-property">value</span>)) &#123;<br>      <span class="hljs-comment">// 如果标签要传入的标识，在当前登录的用户按钮权限点数组没有找到</span><br>      <span class="hljs-comment">// 就要把这个标签移出掉</span><br>      el.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(el)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// mian.js</span><br><span class="hljs-comment">// 注册全局指令</span><br><span class="hljs-keyword">import</span> powerObj <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/dirctives/power&#x27;</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;power&#x27;</span>, powerObj)<br><br>&lt;page-tools&gt;<br>  &lt;!-- 自定义左侧内容 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">slot-left</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>共 19 条记录<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br>  &lt;!-- 自定义右侧内容 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">slot-right</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">v-power</span>=<span class="hljs-string">&quot;&#x27;import&#x27;&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;danger&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;uploadBtnFn&quot;</span>&gt;</span>导入excel<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">v-power</span>=<span class="hljs-string">&quot;&#x27;export&#x27;&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;success&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;exportBtnFn&quot;</span>&gt;</span>导出excel<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addEmpBtnFn&quot;</span>&gt;</span>新增员工<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br>&lt;/page-tools&gt;<br></code></pre></td></tr></table></figure><h2 id="路由模式区别"><a href="#路由模式区别" class="headerlink" title="路由模式区别"></a>路由模式区别</h2><p>hash和history模式的实现原理</p><ul><li>hash：基于锚点，以及 onhashchange 事件，通过锚点的值作为路由地址，地址发生变化出发 onhashchange 事件，在根据路径决定页面上呈现的内容</li><li>history： 利用H5的 history中新增的两个API <code>history.pushState()</code> 和 <code>history.replaceState()</code>，允许开发者直接更改前端路由，即更新浏览器 URL 地址而不重新发起请求(将url替换并且不刷新页面)。</li></ul><p><code>history.pushState</code> 和 <code>history.push</code> 区别</p><ul><li><code>history.pushState()</code> 不会向服务器发送请求，只会改变浏览器地址栏中的地址，并且把地址记录到历史记录中，所以可以实现客户端路由，另外IE10 以后才支持</li><li><code>history.push()</code> 路径发生变化，需要向服务器发送请求</li></ul><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理可以有效、高速地处理从很小到非常大的项目版本管理。</p><h3 id="集中式和分布式是什么意思"><a href="#集中式和分布式是什么意思" class="headerlink" title="集中式和分布式是什么意思"></a>集中式和分布式是什么意思</h3><p><strong>集中式版本控制</strong></p><p>实际上是<strong>版本库集中存放在中央服务器中，个人电脑不包含版本库的修改记录</strong>（即只包含当前的修改，没有任何历史版本）；这样，工作的时候需要从版本库中获取最新的代码；工作工作结束后，需要将本地代码推送到中央服务器；</p><p>缺点： </p><ol><li>安全系数低：因为版本是集中存放的，所以一旦中央服务器出现问题，那么所有的历史版本将会丢失；</li><li>因为本地没有历史版本，所以集中式版本控制必须联网才能工作；就是需要经常地从中央服务器拉取代码或者推送到中央服务器，如果网速很慢，就很浪费时间；</li></ol><p><strong>分布式版本控制</strong></p><p>分布式版本控制的特点是没有中央服务器，<strong>每一台电脑都包含所有的历史版本</strong>；当两个人或者多个人合作的时候，只需要将自己的修改推送给对方就可以；</p><p>优势：</p><ol><li>不需要联网：自己的电脑就有所有的历史版本，当自己修改结束以后，直接修改自己本地的版本库即可；当多人合作的时候，隔一段时间相互推送即可；</li><li>不必担心历史版本丢失：因为每个人电脑中都包含所有的历史版本，因此，只要不是所有人的历史版本都丢失了，其他人只要从未丢失的人那里复制一份即可；</li></ol><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p>应用场景：</p><ol><li>当正在dev分支上开发某个项目，这时项目中出现一个bug，需要紧急修复，但是正在开发的内容只是完成一半，还不想提交，这时可以用git stash命令将修改的内容保存至堆栈区，然后顺利切换到hotfix分支进行bug修复，修复完成后，再次切回到dev分支，从堆栈中恢复刚刚保存的内容。</li><li>由于疏忽，本应该在dev分支开发的内容，却在master上进行了开发，需要重新切回到dev分支上进行开发，可以用git stash将内容保存至堆栈中，切回到dev分支后，再次恢复内容即可。</li><li>总的来说，git stash命令的作用就是将目前还不想提交的但是已经修改的内容进行保存至堆栈中，后续可以在某个分支上恢复出堆栈中的内容。stash中的内容不仅仅可以恢复到原先开发的分支，也可以恢复到其他任意指定的分支上。git stash作用的范围包括工作区和暂存区中的内容，也就是说没有提交的内容都会保存至堆栈中。</li></ol><p>git stash：能够将所有未提交的修改（工作区和暂存区）保存至堆栈中，用于后续恢复当前工作目录。</p><p>git stash list：查看当前stash中的内容</p><p>git stash pop：将当前stash中的内容弹出，并应用到当前分支对应的工作目录上。注：该命令将堆栈中最近保存的内容删除（栈是先进后出）。如果从stash中恢复的内容和当前目录中的内容发生了冲突，也就是说，恢复的内容和当前目录修改了同一行的数据，那么会提示报错，需要解决冲突，可以通过创建新的分支来解决冲突。</p><h1 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h1><h2 id="移动端项目"><a href="#移动端项目" class="headerlink" title="移动端项目"></a>移动端项目</h2><h3 id="组件缓存"><a href="#组件缓存" class="headerlink" title="组件缓存"></a>组件缓存</h3><p>问题：首页和个人中心页来回切换时，首页重复请求数据</p><p>需求：防止组件频繁创建和销毁；防止网络请求重复无用执行。</p><p>解决：使用keep-alive包裹一级路由挂载点和二级路由挂载点</p><p>bug：但发现<strong>搜索页面</strong>和<strong>详情页面</strong>多被缓存起来了 (多次进入不同的文章, 发现都是同一个文章详情)</p><p>原因：因为使用组件缓存，created里方法就不会重新执行请求数据</p><p>解决：对router-view使用exclude属性来区别, 哪些页面组件可以缓存(exclude里是组件的name名字)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">exclude</span>=<span class="hljs-string">&quot;Search,SearchResult,ArticleDetail,UserEdit&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 一级路由挂载点 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h3 id="头像和姓名优化"><a href="#头像和姓名优化" class="headerlink" title="头像和姓名优化"></a>头像和姓名优化</h3><p>使用keep-alive缓存组件后，出现一个问题，在User&#x2F;UserEdit.vue页面修改名称和头像回到User&#x2F;index.vue中头像名称还是原先的，因为页面组件缓存后，created()内的代码不会重新执行，不会再调用接口方法请求数据。</p><p>解决：当更改名称和头像后，将数据保存到vuex中，然后在页面标签上直接从vuex中拿到头像和名称，不在created里面请求接口</p><h3 id="登录未遂页面-刷新token"><a href="#登录未遂页面-刷新token" class="headerlink" title="登录未遂页面&#x2F;刷新token"></a>登录未遂页面&#x2F;刷新token</h3><p>当在某个页面时突然401，重新登录后回到之前的页面。</p><p>解决：当页面401时，通过router.currentPath拿到当前路径拼接到登录页面后面，然后跳转登录页，重新登录成功后，在Login&#x2F;index.vue中通过this.$router.query.path再跳转到该页面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">request.<span class="hljs-property">js</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>  <span class="hljs-keyword">return</span> response<br>&#125;, <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>  <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">401</span>) &#123;<br>    <span class="hljs-title function_">removeToken</span>()<br>    router.<span class="hljs-title function_">replace</span>(<span class="hljs-string">`/login?path=<span class="hljs-subst">$&#123;router.currentRoute.fullPath&#125;</span>`</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>&#125;)<br><span class="hljs-title class_">Login</span>/index.<span class="hljs-property">vue</span>中<br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">onSubmit</span> () &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">isLoading</span> = <span class="hljs-literal">true</span><br>      <span class="hljs-keyword">try</span> &#123;<br>    ......<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">replace</span>(&#123;<br>          <span class="hljs-attr">path</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">query</span>.<span class="hljs-property">path</span> || <span class="hljs-string">&#x27;/layout&#x27;</span><br>        &#125;)<br>      &#125; <br>        ......<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">request.<span class="hljs-property">js</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>  <span class="hljs-keyword">return</span> response<br>&#125;, <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>  <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">401</span>) &#123;<br>    <span class="hljs-comment">// 使用refresh_token换回新的token再继续使用，JS代码实现，用户无感知(效果好)</span><br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getNewTokenAPI</span>()<br>    <span class="hljs-title function_">setToken</span>(res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">token</span>)<br>    <span class="hljs-comment">// error.config就是上一次请求的配置对象</span><br>    error.<span class="hljs-property">config</span>.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;res.data.data.token&#125;</span>`</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">axios</span>(error.<span class="hljs-property">config</span>)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">500</span> &amp;&amp; error.<span class="hljs-property">config</span>.<span class="hljs-property">url</span> === <span class="hljs-string">&#x27;/v1_0/authorizations&#x27;</span> &amp;&amp; error.<span class="hljs-property">config</span>.<span class="hljs-property">method</span> === <span class="hljs-string">&#x27;put&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 刷新的refresh_token也过期了，</span><br>    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">clear</span>() <span class="hljs-comment">// 清除localStorage所有的token</span><br>    <span class="hljs-title class_">Notify</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;warning&#x27;</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;身份已过期，请重新登录&#x27;</span> &#125;)<br>    router.<span class="hljs-title function_">replace</span>(<span class="hljs-string">`/login?path=<span class="hljs-subst">$&#123;router.currentRoute.fullPath&#125;</span>`</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="首页-保存滚动条位置"><a href="#首页-保存滚动条位置" class="headerlink" title="首页-保存滚动条位置"></a>首页-保存滚动条位置</h3><p>在这保存了首页和我的页面切换滚动条位置</p><p>问题：首页滚动一些 点击我的再点击回来为何滚动条回到了顶部</p><p>疑惑：组件缓存keep-alive保存组件标签+样式+js变量，不会保存滚动位置</p><p>原因：切换到我的页面，页面不够高，没有滚动条(此滚动条是整个网页的滚动条)滚动位置会回到顶部 所以切换回首页只是内容改变了,滚动条还在顶部</p><p>解决1：在首页失去焦点(被切走的时候)，在它的路由对象meta中保存滚动位置（发现不能保存下来scrollTop）</p><ul><li>activated和deactivated是keep-alive特有的两个生命周期函数</li><li>window和document 监听网页滚动的事件</li><li>html标签获取scrollTop滚动的距离和设置滚动的位置</li></ul><p>解决2：当在首页时，在activated方法里面监听window滚动事件，调用scrollFn方法将当前html页面被卷去头部保存到路由对象meta中</p><p>当切换到我的页面，触发deactivated方法，当页面滚动时调用滚动方法scrollFn保存当前html网页被卷去的头部</p><p>再切换回首页时，再将路由对象中meta的scrollTop赋值给当前html页面被卷去头部</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">scrollFn</span> () &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">scrollT</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span><br>    &#125;<br>&#125;,<br>  <span class="hljs-title function_">activated</span> () &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">scrollFn</span>)<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">scrollT</span><br>  &#125;,<br>  <span class="hljs-title function_">deactivated</span> () &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">scrollFn</span>)<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="频道切换滚动位置保存"><a href="#频道切换滚动位置保存" class="headerlink" title="频道切换滚动位置保存"></a>频道切换滚动位置保存</h3><p>问题：频道切换(tab栏切换)没有进行路由切换，不走activated生命周期函数，滚动的位置保存不下来</p><p>解决：</p><ul><li><p>定义<code>channelScrollTObj</code>对象保存每个tab栏id和对应的滚动距离。</p></li><li><p>然后再滚动事件的函数中将当前页面滚动距离存到数组里面</p></li></ul><p>问题：但是首页tab栏切换时，滚动条位置还是不能保存，在tab栏切换的一瞬间<code>this.channelScrollTObj[this.channelId]=0</code></p><p>解决：当tab栏切换时，在van-tabs组件标签上绑定change事件，当tab栏切换时将<code>this.channelScrollTObj[this.channelId]</code>赋值给当前页面的滚动距离。</p><p>问题：但是tab栏切换时，会把切走的容器height设置为0，滚动条每页高度回到顶部，切回来的一瞬间没有高度，滚动事件从底下上来也被触发了，所以才把数据设置为0。</p><p>原因：</p><ul><li>切换的一瞬间先执行tab栏切换事件，再触发scrollFn方法。</li><li>但是在切换的一瞬间高度为0，将设置scrollTop不生效。</li></ul><p>解决：要代码慢点执行，当dom异步更新完成后再去执行这句代码，使用<code>this.$nextTick(()=&gt;&#123;&#125;)</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">data</span> () &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    ......<br>    <span class="hljs-attr">channelScrollTObj</span>: &#123;&#125; <span class="hljs-comment">// 保存每个频道的滚动位置 &#123;每个频道id：对应滚动距离&#125;</span><br>  &#125;<br>&#125;,<br><br>  <span class="hljs-title function_">scrollFn</span> () &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">scrollT</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span><br>    <span class="hljs-comment">// 同时保存当前频道的滚动距离</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">channelScrollTObj</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">channelId</span>] = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span><br>  &#125;<br>    <br>    &lt;van-tabs<br>      v-model=<span class="hljs-string">&quot;channelId&quot;</span><br>      @change=<span class="hljs-string">&quot;channelChangeFn&quot;</span><br>      animated<br>      sticky<br>      offset-top=<span class="hljs-string">&quot;1.226667rem&quot;</span><br>    &gt;<br>          <br><span class="hljs-title function_">activated</span> () &#123;<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">scrollFn</span>)<br>  <span class="hljs-comment">// 为了兼容不同手机</span><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">scrollT</span><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollTop</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">scrollT</span><br>&#125;,<br>    <br>  <span class="hljs-title function_">channelChangeFn</span> () &#123;<br>  <span class="hljs-comment">// tab切换时，这个组件内部会把切走的容器height设置为0，滚动条因为没有高度回到了顶部</span><br>  <span class="hljs-comment">// 切回来的一瞬间，没有高度，滚动事件从底下上来也被触发了，所以才把数据设置为0</span><br>  <span class="hljs-comment">// 切回来的一瞬间，没有高度，设置滚动位置也没有</span><br>    <span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">channelScrollTObj</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">channelId</span>]<br>    &#125;)<br>  &#125;,            <br></code></pre></td></tr></table></figure><h2 id="人资项目"><a href="#人资项目" class="headerlink" title="人资项目"></a>人资项目</h2><h3 id="页面访问权限控制"><a href="#页面访问权限控制" class="headerlink" title="页面访问权限控制"></a>页面访问权限控制</h3><p>实现思路：先将权限分配给角色，再将角色分配给员工</p><p>知识点：本项目中左侧侧边栏是通过路由对象渲染出来的</p><p>解决：当前登录用户的页面访问权限英文数组<code>userObj.roles.menus</code>动态添加到路由表中来渲染左侧侧边栏导航</p><ul><li>知识点：路由切换要匹配的路由规则对象数组存在于内存中</li><li>new Router时，有一些初始的路由规则对象</li><li>addRoutes会给路由表再额外增加一个路由规则</li><li>在Vuex中user.js模块中获取用户信息时，返回<code>userObj.roles.menus</code>(页面权限点英文字符串数组)</li><li>在路由前置守卫中用menus接收页面权限点数组</li><li>使用filter数组进行过滤动态路由表asyncRoutes(8个动态路由对象)</li><li>拿到每个路由对象的二级路由的name属性，<code>return menus.includes(routeName)</code></li><li>返回给filterList权限点数组中menus包含的routeName(即当前登录者拥有的权限列表，要渲染的侧边栏导航)</li><li>然后使用<code>router.addRoutes(filterList)</code>给路由表额外添加路由规则</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-title function_">async</span>(to, <span class="hljs-keyword">from</span>, next) =&gt; &#123;<br>  <span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">start</span>()<br>  <span class="hljs-keyword">const</span> token = store.<span class="hljs-property">getters</span>.<span class="hljs-property">token</span><br>  <span class="hljs-keyword">if</span> (token) &#123;<br>    <span class="hljs-keyword">if</span> (to.<span class="hljs-property">path</span> === <span class="hljs-string">&#x27;/login&#x27;</span>) &#123;<br>      <span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;/&#x27;</span>)<br>      <span class="hljs-comment">// 如果中断导航，需要自己关闭正常流程进度条</span><br>      <span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">done</span>()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">next</span>()<br>      <span class="hljs-keyword">if</span> (!store.<span class="hljs-property">getters</span>.<span class="hljs-property">name</span>) &#123;<br>        <span class="hljs-keyword">const</span> menus = <span class="hljs-keyword">await</span> store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;user/getUserInfoActions&#x27;</span>)<br>        <span class="hljs-comment">// 用menus权限点英文字符串和路由规则对象name匹配</span><br>        <span class="hljs-comment">// 把所有准备好的8个路由对象，取出，看看名字和menus里是否匹配，匹配就证明此登录的用户有这个页面的访问权限，就让filter收集此路由规则对象到新数组里</span><br>        <span class="hljs-keyword">const</span> filterList = asyncRoutes.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">routeObj</span> =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> routeName = routeObj.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>.<span class="hljs-title function_">toLowerCase</span>()<br>          <span class="hljs-keyword">return</span> menus.<span class="hljs-title function_">includes</span>(routeName)<br>        &#125;)<br>        filterList.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/404&#x27;</span>, <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span> &#125;)<br>        router.<span class="hljs-title function_">addRoutes</span>(filterList)<br>        store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;permission/setRoutes&#x27;</span>, filterList)<br>        <span class="hljs-title function_">next</span>(&#123;<br>          <span class="hljs-attr">path</span>: to.<span class="hljs-property">path</span>,<br>          <span class="hljs-attr">replace</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 不让回退 类似于this.$router.replace()</span><br>        &#125;)<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果没有登录</span><br>    <span class="hljs-keyword">if</span> (whiteList.<span class="hljs-title function_">includes</span>(to.<span class="hljs-property">path</span>)) &#123; <span class="hljs-comment">// 要去的路由地址字符串是否在白名单数组里出现</span><br>      <span class="hljs-comment">// 如果出现过放行</span><br>      <span class="hljs-title function_">next</span>()<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 去别的页面不放行，并跳转登录页</span><br>      <span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;/login&#x27;</span>)<br>      <span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">done</span>()<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>bug：登录后左侧只有首页选项，没有用户拥有的其他权限页面</p><p>原因：layout&#x2F;components&#x2F;Sidebar&#x2F;index.vue中，computed计算属性中routes数组(动态生成左边侧边栏导航)，是获取的<code>this.$router.options.routes</code>值，但是this.$router.options.routes是一次性的，只能拿到new VueRouter时配置项里routes数组(静态路由数组)，后续addRoutes添加的路由规则对象没有影响到这里，所以登录进入左侧侧边栏导航只有首页。</p><p>解决：在permission.js文件中存一份用户权限列表filterList给vuex中src&#x2F;store&#x2F;modules&#x2F;permission.js，然后在layout&#x2F;components&#x2F;Sidebar&#x2F;index.vue中routes使用this.$store.state.permission.routes从vuex中取值，又因为routes是计算属性，当依赖值发生变化时就会重新计算属性的值，然后重新渲染左侧侧边栏导航。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; constantRoutes &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/router&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">routes</span>: constantRoutes <span class="hljs-comment">// vuex中保存的静态数组</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123;<br>    <span class="hljs-title function_">setRoutes</span>(<span class="hljs-params">state, asyncRoutes</span>) &#123;<br>      state.<span class="hljs-property">routes</span> = [...constantRoutes, ...asyncRoutes]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//permission.js 路由前置守卫中</span><br>store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;permission/setRoutes&#x27;</span>, filterList)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">layout/components/<span class="hljs-title class_">Sidebar</span>/index.<span class="hljs-property">vue</span>中 <br>  <span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-title function_">routes</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// return this.$router.options.routes</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">permission</span>.<span class="hljs-property">routes</span><br>    &#125;,<br></code></pre></td></tr></table></figure><p>bug：为何动态路由添加后，在动态路由地址刷新会跳转到404页面</p><p>原因：刷新页面时，刷新时所有代码都会重新执行，回归初始化；刷新时，路由从’&#x2F;‘跳转到当前地址栏地址，会走一次路由守卫的代码，动态路由还未添加，所以404。</p><p>解决：将静态路由表中的404路由对象注释，在全局路由前置守卫中，将404路由对象push到筛选后的路由对象数组中</p><p>bug：路由规则对象添加成功，但是登录出现白屏</p><p>原因：上面next()放行时，动态路由还没有加入到内存的路由表中</p><p>解决： 添加完动态路由后，立刻再跳转一次</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">next</span>() <span class="hljs-comment">// 注释掉静态路由表中的404页面路由对象再执行next()放行时出现白屏</span><br>   <span class="hljs-keyword">if</span> (!store.<span class="hljs-property">getters</span>.<span class="hljs-property">name</span>) &#123;<br>     <span class="hljs-keyword">const</span> menus = <span class="hljs-keyword">await</span> store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;user/getUserInfoActions&#x27;</span>)<br>     <span class="hljs-keyword">const</span> filterList = asyncRoutes.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">routeObj</span> =&gt;</span> &#123;<br>       <span class="hljs-keyword">const</span> routeName = routeObj.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>.<span class="hljs-title function_">toLowerCase</span>()<br>       <span class="hljs-keyword">return</span> menus.<span class="hljs-title function_">includes</span>(routeName)<br>     &#125;)<br>     filterList.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/404&#x27;</span>, <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span> &#125;)<br>     router.<span class="hljs-title function_">addRoutes</span>(filterList)<br>     store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;permission/setRoutes&#x27;</span>, filterList)<br>     <span class="hljs-title function_">next</span>(&#123;<br>       <span class="hljs-attr">path</span>: to.<span class="hljs-property">path</span>,<br>       <span class="hljs-attr">replace</span>: <span class="hljs-literal">true</span><br>     &#125;)<br>   &#125;<br></code></pre></td></tr></table></figure><p>bug：退出登录后重新登录提示重复的路由对象定义</p><p>原因：</p><p>退出登录后重新登录页面并没刷新，完全依赖路由业务场景的切换(单页面应用好处：用户体验更好，切换业务场景更快)，内存里路由表中之前添加的筛选后路由规则对象还在</p><p>而退出登录时，把token和用户信息清除了，登录的时候，先获取到token保存到vuex和本地，然后才是跳转路由，才执行路由守卫，所有判断token有值，但是用户信息没有，重新请求，再重新添加一遍筛选后的路由对象，所以导致路由重复了</p><p>解决方案：在退出时让路由表回归初始化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">router/index.<span class="hljs-property">js</span>中<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">resetRouter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> newRouter = <span class="hljs-title function_">createRouter</span>()<br>  router.<span class="hljs-property">matcher</span> = newRouter.<span class="hljs-property">matcher</span> <span class="hljs-comment">// reset router</span><br>  <span class="hljs-comment">// 重置的是路由对象内部的match方法(匹配routes选项中的路由规则的)</span><br>  <span class="hljs-comment">// match里面会使用newRouter里routes一起代替掉</span><br>&#125;<br>在store/modules/user.<span class="hljs-property">js</span>的actions退出方法中调用<br>  <span class="hljs-title function_">logoutActions</span>(<span class="hljs-params">&#123; commit &#125;</span>) &#123;<br>    <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;REMOVE_TOKEN&#x27;</span>)<br>    <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;REMOVE_USER&#x27;</span>)<br>    <span class="hljs-title function_">resetRouter</span>()<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="按钮操作权限"><a href="#按钮操作权限" class="headerlink" title="按钮操作权限"></a>按钮操作权限</h3><p>判断：当前登录的用户是否拥有导入Excel和导出Excel的权限</p><p>思路：获取的用户基本资料中有roles数组包含按钮操作权限数组points，如果包含权限点标识’import’或’export’就渲染处导入Excel和导出Excel按钮</p><p>解决：</p><p>封装自定义指令v-power，使用inserted(el,binding)函数，拿到Vuex中存储的用户按钮权限点英文字符数组points，如果points不包含指令传入的权限点标识’import’或’export’，就将对应的el-button按钮移出。</p><p>参数1：el是指令所绑定的元素，可以用来直接操作DOM</p><p>参数2：binding是一个对象，包含着name指令名、value指令绑定的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/store&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; <span class="hljs-comment">// 自定义指令规则对象</span><br>  <span class="hljs-title function_">inserted</span>(<span class="hljs-params">el, binding</span>) &#123; <span class="hljs-comment">// 自定义指令固定名字配置项inserted(指令所在标签，第一次被插入到真实DOM网页上的时候，此函数自动执行)</span><br>    <span class="hljs-comment">// 参数1：指令所在的标签(原生)</span><br>    <span class="hljs-comment">// 参数2：指令关联的信息对象(包含给指令传入的值)</span><br>    <span class="hljs-keyword">const</span> points = store.<span class="hljs-property">state</span>.<span class="hljs-property">user</span>.<span class="hljs-property">userInfo</span>.<span class="hljs-property">roles</span>.<span class="hljs-property">points</span> <span class="hljs-comment">// 按钮权限点英文字符串数组</span><br>    <span class="hljs-keyword">if</span> (!points.<span class="hljs-title function_">includes</span>(binding.<span class="hljs-property">value</span>)) &#123;<br>      <span class="hljs-comment">// 如果标签要传入的标识，在当前登录的用户按钮权限点数组没有找到</span><br>      <span class="hljs-comment">// 就要把这个标签移出掉</span><br>      el.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(el)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;page-tools&gt;<br>  &lt;!-- 自定义左侧内容 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">slot-left</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>共 19 条记录<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br>  &lt;!-- 自定义右侧内容 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">slot-right</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">v-power</span>=<span class="hljs-string">&quot;&#x27;import&#x27;&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;danger&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;uploadBtnFn&quot;</span>&gt;</span>导入excel<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">v-power</span>=<span class="hljs-string">&quot;&#x27;export&#x27;&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;success&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;exportBtnFn&quot;</span>&gt;</span>导出excel<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addEmpBtnFn&quot;</span>&gt;</span>新增员工<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br>&lt;/page-tools&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue3学习</title>
    <link href="/2023/05/13/Vue3%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/05/13/Vue3%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="项目安装启动"><a href="#项目安装启动" class="headerlink" title="项目安装启动"></a>项目安装启动</h2><h3 id="通过命令配置淘宝镜像"><a href="#通过命令配置淘宝镜像" class="headerlink" title="通过命令配置淘宝镜像"></a>通过命令配置淘宝镜像</h3><p>切换为淘宝镜像命令（安装一些package容易报错）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">npm config set registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><p>查看当前使用的镜像地址命令</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">npm config get registry<br></code></pre></td></tr></table></figure><p>如果返回 <code>https://registry.npm.taobao.org</code>，说明镜像配置成功。</p><h3 id="切换回原镜像"><a href="#切换回原镜像" class="headerlink" title="切换回原镜像"></a>切换回原镜像</h3><p>安装一些package不容易报错</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">npm config set registry https://registry.npmjs.org<br>npm config set registry https://registry.npmjs.org<br></code></pre></td></tr></table></figure><h3 id="Vue3项目创建"><a href="#Vue3项目创建" class="headerlink" title="Vue3项目创建"></a>Vue3项目创建</h3><p>使用Vue3专用脚手架create-vue创建项目</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">npm init vue@latest<br>//<br>yarn create vue<br></code></pre></td></tr></table></figure><p>安装依赖</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">npm i<br></code></pre></td></tr></table></figure><p>启动项目</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">npm run dev<br></code></pre></td></tr></table></figure><h2 id="组合式API"><a href="#组合式API" class="headerlink" title="组合式API"></a>组合式API</h2><h3 id="setup选项"><a href="#setup选项" class="headerlink" title="setup选项"></a>setup选项</h3><p>setup选项执行时机是在beforeCreate钩子之前，自动执行</p><p>需要在setup()方法中定义数据和函数，然后以对象的形式return</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setup&#x27;</span>,<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-keyword">const</span> message = <span class="hljs-string">&#x27;Hello world&#x27;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">logMessage</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<br>      message,<br>      logMessage<br>    &#125;<br>  &#125;,<br>  <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeCreate&#x27;</span>);<br>   &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="组合式API-1"><a href="#组合式API-1" class="headerlink" title="组合式API"></a>组合式API</h3><p>setup选项的语法糖，可以更简单使用组合式API</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setup&#x27;</span>, <span class="hljs-variable language_">this</span>);<br><span class="hljs-keyword">const</span> message = <span class="hljs-string">&#x27;Hello world&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">logMessage</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>并且setup中的this不指向组件实例，指向undefined</p><h3 id="reactive和ref函数"><a href="#reactive和ref函数" class="headerlink" title="reactive和ref函数"></a>reactive和ref函数</h3><p>reactive() 作用：接收对象类型数据的参数传入，并返回一个响应式的对象</p><p>ref() 作用：接收简单类型或对象类型数据的参数传入，并返回一个响应式的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-comment">// 1.导入函数</span><br><span class="hljs-comment">// import &#123; reactive &#125; from &#x27;vue&#x27;;</span><br><span class="hljs-comment">// 2.执行函数，传入一个对象类型的参数，变量接收</span><br><span class="hljs-comment">// const state = reactive(&#123; count: 0 &#125;)</span><br><span class="hljs-comment">// const setCount = () =&gt; &#123;</span><br><span class="hljs-comment">//   state.count++</span><br><span class="hljs-comment">//  &#125;</span><br><span class="hljs-comment">// 1.导入函数</span><br><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-comment">// 2.执行函数，传入一个对象类型的参数，变量接收</span><br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">setCount</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-comment">// 脚本区域修改ref产生的响应式对象数据 必须通过.value属性</span><br>  state.<span class="hljs-property">value</span>++<br> &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>reactive和ref对比</p><ol><li>reactive不能处理简单类型的数据</li><li>ref参数支持更好但是必须通过.value访问修改</li><li>ref函数的内部实现依赖于reactive函数</li></ol><h3 id="计算属性computed"><a href="#计算属性computed" class="headerlink" title="计算属性computed"></a>计算属性computed</h3><p>计算属性不应该有副作用：即除计算数据以外的其他操作，如异步请求&#x2F;修改dom</p><p>避免直接修改计算属性的值，计算属性是只读的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; ref,computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">const</span> list=<span class="hljs-title function_">ref</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>])<br><span class="hljs-keyword">const</span> computedList = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123; <br>  <span class="hljs-keyword">return</span> list.<span class="hljs-property">value</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>item&gt;<span class="hljs-number">2</span>)<br>&#125;)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  list.<span class="hljs-property">value</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">9</span>,<span class="hljs-number">10</span>)<br> &#125;,<span class="hljs-number">3000</span>)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="wacth函数"><a href="#wacth函数" class="headerlink" title="wacth函数"></a>wacth函数</h3><p>作用：侦听一个或多个数据的变化，数据变化时执行回调函数</p><p>额外参数：</p><ol><li>immediate立即执行：在侦听器创建时立刻出发回调</li><li>deep深度侦听：watch侦听ref对象默认是浅层侦听的，直接修改嵌套的对象属性不会触发回调执行</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 监听单个变量</span><br>&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; ref, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">setCount</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  count.<span class="hljs-property">value</span>++<br>&#125;<br><span class="hljs-title function_">watch</span>(count, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;count变化了&#x27;</span>);<br>&#125;, &#123;<br>  <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span><br>&#125;)<br>&lt;/script&gt;<br><br><br><span class="hljs-comment">// 监听多个个变量</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> name = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;cj&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">setCount</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  count.<span class="hljs-property">value</span>++</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">setName</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  name.<span class="hljs-property">value</span> = name.<span class="hljs-property">value</span> + <span class="hljs-string">&#x27;cjzm&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">watch</span>([count,name], <span class="hljs-function">(<span class="hljs-params">[newCount, newName],[oldCount, oldName]</span>) =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newCount, oldCount);</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newName, oldName);</span></span><br><span class="language-javascript"><span class="language-xml">&#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><br><span class="hljs-comment">// 监听对象中属性的变化</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">ref</span>(&#123;<span class="hljs-attr">count</span>:<span class="hljs-number">0</span>&#125;)</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">setCount</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  state.<span class="hljs-property">value</span>.<span class="hljs-property">count</span>++</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">watch</span>(state, <span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;count变化了&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">&#125;, &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>如果想要只侦听state对象中的age属性，可以将第一个参数改为箭头函数，指向要监听的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; ref, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">ref</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">setCount</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  state.<span class="hljs-property">value</span>.<span class="hljs-property">count</span>++<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">setAge</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  state.<span class="hljs-property">value</span>.<span class="hljs-property">age</span> = <span class="hljs-number">24</span><br>&#125;<br><span class="hljs-title function_">watch</span>(<br>  <span class="hljs-function">() =&gt;</span> state.<span class="hljs-property">value</span>.<span class="hljs-property">age</span>,<br>  <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;age变化了&#x27;</span>); &#125;<br>)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="Vue3生命周期函数"><a href="#Vue3生命周期函数" class="headerlink" title="Vue3生命周期函数"></a>Vue3生命周期函数</h3><table><thead><tr><th align="center">选项式API</th><th align="center">组合式API</th></tr></thead><tbody><tr><td align="center"><strong>beforeCreate&#x2F;created</strong></td><td align="center"><strong>setup</strong></td></tr><tr><td align="center">beforeMount</td><td align="center">onBeforeMount</td></tr><tr><td align="center">mounted</td><td align="center">onMounted</td></tr><tr><td align="center">beforeUpdate</td><td align="center">onBeforeUpdate</td></tr><tr><td align="center">updated</td><td align="center">onUpdate</td></tr><tr><td align="center"><strong>beforeUnmount</strong></td><td align="center"><strong>onBeforeUnmount</strong></td></tr><tr><td align="center"><strong>unmounted</strong></td><td align="center"><strong>onUnmounted</strong></td></tr></tbody></table><p>生命周期函数可以执行多次，多次执行传入的回调会在时机成熟时<strong>依次执行</strong></p><ul><li><strong>setup</strong>：实在beforeCreate和created阶段之前触发的钩子函数</li><li><strong>onBeforeMount</strong>：注册一个钩子，在组件被挂载之前被调用。</li><li><strong>onMounted</strong>：注册一个回调函数，在组件挂载完成后执行。</li><li><strong>onBeforeUpdate</strong>：注册一个钩子，在组件即将因为响应式状态变更而更新其 DOM 树之前调用。</li><li><strong>onUpdate</strong>：注册一个回调函数，在组件因为响应式状态变更而更新其 DOM 树之后调用。</li><li><strong>onBeforeUnmount</strong>：注册一个钩子，在组件实例被卸载之前调用。</li><li><strong>onUnmounted</strong>：注册一个回调函数，在组件实例被卸载之后调用。</li></ul><h3 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h3><h4 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h4><p>父组件中给子组件绑定属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> son <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./son.vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">200</span>)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  count.<span class="hljs-property">value</span>=<span class="hljs-number">2000</span><br> &#125;,<span class="hljs-number">3000</span>)<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>父组件<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">son</span> <span class="hljs-attr">message</span>=<span class="hljs-string">&quot;father message&quot;</span> <span class="hljs-attr">:count</span>=<span class="hljs-string">&quot;count&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">son</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>子组件中通过props选项接收：通过宏函数defineProps({属性名: 类型})</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-keyword">const</span> props=<span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">message</span>: <span class="hljs-title class_">String</span>,<br>  <span class="hljs-attr">count</span>:<span class="hljs-title class_">Number</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(props);<br>&lt;/script&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;son&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>子组件<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>父组件传入的数据： &#123;&#123; message &#125;&#125;----&#123;&#123;count&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h4><p>父组件中给子组件标签通过@绑定事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> son1 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./son1.vue&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getMessage</span>=(<span class="hljs-params">msg</span>)=&gt;&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg);<br> &#125;<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>父组件<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 1.绑定自定义事件 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">son1</span> @<span class="hljs-attr">getSonMessage</span>=<span class="hljs-string">&quot;getMessage&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">son1</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>子组件内部通过$emit方法出触发事件：通过宏函数defineEmits([‘自定义事件名’])</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-comment">// 2.通过defineEmits()拿到emit方法</span><br><span class="hljs-keyword">const</span> emit =<span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;getSonMessage&#x27;</span>])<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">sendMsg</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-comment">// 3.触发自定义事件，传数据给父组件</span><br>  <span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;getSonMessage&#x27;</span>,<span class="hljs-string">&#x27;this is son message&#x27;</span>)<br> &#125;<br>&lt;/script&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;son&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>子组件<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sendMsg&quot;</span>&gt;</span>触发自定义事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="模板引用"><a href="#模板引用" class="headerlink" title="模板引用"></a>模板引用</h3><p>通过ref标识获取真实的dom对象或组件实例对象，在onMounted()生命周期函数中获取ref</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> son1 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./son1.vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; ref,onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">const</span> h2ref = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<br><span class="hljs-keyword">const</span> son1ref = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<br><span class="hljs-title function_">onMounted</span>(<span class="hljs-function">()=&gt;</span>&#123; <br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(h2ref.<span class="hljs-property">value</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(son1ref.<span class="hljs-property">value</span>);<br>&#125;)<br>&lt;/script&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;h2ref&quot;</span>&gt;</span>父组件<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 1.绑定自定义事件 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">son1</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;son1ref&quot;</span> @<span class="hljs-attr">getSonMessage</span>=<span class="hljs-string">&quot;getMessage&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">son1</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;;<br>const name = ref(&#x27;son1&#x27;)<br>const setName = () =&gt; &#123;<br>  name.value=&#x27;son2&#x27;<br>&#125;<br>defineExpose(&#123;<br>  name,setName<br>&#125;)<br>&lt;/script&gt;<br>&lt;template&gt;<br>  &lt;div class=&quot;son&quot;&gt;<br>    &lt;h2&gt;子组件&lt;/h2&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>并且默认情况下setup语法糖下组件内部的属性和方法是不开放给父组件访问的，可以通过defineExpose编译宏指定那些属性和方法允许访问</p><h3 id="provide和reject"><a href="#provide和reject" class="headerlink" title="provide和reject"></a>provide和reject</h3><p>作用：顶层组件向任意的底层组件传递数据和方法，实现跨层组件通信</p><p>跨层传递普通数据</p><ol><li><p>顶层组件通过provide函数提供数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;key&#x27;</span>, 顶层组件中的数据)<br></code></pre></td></tr></table></figure></li><li><p>底层组件通过inject函数获取数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> message=<span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;key&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ol><p>跨层传递方法</p><p>顶层组件可以向底层组件传递方法，底层组件调用方法修改顶层组件中的数据</p><p>在不破坏单向数据流的前提下修改顶层组件的数据，谁的数据谁修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">setCount</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  count.<span class="hljs-property">value</span>++<br>&#125;<br><span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;funtion-key&#x27;</span>, setCount)<br><br><span class="hljs-keyword">const</span> setCount = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;funtion-key&#x27;</span>)<br>    &lt;button @click=<span class="hljs-string">&quot;setCount&quot;</span>&gt;修改顶层数据&lt;/button&gt;<br></code></pre></td></tr></table></figure><h2 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h2><h3 id="TS简介"><a href="#TS简介" class="headerlink" title="TS简介"></a>TS简介</h3><p>Type+JavaScript，在JS基础上，为JS添加了类型支持</p><p>TS是JavaScript的超集</p><p>JS是弱类型语言，TS是强类型语言</p><p><strong>强类型语言</strong>是一种强制类型定义的语言，一旦某一个变量被定义类型，如果不经过强制转换，则它永远就是该数据类型了，强类型语言包括Java、.net 、Python、C++等语言。</p><p><strong>弱类型语言</strong>是一种弱类型定义的语言，某一个变量被定义类型，该变量可以根据环境变化自动进行转换，不需要经过显性强制转换。弱类型语言包括vb、PHP、javascript等语言。</p><ul><li><p>从编程语言的动静来区分，<strong>TypeScript 属于静态类型的编程语言</strong>，<strong>JavaScript 属于动态类型的编程语言</strong> </p></li><li><ul><li>静态类型：<strong>编译</strong>期做类型检查</li><li>动态类型：<strong>执行</strong>期做类型检查</li></ul></li><li><p>代码编译和代码执行的顺序：1 编译 2 执行</p></li><li><p>对于 JS 来说：需要等到代码真正去执行的时候才能发现错误（晚）</p></li><li><p>对于 TS 来说：在代码编译的时候（代码执行前）就可以发现错误（早）</p></li></ul><h3 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">let</span> num = <span class="hljs-number">18</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span>= <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><ul><li>说明：代码中的 <code>: number</code> 就是<strong>类型注解</strong></li><li>作用：<strong>为变量添加类型约束</strong>。比如，上述代码中，约定变量 age 的类型为 number 类型</li><li>解释：<strong>约定了什么类型，就只能给变量赋值该类型的值，否则，就会报错</strong></li><li>约定了类型之后，代码的提示就会非常的清晰</li></ul><h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><p>在 TS 中，某些没有明确指出类型的地方，<strong>TS 的类型推论机制会帮助提供类型</strong> 换句话说：由于类型推论的存在，有些场合下的类型注解可以省略不写</p><p>发生类型推论的 2 种常见场景: </p><ol><li>声明变量并初始化时</li><li>决定函数返回值时</li></ol><h3 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// 格式1：数组名：类型[] = [值，...]</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-comment">// 格式2：数组名：Array&lt;类型&gt; = [值，...]</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr1</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt; = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>]<br></code></pre></td></tr></table></figure><h3 id="定义联合类型"><a href="#定义联合类型" class="headerlink" title="定义联合类型"></a>定义联合类型</h3><p><code>|</code>（竖线）在 TS 中叫做<strong>联合类型</strong>，即：由两个或多个其他类型组成的类型，表示可以是这些类型中的任意一种</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// x既可以是number也可以是string类型数据</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: (<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>) = <span class="hljs-string">&#x27;a&#x27;</span><br>x = <span class="hljs-number">100</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>: (<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>)[] = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;d&#x27;</span>)<br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">5</span>)<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>: (<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>)[] = []<br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;d&#x27;</span>)<br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>定义 type 别名 &#x3D; 类型，也可以自定义类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">type</span> s = <span class="hljs-built_in">string</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">str</span>: s = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">boolean</span> | <span class="hljs-built_in">number</span>) = <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-comment">// 定义自定义类型</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyType</span> = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">boolean</span> | <span class="hljs-built_in">number</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">y</span>: <span class="hljs-title class_">MyType</span> = <span class="hljs-literal">false</span><br><span class="hljs-keyword">export</span> &#123; &#125;<br></code></pre></td></tr></table></figure><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// 普通函数 </span><br><span class="hljs-keyword">function</span> 函数名(形参<span class="hljs-number">1</span>： 类型=默认值， 形参<span class="hljs-number">2</span>：类型=默认值): 返回值类型 &#123; &#125;  <br><span class="hljs-comment">// 如果它可以推论出来，可以省略返回值类型</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">100</span></span>): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br><br><span class="hljs-comment">// 箭头函数 </span><br><span class="hljs-keyword">const</span> 函数名（形参<span class="hljs-number">1</span>: 类型=默认值, 形参<span class="hljs-number">2</span>: 类型=默认值):返回值类型 =&gt; &#123; &#125;<br><span class="hljs-keyword">const</span> f1 = (<span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span> &#123; <span class="hljs-keyword">return</span> a + b &#125;<br><br><span class="hljs-comment">// 定义自定义类型 只适用于箭头函数</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyFunc</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">f3</span>: <span class="hljs-title class_">MyFunc</span> = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123; <span class="hljs-keyword">return</span> a + b &#125;<br></code></pre></td></tr></table></figure><h4 id="如果函数没有返回值，就设置为void类型"><a href="#如果函数没有返回值，就设置为void类型" class="headerlink" title="如果函数没有返回值，就设置为void类型"></a>如果函数没有返回值，就设置为void类型</h4><ul><li>不写return</li><li>写return，但是后面不接内容</li><li>写return undefined</li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// 普通函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f4</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;f&#x27;</span>)<br>&#125;<br><span class="hljs-comment">// 箭头函数</span><br><span class="hljs-keyword">const</span> f5 = (): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;f&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyFn</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">f6</span>: <span class="hljs-title class_">MyFn</span> = <span class="hljs-function">() =&gt;</span> &#123; &#125;<br></code></pre></td></tr></table></figure><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>如果想要一个参数是可选的，就在形参后面加个?，这个参数就可传可不传</p><p>并且可选参数和默认值不能同时写</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"><span class="hljs-attr">a</span>?: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>?: <span class="hljs-built_in">number</span></span>) =&gt; &#123;<br>        <span class="hljs-keyword">return</span> a + b<br>    &#125;<br>    <span class="hljs-title function_">fn</span>()<br>    <span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="定义的对象"><a href="#定义的对象" class="headerlink" title="定义的对象"></a>定义的对象</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&#123;<br>    <span class="hljs-comment">// 格式：对象名：&#123;属性名: 类型&#125;= &#123;属性名: 值，...&#125;</span><br>    <span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">obj1</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> &#125; = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;<br>    obj1.<span class="hljs-property">age</span> = <span class="hljs-number">28</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">obj2</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> &#125; = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;ls&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">ObjType</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">address</span>: <span class="hljs-built_in">number</span> &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">obj3</span>: <span class="hljs-title class_">ObjType</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;ws&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">28</span>, <span class="hljs-attr">address</span>: <span class="hljs-number">8</span> &#125;<br>    obj3.<span class="hljs-property">age</span> = <span class="hljs-number">29</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"><span class="hljs-attr">g</span>: <span class="hljs-title class_">ObjType</span></span>) =&gt; &#123;<br>        g.<span class="hljs-property">address</span> = <span class="hljs-number">16</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果对象中要求写方法</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tsx">   <span class="hljs-comment">// 格式：对象名：&#123;属性名: 类型; 方法名: () =&gt; 返回值类型; 方法名():返回值类型&#125;= &#123;属性名: 值，...&#125;</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">ObjType</span> = &#123;<br>       <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>       <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>,<br>       <span class="hljs-attr">address</span>: <span class="hljs-built_in">number</span>,<br>       <span class="hljs-attr">hello</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>,<br>       <span class="hljs-title function_">say</span>():<span class="hljs-built_in">void</span><br>   &#125;<br>   <span class="hljs-keyword">let</span> <span class="hljs-attr">obj3</span>: <span class="hljs-title class_">ObjType</span> = &#123;<br>       <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;ws&#x27;</span>,<br>       <span class="hljs-attr">age</span>: <span class="hljs-number">28</span>,<br>       <span class="hljs-attr">address</span>: <span class="hljs-number">8</span>,<br>       <span class="hljs-attr">hello</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;abc&#x27;</span> &#125;,<br>       <span class="hljs-attr">say</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>对象的可选属性，在属性后面加个?</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Student</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">score</span>?: <span class="hljs-built_in">number</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>,<br>    <span class="hljs-attr">study</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>,<br>    <span class="hljs-attr">play</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span><br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">s1</span>: <span class="hljs-title class_">Student</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">26</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;男&#x27;</span>,<br>    <span class="hljs-comment">// score: 99,</span><br>    <span class="hljs-attr">height</span>: <span class="hljs-number">178</span>,<br>    <span class="hljs-attr">study</span>: <span class="hljs-function">() =&gt;</span> &#123; &#125;,<br>    <span class="hljs-attr">play</span>: <span class="hljs-function">() =&gt;</span> &#123; &#125;<br>&#125;<br><span class="hljs-keyword">export</span> &#123; &#125;<br></code></pre></td></tr></table></figure><h3 id="接口类型interface"><a href="#接口类型interface" class="headerlink" title="接口类型interface"></a>接口类型interface</h3><p>当一个对象类型被多次使用时，一般会使用接口（<code>interface</code>）来描述对象的类型，达到复用的目的</p><ul><li>解释：</li></ul><ol><li><ol><li>使用 <code>interface</code> 关键字来声明接口</li><li>接口名称(比如，此处的 IPerson)，可以是任意合法的变量名称，推荐以 <code>I</code> 开头</li><li>声明接口后，直接使用接口名称作为变量的类型</li><li>因为每一行只有一个属性类型，因此，属性类型后没有 ;(分号)</li></ol></li></ol><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IStudent</span>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">gender</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">score</span>?: <span class="hljs-built_in">number</span>, <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>,<br>    <span class="hljs-attr">study</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>, <span class="hljs-attr">play</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span><br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">s1</span>: <span class="hljs-title class_">IStudent</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">26</span>, <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-comment">// score: 99,</span><br>    <span class="hljs-attr">height</span>: <span class="hljs-number">178</span>, <span class="hljs-attr">study</span>: <span class="hljs-function">() =&gt;</span> &#123; &#125;, <span class="hljs-attr">play</span>: <span class="hljs-function">() =&gt;</span> &#123; &#125;<br>&#125;<br><span class="hljs-keyword">export</span> &#123; &#125;<br></code></pre></td></tr></table></figure><h4 id="interface和type的区别"><a href="#interface和type的区别" class="headerlink" title="interface和type的区别"></a>interface和type的区别</h4><ul><li>interface只能定义对象，type不限于对象，也可自定义其他的类型</li><li>interface可以继承，type不可以继承</li></ul><h4 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h4><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPoint2D</span> &#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>,<br>    <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">p1</span>: <span class="hljs-title class_">IPoint2D</span> = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">50</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">30</span> &#125;<br><span class="hljs-comment">// interface 接口1 extends 接口2 &#123;</span><br><span class="hljs-comment">//     接口1自己的类型</span><br><span class="hljs-comment">//  &#125;</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPoint3D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IPoint2D</span> &#123;<br>    <span class="hljs-attr">z</span>:<span class="hljs-built_in">number</span><br> &#125;<br><span class="hljs-comment">// 此时IPoint3D接口如下</span><br><span class="hljs-comment">// interface IPoint3D &#123;</span><br><span class="hljs-comment">//     x: number,</span><br><span class="hljs-comment">//     y: number,</span><br><span class="hljs-comment">//     z: number</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">p2</span>: <span class="hljs-title class_">IPoint3D</span> = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">30</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">40</span> &#125;<br></code></pre></td></tr></table></figure><h3 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h3><p>元组：一种特殊的数组，约定了元素的个数和对应的类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&#123;<br>    <span class="hljs-comment">// 比如地图经纬度</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">position</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">121.1324</span>, <span class="hljs-number">134.1234</span>]<br>    <span class="hljs-comment">// number[] 只能表示一个数组，元素是number类型</span><br>    <span class="hljs-comment">// 需求：一个数组，两个元素，第一个是数值，第二个也是数值</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">c1</span>: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-number">123</span>, <span class="hljs-number">87</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// let str1=&#x27;Hello TS&#x27;</span><br><span class="hljs-comment">// str1是string类型</span><br><span class="hljs-comment">// const str2 = &#x27;Hello TS&#x27;</span><br><span class="hljs-comment">// str2是&#x27;Hello TS&#x27;类型，就是字面量类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">str1</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Hello TS&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">str2</span>: <span class="hljs-string">&#x27;Hello TS&#x27;</span> = <span class="hljs-string">&#x27;Hello TS&#x27;</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyType1</span> = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyType2</span> = <span class="hljs-string">&#x27;Hello TS&#x27;</span> | <span class="hljs-number">100</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">m1</span>: <span class="hljs-title class_">MyType2</span> = <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>字面量类型单独没有使用场景<br> 一般和联合类型一起使用，表示多个固定的值中取一个</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">type</span> gender = <span class="hljs-string">&#x27;男&#x27;</span> | <span class="hljs-string">&#x27;女&#x27;</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">s1</span>:gender=<span class="hljs-string">&#x27;女&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>枚举的功能类似于<strong>字面量类型+联合类型组合</strong>的功能，也可以表示一组明确的可选值</p><p>枚举：定义一组命名常量。它描述一个值，该值可以是这些命名常量中的一个</p><ol><li>使用 <code>enum</code> 关键字定义枚举</li><li>约定枚举名称以大写字母开头</li><li>枚举中的多个值之间通过 <code>,</code>（逗号）分隔</li><li>定义好枚举后，直接使用枚举名称作为类型注解</li></ol><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&#123;<br>    <span class="hljs-comment">// type Directive = &#x27;up&#x27; | &#x27;down&#x27; | &#x27;left&#x27; | &#x27;right&#x27;</span><br>    <span class="hljs-comment">// 枚举类型</span><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Directive</span> &#123; <span class="hljs-string">&#x27;up&#x27;</span>, <span class="hljs-string">&#x27;down&#x27;</span>, <span class="hljs-string">&#x27;left&#x27;</span>, <span class="hljs-string">&#x27;right&#x27;</span> &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">d2</span>: <span class="hljs-title class_">Directive</span> = <span class="hljs-title class_">Directive</span>.<span class="hljs-property">down</span><br>&#125;<br></code></pre></td></tr></table></figure><p>枚举比较奇怪，这个类型有值，</p><ol><li>ts中的类型声明语句转成js后会丢弃，而枚举类型不会</li><li>枚举是有值的，可以输出打印，用了枚举以后代码体积会变大</li></ol><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Directive</span> = <span class="hljs-string">&#x27;up&#x27;</span> | <span class="hljs-string">&#x27;down&#x27;</span> | <span class="hljs-string">&#x27;left&#x27;</span> | <span class="hljs-string">&#x27;right&#x27;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">d1</span>:<span class="hljs-title class_">Directive</span>=<span class="hljs-string">&quot;right&quot;</span><br>    <span class="hljs-comment">// 枚举类型</span><br>    <span class="hljs-keyword">enum</span> directive &#123; <span class="hljs-string">&#x27;up&#x27;</span>, <span class="hljs-string">&#x27;down&#x27;</span>, <span class="hljs-string">&#x27;left&#x27;</span>, <span class="hljs-string">&#x27;right&#x27;</span> &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(directive)<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">d2</span>: directive = directive.<span class="hljs-property">down</span><br>&#125;<br><span class="hljs-comment">// ts文件转换后的js文件</span><br>&#123;<br>    <span class="hljs-keyword">var</span> d1 = <span class="hljs-string">&quot;right&quot;</span>;<br>    <span class="hljs-comment">// 枚举类型</span><br>    <span class="hljs-keyword">var</span> directive = <span class="hljs-built_in">void</span> <span class="hljs-number">0</span>;<br>    (<span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) &#123;<br>        directive[directive[<span class="hljs-string">&quot;up&quot;</span>] = <span class="hljs-number">0</span>] = <span class="hljs-string">&quot;up&quot;</span>;<br>        directive[directive[<span class="hljs-string">&quot;down&quot;</span>] = <span class="hljs-number">1</span>] = <span class="hljs-string">&quot;down&quot;</span>;<br>        directive[directive[<span class="hljs-string">&quot;left&quot;</span>] = <span class="hljs-number">2</span>] = <span class="hljs-string">&quot;left&quot;</span>;<br>        directive[directive[<span class="hljs-string">&quot;right&quot;</span>] = <span class="hljs-number">3</span>] = <span class="hljs-string">&quot;right&quot;</span>;<br>    &#125;)(directive || (directive = &#123;&#125;));<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(directive)<br>    <span class="hljs-keyword">var</span> d2 = directive.<span class="hljs-property">down</span>;<br>&#125;<br><span class="hljs-comment">// 枚举对象directive的值</span><br>&#123;<br>  <span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-string">&#x27;up&#x27;</span>,<br>  <span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-string">&#x27;down&#x27;</span>,<br>  <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-string">&#x27;left&#x27;</span>,<br>  <span class="hljs-string">&#x27;3&#x27;</span>: <span class="hljs-string">&#x27;right&#x27;</span>,<br>  <span class="hljs-attr">up</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">down</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">left</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">right</span>: <span class="hljs-number">3</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="any类型"><a href="#any类型" class="headerlink" title="any类型"></a>any类型</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&#123; <br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>: &#123;<span class="hljs-attr">a</span>:<span class="hljs-built_in">number</span>&#125; = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;<br>    obj.<span class="hljs-property">b</span>=<span class="hljs-number">200</span><br>&#125;<br>&#123; <br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>: <span class="hljs-built_in">any</span> = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;<br>    obj.<span class="hljs-property">b</span>=<span class="hljs-number">200</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以上操作都不会有任何类型错误提示，即使可能存在错误</p><p>尽可能的避免使用 any 类型，除非临时使用 any 来“避免”书写很长、很复杂的类型</p><p>有些时候可以临时写一下，</p><ul><li>前端没有明确拿到后端的数据的时候，不知道使用什么类型来保存可以先用下any，让代码通过</li></ul><p>有些时候就该是any</p><ul><li><code>console.log()</code>它的参数就是any</li></ul><p>其他隐式具有 any 类型的情况 </p><ul><li>声明变量不提供类型也不提供默认值</li><li>函数参数不加类型</li></ul><p>类型认值的类型时，使用as制定范围更小的类型</p><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>在知道获取元素的类型时，使用as制定范围更小的类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&#123; <br>    <span class="hljs-comment">// const img = document.getElementById(&#x27;img&#x27;)</span><br>    <span class="hljs-comment">// document.getElementById获取到的是HTMLElement类型</span><br>    <span class="hljs-comment">// HTMLElement类型没有src属性</span><br>    <span class="hljs-comment">// HTMLElement类型 ===&gt; HTML元素</span><br>    <span class="hljs-keyword">const</span> img = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;img&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLImageElement</span><br>    img.<span class="hljs-property">src</span>=<span class="hljs-string">&#x27;www.baidu.com&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Typescript进阶"><a href="#Typescript进阶" class="headerlink" title="Typescript进阶"></a>Typescript进阶</h2><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型：宽泛的类型，就是类型是不固定的，不写死的，不是任意类型</p><p>可以适用于多个类型，使用<strong>类型变量</strong>(比如T)捕获传入的类型，之后就可以继续使用这个类型。</p><p>本质是<strong>参数化类型</strong>，通俗的讲，就是所操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和函数的创建中，分别成为<strong>泛型类</strong>，<strong>泛型接口</strong>、<strong>泛型函数</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> 函数名&lt;类型变量<span class="hljs-number">1</span>,类型变量<span class="hljs-number">2</span>,...&gt;(参数<span class="hljs-number">1</span>:类型<span class="hljs-number">1</span>,参数<span class="hljs-number">2</span>:类型<span class="hljs-number">2</span>,...): 返回值类型 &#123;<br>  <br>&#125;<br><br><span class="hljs-keyword">function</span> id&lt;T&gt;(<span class="hljs-attr">value</span>: T): T &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-property">length</span>);<br>    <span class="hljs-keyword">return</span> value<br>&#125;<br><span class="hljs-keyword">const</span> r1 = id&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">const</span> r2 = id&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&#x27;abc&#x27;</span>)<br><span class="hljs-keyword">const</span> r3 = id&lt;<span class="hljs-built_in">boolean</span>&gt;(<span class="hljs-literal">true</span>)<br><span class="hljs-comment">// 没有明确传入T，但是因为类型推论，TS可以推出来数据的类型</span><br><span class="hljs-keyword">let</span> r4 = <span class="hljs-title function_">id</span>(<span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>解释：Type 可以代表任意类型，无法保证一定存在 length 属性，比如 number 类型就没有 length</p><p>此时，就需要<strong>为泛型添加约束来</strong><code>收缩类型</code><strong>(缩窄类型取值范围)</strong></p><p>添加泛型约束收缩类型，主要有以下两种方式：</p><ul><li>指定更加具体的类型，如T[]，要求传入的是一个数组</li><li>添加约束，使用interface，从指定接口继承属性</li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&#123;<br>    <span class="hljs-keyword">function</span> id&lt;T&gt;(<span class="hljs-attr">value</span>: T[]): T[] &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-property">length</span>);<br>        <span class="hljs-keyword">return</span> value<br>    &#125;<br>    <span class="hljs-comment">// 要求传入元素是string类型的数组</span><br>    <span class="hljs-keyword">const</span> r1=id&lt;<span class="hljs-built_in">string</span>&gt;([<span class="hljs-string">&#x27;a&#x27;</span>])<br>    <span class="hljs-comment">// 要求传入元素是number类型的数组</span><br>    <span class="hljs-keyword">const</span> r2=id&lt;<span class="hljs-built_in">number</span>&gt;([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br> &#125;<br>&#123;<br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ILength</span> &#123;<span class="hljs-attr">length</span>:<span class="hljs-built_in">number</span>,<span class="hljs-attr">age</span>:<span class="hljs-built_in">number</span> &#125;<br>    <span class="hljs-keyword">function</span> id&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ILength</span>&gt;(<span class="hljs-attr">value</span>: T): T &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-property">length</span>);<br>        <span class="hljs-keyword">return</span> value<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>多个泛型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&#123;<br>    <span class="hljs-keyword">function</span> id&lt;T&gt;(<span class="hljs-attr">value</span>: T): T &#123;<br>        <span class="hljs-keyword">return</span> value<br>    &#125;<br>    id&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&#x27;abc&#x27;</span>)<br>    <br>    <span class="hljs-keyword">function</span> f&lt;<span class="hljs-title class_">Type</span>, <span class="hljs-title class_">Result</span>&gt;(<span class="hljs-attr">a</span>: <span class="hljs-title class_">Type</span>, <span class="hljs-attr">b</span>: <span class="hljs-title class_">Result</span>): [<span class="hljs-title class_">Type</span>, <span class="hljs-title class_">Result</span>] &#123;<br>        <span class="hljs-keyword">return</span> [a,b]<br>    &#125;<br>    <span class="hljs-comment">// 类型推论</span><br>    <span class="hljs-keyword">const</span> r1=<span class="hljs-title function_">f</span>(<span class="hljs-number">100</span>,<span class="hljs-literal">false</span>)<br>&#125;<br><span class="hljs-comment">// 多个泛型变量相互约束</span><br><span class="hljs-comment">// keyof Obj 就是拿到Obj中所有key的集合</span><br>&#123;<br>    <span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> ,<span class="hljs-attr">c</span>: <span class="hljs-string">&#x27;abc&#x27;</span> &#125;<br>    <span class="hljs-keyword">function</span> getProp&lt;<span class="hljs-title class_">Obj</span>, <span class="hljs-title class_">Key</span> <span class="hljs-keyword">extends</span> keyof <span class="hljs-title class_">Obj</span>&gt;(<span class="hljs-attr">obj</span>: <span class="hljs-title class_">Obj</span>, <span class="hljs-attr">prop</span>: <span class="hljs-title class_">Key</span>): <span class="hljs-built_in">any</span> &#123;<br>        <span class="hljs-keyword">return</span> obj[prop]<br>    &#125;<br>    <span class="hljs-comment">// Key中是&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span><br>    <span class="hljs-comment">// 希望prop只能是obj中已有的属性</span><br>    <span class="hljs-title function_">getProp</span>(obj, <span class="hljs-string">&#x27;a&#x27;</span>)<br>    <br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">MyType</span> = &#123; <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">string</span> &#125;<br>    <span class="hljs-keyword">type</span> K = keyof <span class="hljs-title class_">MyType</span><br>    <span class="hljs-comment">// 这个时候K就是MyType中key组成的一个新的类型</span><br>    <span class="hljs-comment">// type K = &#x27;a&#x27; | &#x27;b&#x27;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: K = <span class="hljs-string">&#x27;b&#x27;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: K = <span class="hljs-string">&#x27;a&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>泛型练习</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs tsx">&#123;<br>    <span class="hljs-comment">// useState它接收一个任意类型的数据，返回一个数组。</span><br>    <span class="hljs-comment">// 数组的第一个元素的类型与入参一致； </span><br>    <span class="hljs-comment">// 数组的第二个元素是一个函数</span><br>    <span class="hljs-comment">// 这个函数的入参类型和返回值类型与useState的入参一致</span><br>    <span class="hljs-comment">// 传入的value类型是T，返回元组类型[T, (val: T) =&gt; T]，第一个参数是传入的类型T，第二个参数是一个函数，返回传入的类型T</span><br>    <span class="hljs-keyword">function</span> useState&lt;T&gt;(<span class="hljs-attr">value</span>: T): [T, <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">val</span>: T</span>) =&gt;</span> T] &#123;<br>        <span class="hljs-keyword">const</span> setValue = (<span class="hljs-attr">val</span>: T): <span class="hljs-function"><span class="hljs-params">T</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> val<br>        &#125;<br>        <span class="hljs-keyword">return</span> [value, setValue]<br>    &#125;<br>    <span class="hljs-keyword">const</span> [str, setStr] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;123&#x27;</span>)<br>    <span class="hljs-keyword">const</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">123</span>)<br>&#125;<br><span class="hljs-keyword">export</span> &#123; &#125;<br></code></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IFunct</span>&lt;<span class="hljs-title class_">Type</span>&gt; &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">value</span>: <span class="hljs-title class_">Type</span></span>) =&gt;</span> <span class="hljs-title class_">Type</span><br>    <span class="hljs-attr">ids</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Type</span>[]<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">m</span>: <span class="hljs-title class_">IFunct</span>&lt;<span class="hljs-built_in">string</span>&gt; = &#123;<br>    <span class="hljs-attr">id</span>:  <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> val,<br>    <span class="hljs-attr">ids</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>[]<br>&#125;<br>m.<span class="hljs-title function_">id</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)<br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>:<span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;=[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="Vite创建项目"><a href="#Vite创建项目" class="headerlink" title="Vite创建项目"></a>Vite创建项目</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm create vite<br></code></pre></td></tr></table></figure><h3 id="TS下props的使用"><a href="#TS下props的使用" class="headerlink" title="TS下props的使用"></a>TS下props的使用</h3><p>JS写法：</p><p><code>defineProps(&#123; money: &#123; type: Number, required: true &#125;&#125;)</code></p><p>TS写法：</p><p><code>const &#123;money, car=&#39;默认值&#39;&#125; = defineProps&lt;money:number,car?:string&gt;()</code></p><p><code>vite.config.json添加配置 reactivityTransform: true</code>当没有传值时使用默认值</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-title function_">defineProps</span>(&#123;<br>    <span class="hljs-attr">money</span>: &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>        <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span><br>    &#125;<br>&#125;)<br>defineProps&lt;&#123; <span class="hljs-attr">money</span>: <span class="hljs-built_in">number</span> &#125;&gt;()<br><span class="hljs-comment">// 如果想要给可选参数设置默认值</span><br><span class="hljs-keyword">const</span> &#123;money, car=<span class="hljs-string">&#x27;默认值&#x27;</span>&#125; = defineProps&lt;<span class="hljs-attr">money</span>:<span class="hljs-built_in">number</span>,<span class="hljs-attr">car</span>?:<span class="hljs-built_in">string</span>&gt;()<br></code></pre></td></tr></table></figure><h3 id="TS下emits的使用"><a href="#TS下emits的使用" class="headerlink" title="TS下emits的使用"></a>TS下emits的使用</h3><p>JS写法：</p><p><code>const emit = defineEmits([&#39;事件名1&#39;,&#39;事件名2&#39;])</code><br><code>emit(&#39;事件名1&#39;, 实参)</code></p><p>TS写法：</p><p><code>const emit = defineEmits&lt;&#123; (e: &#39;事件名&#39;, 变量名: 类型): void &#125;&gt;()</code></p><p><code>emit(&#39;事件名&#39;, 实参)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup lang=&quot;ts&quot;&gt;<br>const emit = defineEmits([&#x27;event1&#x27;])<br>const hClick = () =&gt; &#123;<br>    emit(&#x27;event1&#x27;, 12000)<br>&#125;<br><br>const emit = defineEmits&lt;&#123;<br>    (e: &#x27;event1&#x27;, money: number): void<br>&#125;&gt;()<br>const hClick = () =&gt; &#123;<br>    emit(&#x27;event1&#x27;, 12000)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="TS下ref的使用"><a href="#TS下ref的使用" class="headerlink" title="TS下ref的使用"></a>TS下ref的使用</h3><p>js写法：</p><p><code>const todos=ref([])</code></p><p>TS写法：</p><p><code>ref&lt;&#123;变量: 类型&#125;[]&gt;([])</code></p><p><code>const todos = ref&lt;&#123; id: number, content: string, isDone: boolean &#125;[]&gt;([])</code></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> todos=<span class="hljs-title function_">ref</span>([])<br><span class="hljs-comment">// 不赋值页面会报错</span><br><br><span class="hljs-keyword">const</span> todos = ref&lt;&#123; <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">content</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">isDone</span>: <span class="hljs-built_in">boolean</span> &#125;[]&gt;([])<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    todos.<span class="hljs-property">value</span> = [&#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;吃饭&#x27;</span>, <span class="hljs-attr">isDone</span>: <span class="hljs-literal">false</span> &#125;, &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;睡觉&#x27;</span>, <span class="hljs-attr">isDone</span>: <span class="hljs-literal">true</span> &#125;]<br>&#125;, <span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure><h3 id="TS下computed的使用"><a href="#TS下computed的使用" class="headerlink" title="TS下computed的使用"></a>TS下computed的使用</h3><p>JS写法：<code>computed(()=&gt;&#123; return... &#125;)</code></p><p>TS写法:<code>computed&lt;返回值类型&gt;(()=&gt;&#123; return... &#125;)</code></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> leftCount = computed&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> todos.<span class="hljs-property">value</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">isDone</span>).<span class="hljs-property">length</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="TS下的事件处理函数"><a href="#TS下的事件处理函数" class="headerlink" title="TS下的事件处理函数"></a>TS下的事件处理函数</h3><p>TS写法：</p><p><code>&lt;button @mousemove=&quot;hMouseMove($event)&quot;&gt;按钮&lt;/button&gt;</code></p><p><code>const hMouseMove = (e:MouseEvent) =&gt; &#123; console.log(e.pageX,e.pageY); &#125;</code></p><p>$event是一个特殊的变量，写在回调函数中，固定名字，表示当前对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup lang=&quot;ts&quot;&gt;<br>const hMouseMove = (e:MouseEvent) =&gt; &#123;<br>console.log(e.pageX,e.pageY);<br>&#125;<br>const h1 = (e: KeyboardEvent) =&gt; &#123;<br>    console.log(e);<br> &#125;<br>&lt;/script&gt;<br>&lt;template&gt;<br>    &lt;input type=&quot;text&quot; @keydown=&quot;h1($event)&quot;&gt;<br>    &lt;button @mousemove=&quot;hMouseMove($event)&quot;&gt;按钮&lt;/button&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h3 id="TS下的通过ref获取dom"><a href="#TS下的通过ref获取dom" class="headerlink" title="TS下的通过ref获取dom"></a>TS下的通过ref获取dom</h3><p>TS写法：</p><p><code>const hRef = ref&lt;null | HTMLHeadElement&gt;(null)</code></p><p><code>&lt;h1 ref=&quot;hRef&quot;&gt;ref&lt;/h1&gt;</code></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> hRef = ref&lt;<span class="hljs-literal">null</span> | <span class="hljs-title class_">HTMLHeadElement</span>&gt;(<span class="hljs-literal">null</span>)<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;h1&#x27;</span>) <span class="hljs-comment">// HTMLHeadElement</span><br></code></pre></td></tr></table></figure><p>ref用于获取页面中元素时，有两个状态：1.初始状态 null 2.绑定后的状态</p><p>可以通过document.createElement(对应标签名)的vscode提示得到DOM对象的类型</p><h4 id="可选链操作符"><a href="#可选链操作符" class="headerlink" title="可选链操作符?"></a>可选链操作符?</h4><p><code>iptRef.value?.innerHTML</code></p><p><code>JavaScript</code> 会在尝试访问 <code>iptRef.value.innerHTML</code> 之前，先隐式地检查并确定 <code>iptRef.value</code> 既不是 <code>null</code> 也不是 <code>undefined</code>。如果<code>iptRef.value</code> 是 <code>null</code> 或者 <code>undefined</code>，表达式将会短路计算直接返回 <code>undefined</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br>const hRef = ref&lt;null | HTMLHeadElement&gt;(null)<br>const clickFn = () =&gt; &#123;<br>    console.log(iptRef.value?.innerHTML);<br>&#125;<br><br>&lt;/script&gt;<br>&lt;template&gt;<br>    &lt;h1 ref=&quot;hRef&quot;&gt;ref&lt;/h1&gt;<br>    &lt;button @click=&quot;clickFn&quot;&gt;点击&lt;/button&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h3 id="Typescript类型声明文件"><a href="#Typescript类型声明文件" class="headerlink" title="Typescript类型声明文件"></a>Typescript类型声明文件</h3><p>import导入包后的加载过程</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><span class="hljs-comment">// 1.在node_modules/axios中找到package.json</span><br><span class="hljs-comment">// 2.在package.json中找到main字段对应的文件</span><br><span class="hljs-comment">//    找到node_modules/axios/lib/axios.js</span><br><span class="hljs-comment">// 3.在引入.js文件的同时，会载入types字段指定的index.d.ts</span><br><span class="hljs-comment">// 此时就有了类型提示</span><br></code></pre></td></tr></table></figure><p>用来为已存在的 JS 库提供类型信息。包括内置类型声明文件、第三方库类型声明文件和自定义类型声明文件</p><p>如果要为 JS 库提供类型信息，要使用 <code>.d.ts</code> 文件</p><p>内置类型声明文件：TS 为 JS 运行时可用的所有标准化内置 API 都提供了声明文件</p><p>第三方库类型声明文件：1. 库自带类型声明文件 2. 由 TS官方给它写的</p><p>自定义类型声明文件</p><p>如下两种场景需要提供自定义类型声明文件</p><ol><li>项目内共享类型</li><li>为已有 JS 文件提供类型声明</li></ol><p>如何基于现有的.js提供声明文件?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// utils/index.js</span><br><span class="hljs-keyword">let</span> count = <span class="hljs-number">10</span><br><span class="hljs-keyword">let</span> songName = <span class="hljs-string">&#x27;痴心绝对&#x27;</span><br><span class="hljs-keyword">let</span> position = &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">y</span>: <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + y<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">changeDirection</span>(<span class="hljs-params">direction</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(direction)<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fomartPoint</span> = point =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;当前坐标：&#x27;</span>, point)<br>&#125;<br><br><span class="hljs-keyword">export</span> &#123; count, songName, position, add, changeDirection, fomartPoint &#125;<br></code></pre></td></tr></table></figure><p>思路：编写同名的.d.ts文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">demo.<span class="hljs-property">ts</span><br>utils/index.<span class="hljs-property">js</span><br>utils/index.<span class="hljs-property">d</span>.<span class="hljs-property">ts</span> <span class="hljs-comment">// 这里是重点</span><br></code></pre></td></tr></table></figure><ol><li><p>它的作用是提供声明，不需要提供逻辑代码；</p></li><li><p>declare 关键字:用于类型声明，为其他地方(比如.js 文件)已存在的变量声明类型，而不是创建一个新的变量。</p></li><li><ol><li>对于 type、interface 等这些明确就是 TS 类型的(只能在 TS 中使用的)，可以省略 declare 关键字。</li><li>对于 let、function 等具有双重含义(在 JS、TS 中都能用)，应该使用 declare 关键字，明确指定此处用于类型声明。</li></ol></li></ol><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// util/index.d.ts</span><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> <span class="hljs-attr">count</span>:<span class="hljs-built_in">number</span><br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> <span class="hljs-attr">songName</span>: <span class="hljs-built_in">string</span><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Position</span> &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>,<br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> <span class="hljs-attr">position</span>: <span class="hljs-title class_">Position</span><br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span> (<span class="hljs-params">x :<span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span></span>) : <span class="hljs-built_in">number</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Direction</span> = <span class="hljs-string">&#x27;left&#x27;</span> | <span class="hljs-string">&#x27;right&#x27;</span> | <span class="hljs-string">&#x27;top&#x27;</span> | <span class="hljs-string">&#x27;bottom&#x27;</span><br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeDirection</span> (<span class="hljs-params"><span class="hljs-attr">direction</span>: <span class="hljs-title class_">Direction</span></span>): <span class="hljs-built_in">void</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">FomartPoint</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">point</span>: <span class="hljs-title class_">Position</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">fomartPoint</span>: <span class="hljs-title class_">FomartPoint</span><br><br><span class="hljs-keyword">export</span> &#123;<br>  count, songName, position, add, changeDirection, fomartPoint<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Pinia"><a href="#Pinia" class="headerlink" title="Pinia"></a>Pinia</h2><p>pinia是Vue的专属的状态管理库，是Vuex状态管理工具的替代品</p><p>优势：</p><ol><li>提供了更加简单的API（去掉了mutations）</li><li>提供符合组合式风格的API（和Vue3新语法统一）</li><li>去掉了modules的概念，每一个store都是一个独立的模块</li><li>搭配Typescript一起使用提供可靠的类型推断</li></ol><h3 id="pinia的使用"><a href="#pinia的使用" class="headerlink" title="pinia的使用"></a>pinia的使用</h3><p>pinia安装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install pinia<br></code></pre></td></tr></table></figure><p>在main.js中注册</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createPinia &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><span class="hljs-keyword">const</span> pinia=<span class="hljs-title function_">createPinia</span>()<br><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">use</span>(pinia).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>新建stores&#x2F;counter.js</p><ul><li>state数据通过ref定义响应式数据</li><li>getters数据通过computed计算属性方法定义</li><li>将所有定义的变量和方法全部return出去</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><span class="hljs-keyword">import</span> &#123; computed, ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCounterStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;counter&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// state属性</span><br>    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br>    <span class="hljs-comment">// actions同步方法</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        count.<span class="hljs-property">value</span>++<br>    &#125;<br>    <span class="hljs-comment">// actions异步方法</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">API_URL</span> = <span class="hljs-string">&#x27;http://geek.itheima.net/v1_0/channels&#x27;</span><br>    <span class="hljs-keyword">const</span> list = <span class="hljs-title function_">ref</span>([])<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">getList</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-variable constant_">API_URL</span>)<br>        <span class="hljs-comment">// console.log(res);</span><br>        list.<span class="hljs-property">value</span>=res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">channels</span><br>     &#125;<br>    <span class="hljs-comment">// getters计算属性</span><br>    <span class="hljs-keyword">const</span> computedCount = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span> * <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> &#123;<br>        count,<br>        increment,<br>        computedCount,<br>        list,<br>        getList<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>在页面中导入使用</p><ul><li><p>如果直接解构赋值，会丢失数据的响应式</p><p><code>const &#123; count, computedCount &#125; = counterStore</code></p></li><li><p>使用storeToRef方法包裹保持数据响应式</p><p><code>const &#123; count, computedCount &#125; = storeToRefs(counterStore)</code></p></li><li><p>方法直接从原来的counterStore中解构赋值<br><code>const &#123; increment &#125; = counterStore</code></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; useCounterStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./stores/counter&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; storeToRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span>;<br><span class="hljs-comment">// 执行方法得到store实例对象</span><br><span class="hljs-keyword">const</span> counterStore = <span class="hljs-title function_">useCounterStore</span>()<br><span class="hljs-comment">// 直接解构赋值 响应式的丢失</span><br><span class="hljs-comment">// const &#123; count, computedCount &#125; = counterStore</span><br><span class="hljs-comment">// 方法包裹 保持响应式更细</span><br><span class="hljs-keyword">const</span> &#123; count, computedCount &#125; = <span class="hljs-title function_">storeToRefs</span>(counterStore)<br><span class="hljs-comment">// 方法直接从原来的counterStore中解构赋值</span><br><span class="hljs-keyword">const</span> &#123; increment &#125; = counterStore<br><span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  counterStore.<span class="hljs-title function_">getList</span>()<br> &#125;)<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>&#123;&#123; computedCount &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in counterStore.list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="项目开始"><a href="#项目开始" class="headerlink" title="项目开始"></a>项目开始</h2><h3 id="项目别名路径联想设置"><a href="#项目别名路径联想设置" class="headerlink" title="项目别名路径联想设置"></a>项目别名路径联想设置</h3><p>新建jsconfig.json文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;baseUrl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;paths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;@/*&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;src/*&quot;</span><br>            <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;exclude&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;node_modeules&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;dist&quot;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>安装elementPlus和按需导入的包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">yarn add elementPlus<br>npm install -D unplugin-vue-components unplugin-auto-<span class="hljs-keyword">import</span><br></code></pre></td></tr></table></figure><p>在vite.config.js中配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// vite.config.ts</span><br><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">AutoImport</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-auto-import/vite&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Components</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-vue-components/vite&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ElementPlusResolver</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-vue-components/resolvers&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-title class_">AutoImport</span>(&#123;<br>      <span class="hljs-attr">resolvers</span>: [<span class="hljs-title class_">ElementPlusResolver</span>()],<br>    &#125;),<br>    <span class="hljs-title class_">Components</span>(&#123;<br>      <span class="hljs-attr">resolvers</span>: [<span class="hljs-title class_">ElementPlusResolver</span>()],<br>    &#125;),<br>  ],<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="定制elementPlus主题"><a href="#定制elementPlus主题" class="headerlink" title="定制elementPlus主题"></a>定制elementPlus主题</h3><p>新建styles&#x2F;element&#x2F;index.scss</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/* 只需要重写你需要的即可 */</span><br><span class="hljs-keyword">@forward</span> <span class="hljs-string">&#x27;element-plus/theme-chalk/src/common/var.scss&#x27;</span> with (<br>  <span class="hljs-variable">$colors</span>: (<br>    <span class="hljs-string">&#x27;primary&#x27;</span>: (<br>      // 主色<br>      <span class="hljs-string">&#x27;base&#x27;</span>: <span class="hljs-number">#27ba9b</span>,<br>    ),<br>    <span class="hljs-string">&#x27;success&#x27;</span>: (<br>      // 成功色<br>      <span class="hljs-string">&#x27;base&#x27;</span>: <span class="hljs-number">#1dc779</span>,<br>    ),<br>    <span class="hljs-string">&#x27;warning&#x27;</span>: (<br>      // 警告色<br>      <span class="hljs-string">&#x27;base&#x27;</span>: <span class="hljs-number">#ffb302</span>,<br>    ),<br>    <span class="hljs-string">&#x27;danger&#x27;</span>: (<br>      // 危险色<br>      <span class="hljs-string">&#x27;base&#x27;</span>: <span class="hljs-number">#e26237</span>,<br>    ),<br>    <span class="hljs-string">&#x27;error&#x27;</span>: (<br>      // 错误色<br>      <span class="hljs-string">&#x27;base&#x27;</span>: <span class="hljs-number">#cf4444</span>,<br>    ),<br>  )<br>)<br></code></pre></td></tr></table></figure><p>在vite.config.js中配置</p><p>在plugins节点下面的Components配置<code>resolvers: [ElementPlusResolver(&#123;importStyle:&quot;sass&quot;&#125;)],</code></p><p>添加css节点，在prepocessorOptions预处理器添加scss，使用 <code>scss.additionalData</code> 来编译所有应用 scss 变量的组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; fileURLToPath, <span class="hljs-variable constant_">URL</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;node:url&#x27;</span><br><br><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-vue&#x27;</span><br><span class="hljs-comment">// 配置elementPlus按需导入</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">AutoImport</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-auto-import/vite&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Components</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-vue-components/vite&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ElementPlusResolver</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-vue-components/resolvers&#x27;</span><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-title function_">vue</span>(),<br>    <span class="hljs-title class_">AutoImport</span>(&#123;<br>      <span class="hljs-attr">resolvers</span>: [<span class="hljs-title class_">ElementPlusResolver</span>()],<br>    &#125;),<br>    <span class="hljs-title class_">Components</span>(&#123;<br>      <span class="hljs-attr">resolvers</span>: [<span class="hljs-title class_">ElementPlusResolver</span>(&#123;<span class="hljs-attr">importStyle</span>:<span class="hljs-string">&quot;sass&quot;</span>&#125;)],<br>    &#125;),<br>  ],<br>  ......<br>  <span class="hljs-attr">css</span>: &#123;<br>    <span class="hljs-attr">preprocessorOptions</span>: &#123;<br>      <span class="hljs-attr">scss</span>: &#123;<br>        <span class="hljs-attr">additionalData</span>:<span class="hljs-string">`@use &quot;@/styles/element/index.scss&quot; as *;`</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="axios封装"><a href="#axios封装" class="headerlink" title="axios封装"></a>axios封装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><span class="hljs-keyword">const</span> httpInstance = axios.<span class="hljs-title function_">create</span>(&#123;<br>    <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;http://pcapi-xiaotuxian-front-devtest.itheima.net&#x27;</span>,<br>    <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span><br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> httpInstance<br></code></pre></td></tr></table></figure><p>如果项目里面不同的业务需要不同的接口基地址不同：</p><p>axios.create()方法可以执行多次，每次执行就会生成一个新的实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http1=axios.<span class="hljs-title function_">create</span>(&#123;<span class="hljs-attr">baseURL</span>:<span class="hljs-string">&#x27;url1&#x27;</span>&#125;)<br><span class="hljs-keyword">const</span> http2=axios.<span class="hljs-title function_">create</span>(&#123;<span class="hljs-attr">baseURL</span>:<span class="hljs-string">&#x27;url2&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><h3 id="scss文件自动导入"><a href="#scss文件自动导入" class="headerlink" title="scss文件自动导入"></a>scss文件自动导入</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">css</span>: &#123;<br>  <span class="hljs-attr">preprocessorOptions</span>: &#123;<br>    <span class="hljs-attr">scss</span>: &#123;<br>      <span class="hljs-attr">additionalData</span>: <span class="hljs-string">`</span><br><span class="hljs-string">         @use &quot;@/styles/element/index.scss&quot; as *;</span><br><span class="hljs-string">         @use &quot;@/styles/var.scss&quot; as *;</span><br><span class="hljs-string">         `</span>,<br>    &#125;,<br>  &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="纯展示类组件调用封装思路"><a href="#纯展示类组件调用封装思路" class="headerlink" title="纯展示类组件调用封装思路"></a>纯展示类组件调用封装思路</h3><ol><li>搭建纯静态的部分，不管可变的部分</li><li>抽离可变的部分为组件参数，非复杂的文本抽离成props，复杂的结构抽象为插槽</li></ol><p>路由缓存问题</p><p>当页面从category&#x2F;1005000跳转到category&#x2F;1005002时，只有参数发生变化，相同的组件实例将被重复使用，两个路由渲染同一个组件，组件得到生命周期钩子函数不会被调用，导致分类数据无法更新。</p><p>解决思路：</p><ol><li>让组件实例不复用，强制销毁重建</li><li>监听路由变化，变化之后执行数据更新操作</li></ol><p>解决方案1：</p><p>添加key，破坏复用机制，强制销毁重建</p><p>问题：整个页面网络请求都会重新发送，浪费资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;router-view :key=&quot;$route.fullPath&quot;&gt;&lt;/router-view&gt;<br></code></pre></td></tr></table></figure><p>解决方案2：</p><p>beforeRouteUpdate导航钩子，在每次更新路由前执行，在回调中执行需要数据更新的业务逻辑即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; onBeforeRouteUpdate, useRoute &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getSecondCategory</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">id = route.params.id</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getSecondCategoryAPI</span>(id)<br>    <span class="hljs-comment">// console.log(res);</span><br>    categoryData.<span class="hljs-property">value</span> = res.<span class="hljs-property">result</span><br>&#125;<br><span class="hljs-comment">// 监听路由参数变化，重新发送请求分类数据</span><br><span class="hljs-title function_">onBeforeRouteUpdate</span>(<span class="hljs-function">(<span class="hljs-params">to</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 存在问题:使用最新的路由参数请求最新的分类数据</span><br>    <span class="hljs-title function_">getSecondCategory</span>(to.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>解决方案3</p><p>使用watch监听路由变化，发送请求，可以实现效果</p><p>问题：跳转首页后控制台报错，因为首页是一级路由’&#x2F;‘，分类页面是’&#x2F;category&#x2F;105000’，没有route.params.id</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">watch</span>(<br>    route, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">getSecondCategory</span>()<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><h3 id="使用逻辑函数拆分业务"><a href="#使用逻辑函数拆分业务" class="headerlink" title="使用逻辑函数拆分业务"></a>使用逻辑函数拆分业务</h3><p>实现步骤</p><ol><li>按照业务声明以use打头的逻辑函数</li><li>把独立的业务逻辑封装到各个函数内部</li><li>函数内部把组件中需要用到的数据或方法return出去</li><li>在组件中调用函数把数据或者方法组合回来使用</li></ol><h3 id="无限滚动实现"><a href="#无限滚动实现" class="headerlink" title="无限滚动实现"></a>无限滚动实现</h3><ul><li>el-tabs组件的v-model属性关联el-tab-pane组件的name属性，也是请求二级分类数据reqData.sortFields属性。切换tab栏时触发tab-click事件重新请求二级分类商品数据</li><li>请求回来的数据需要与原goodsList进行合并</li><li>使用elementPlus组件的v-infinite-scroll&#x3D;”load”指令进行无限滚动，当前<code>reqData.page*reqData.pageSize</code>大于数据最多数量maxCount时，判断加载完成，设置infinite-scroll-disabled&#x3D;”disabled”禁用无限滚动</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; getCategoryFilterAPI, geySubCatetoryAPI &#125; from &#x27;@/apis&#x27;;<br>import &#123; ref, onMounted &#125; from &#x27;vue&#x27;;<br>......<br>const goodsList = ref([])<br>const maxCount = ref(0)<br>const disabled = ref(false)<br>// 请求数据对象<br>const reqData = ref(&#123;<br>    catetoryId: route.params.id,<br>    page: 1,<br>    pageSize: 20,<br>    sortField: &#x27;publishTime&#x27;<br>&#125;)<br>const getGoodsList = async () =&gt; &#123;<br>    const res = await geySubCatetoryAPI(reqData)<br>    maxCount.value = res.result.counts<br>    goodsList.value = [...goodsList.value, ...res.result.items]<br>&#125;<br>onMounted(() =&gt; getGoodsList())<br>const tabChange = () =&gt; &#123;<br>    getGoodsList()<br>&#125;    <br>const load = () =&gt; &#123;<br>    reqData.value.page++<br>    getGoodsList()<br>    // 如果没有更多数据了，禁用无限滚动<br>    if (reqData.value.page * reqData.value.pageSize &gt; maxCount.value) &#123;<br>        disabled.value = true<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>    &lt;div class=&quot;container &quot;&gt;<br>......<br>        &lt;div class=&quot;sub-container&quot;&gt;<br>            &lt;el-tabs v-model=&quot;reqData.sortField&quot; @tab-click=&quot;tabChange&quot;&gt;<br>                &lt;el-tab-pane label=&quot; 最新商品&quot; name=&quot;publishTime&quot;&gt;&lt;/el-tab-pane&gt;<br>                &lt;el-tab-pane label=&quot;最高人气&quot; name=&quot;orderNum&quot;&gt;&lt;/el-tab-pane&gt;<br>                &lt;el-tab-pane label=&quot;评论最多&quot; name=&quot;evaluateNum&quot;&gt;&lt;/el-tab-pane&gt;<br>            &lt;/el-tabs&gt;<br>            &lt;div class=&quot;body&quot; v-infinite-scroll=&quot;load&quot; :infinite-scroll-disabled=&quot;disabled&quot;&gt;<br>                &lt;!-- 商品列表--&gt;<br>                &lt;GoodsItem v-for=&quot;item in goodsList&quot; :key=&quot;item.id&quot; :goods=&quot;item&quot;&gt;&lt;/GoodsItem&gt;<br>            &lt;/div&gt;<br>        &lt;/div&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h3 id="二级分类-定制路由滚动行为"><a href="#二级分类-定制路由滚动行为" class="headerlink" title="二级分类-定制路由滚动行为"></a>二级分类-定制路由滚动行为</h3><p>在不同路由切换时，可以自动滚动到页面的顶部，而不是停留在原先的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-title function_">scrollBehavior</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">top</span>: <span class="hljs-number">0</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="封装复杂组件"><a href="#封装复杂组件" class="headerlink" title="封装复杂组件"></a>封装复杂组件</h3><h4 id="通用思路"><a href="#通用思路" class="headerlink" title="通用思路"></a>通用思路</h4><ol><li>功能拆解</li><li>寻找核心实现思路</li><li>寻找关键技术</li><li>逐个实现，逐个验证，最后优化</li></ol><h4 id="图片预览组件的封装逻辑"><a href="#图片预览组件的封装逻辑" class="headerlink" title="图片预览组件的封装逻辑"></a>图片预览组件的封装逻辑</h4><p>功能拆解：</p><ol><li><p>小图切换大图显示</p><p>ul的li身上绑定mouseenter事件，经过哪张图片时就将当前图片的索引activeIndex赋值给左侧大图显示<code>&lt;img :src=&quot;imageList[activeIndex]&quot; alt=&quot;&quot; /&gt;</code></p></li><li><p>放大镜效果实现</p><p>使用useMouseInElement(target)获取到鼠标相对于当前盒子的<code>elementX, elementY, isOutside</code>，当isOutside为false时展示大图预览，并且展示蒙层小盒子，当移动鼠标时，获取鼠标的相对位移，操控蒙层小盒子的top和left。大图预览时图片的移动方向和鼠标移动方向相反，设置<code>const positionX = computed(() =&gt; &#123; return -left.value * 2 &#125;)</code>和<code>const positionY = computed(() =&gt; &#123; return -top.value * 2 &#125;)</code>赋值给大盒子的backgroundPositionX和backgroundPositionY，实现效果。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref, watch, computed &#125; from &#x27;vue&#x27;;<br>import &#123; useMouseInElement &#125; from &#x27;@vueuse/core&#x27;<br>// 图片列表<br>defineProps(&#123;<br>    imageList: &#123;<br>        type: Array,<br>        default:()=&gt;([])<br>    &#125;<br>&#125;)<br>// 1.小图切换大图显示<br>const activeIndex = ref(0)<br>const enterImage = (i) =&gt; &#123;<br>    activeIndex.value = i<br>&#125;<br>// 2.放大镜效果实现-滑块跟随鼠标移动<br>// 获取鼠标相对位置，控制滑块跟随移动<br>const target = ref(null)<br>const left = ref(0)<br>const top = ref(0)<br>const &#123; elementX, elementY, isOutside &#125; = useMouseInElement(target)<br>// 3.控制滑块跟随鼠标移动(监听elementX/Y变化，一旦变化，重新设置left/top)<br>watch([elementX, elementY, isOutside], () =&gt; &#123;<br>    // 如果鼠标没有移入到盒子里，直接不执行后面逻辑<br>    if (isOutside.value) return<br>    // 有效移动距离计算<br>    if (elementX.value &gt; 100 &amp;&amp; elementX.value &lt; 300) &#123;<br>        left.value = elementX.value - 100<br>    &#125;<br>    if (elementY.value &gt; 100 &amp;&amp; elementY.value &lt; 300) &#123;<br>        top.value = elementY.value - 100<br>    &#125;<br>    // 边界距离控制<br>    if (elementX.value &gt; 300) &#123; left.value = 200 &#125;<br>    if (elementX.value &lt; 100) &#123; left.value = 0 &#125;<br>    if (elementY.value &gt; 300) &#123; top.value = 200 &#125;<br>    if (elementY.value &lt; 100) &#123; top.value = 0 &#125;<br>&#125;)<br>// 控制大图显示<br>const positionX = computed(() =&gt; &#123;<br>    return -left.value * 2<br>&#125;)<br>const positionY = computed(() =&gt; &#123;<br>    return -top.value * 2<br>&#125;)<br>&lt;/script&gt;<br>&lt;template&gt;<br>    &lt;div class=&quot;goods-image&quot;&gt;<br>        &lt;!-- 左侧大图--&gt;<br>        &lt;div class=&quot;middle&quot; ref=&quot;target&quot;&gt;<br>            &lt;img :src=&quot;imageList[activeIndex]&quot; alt=&quot;&quot; /&gt;<br>            &lt;!-- 蒙层小滑块 --&gt;<br>            &lt;!-- 如果鼠标移出盒子范围，就隐藏蒙层 --&gt;<br>            &lt;div class=&quot;layer&quot; :style=&quot;&#123; left: `$&#123;left&#125;px`, top: `$&#123;top&#125;px` &#125;&quot; v-show=&quot;!isOutside&quot;&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br>        &lt;!-- 小图列表 --&gt;<br>        &lt;ul class=&quot;small&quot;&gt;<br>            &lt;li v-for=&quot;(img, i) in imageList&quot; :key=&quot;i&quot; @mouseenter=&quot;enterImage(i)&quot; :class=&quot;&#123; active: activeIndex === i &#125;&quot;&gt;<br>                &lt;img :src=&quot;img&quot; alt=&quot;&quot; /&gt;<br>            &lt;/li&gt;<br>        &lt;/ul&gt;<br>        &lt;!-- 放大镜大图 --&gt;<br>        &lt;div class=&quot;large&quot; :style=&quot;[&#123;<br>                backgroundImage: `url($&#123;imageList[activeIndex]&#125;)`,<br>                backgroundPositionX: `$&#123;positionX&#125;px`,<br>                backgroundPositionY: `$&#123;positionY&#125;px`,<br>            &#125;,]&quot; v-show=&quot;!isOutside&quot;&gt;&lt;/div&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h3 id="SKU组件"><a href="#SKU组件" class="headerlink" title="SKU组件"></a>SKU组件</h3><p>存活单位(stock keeping unit)，也翻译为库存单元，是一个会计学名词，定义为库存管理中打的最小可用单元，例如纺织品中的一个SKU通常表示规格、颜色、款式，而在零售门店中有时称单品位一个SKU</p><p>作用：产出当前用户选择的商品规格，为加入购物车操作提供数据信息</p><p>遇到别人写好的组件，首先重点看props和emit，props决定了当前组件接收什么数据，emit决定了会产出什么数据</p><p>验证组件是否使用成功：传入必要数据是否交互功能正常，点击选择规格，是否正常产出数据</p><h3 id="共用组件全局注册"><a href="#共用组件全局注册" class="headerlink" title="共用组件全局注册"></a>共用组件全局注册</h3><p>在src&#x2F;components文件夹下面新建index.js，通过插件的形式将components中的所有组件进行全局化注册</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ImagePreview</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ImagePreview/index.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">XtxSku</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./XtxSku/index.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Banner</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Banner.vue&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> componentPlugin = &#123;<br>    <span class="hljs-title function_">install</span>(<span class="hljs-params">app</span>) &#123;<br>        <span class="hljs-comment">// app.component(&#x27;组件名字&#x27;,&#x27;组件配置对象&#x27;)</span><br>        app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;ImagePreview&#x27;</span>, <span class="hljs-title class_">ImagePreview</span>),<br>        app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;XtxSku&#x27;</span>, <span class="hljs-title class_">XtxSku</span>),<br>        app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;Banner&#x27;</span>, <span class="hljs-title class_">Banner</span>)<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后再main.js中导入全局注册</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; componentPlugin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components&#x27;</span><br>app.<span class="hljs-title function_">use</span>(componentPlugin)<br></code></pre></td></tr></table></figure><h3 id="登录表单校验"><a href="#登录表单校验" class="headerlink" title="登录表单校验"></a>登录表单校验</h3><h4 id="全局校验"><a href="#全局校验" class="headerlink" title="全局校验"></a>全局校验</h4><p>在点击登录按钮时进行全局校验，使用Form组件自带的校验方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">loginFn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    formRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">validate</span>(<span class="hljs-title function_">async</span> (valid) =&gt; &#123;<br>        <span class="hljs-keyword">if</span> (valid) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">await</span>  userStore.<span class="hljs-title function_">getUserInfo</span>(&#123;<br>                    <span class="hljs-attr">account</span>: userForm.<span class="hljs-property">value</span>.<span class="hljs-property">account</span>,<br>                    <span class="hljs-attr">password</span>: userForm.<span class="hljs-property">value</span>.<span class="hljs-property">password</span><br>                &#125;)<br>                <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">success</span>(<span class="hljs-string">&#x27;用户登录成功&#x27;</span>)<br>                router.<span class="hljs-title function_">replace</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span> &#125;)<br>            &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>                <span class="hljs-comment">// console.log(err)</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="pinia管理用户数据"><a href="#pinia管理用户数据" class="headerlink" title="pinia管理用户数据"></a>pinia管理用户数据</h4><p>在pinia中定义异步的actions方法，调用时传入账户名和密码，将返回的用户信息存到state中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><span class="hljs-keyword">import</span> &#123; loginAPI &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/apis&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useUserStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> userInfo = <span class="hljs-title function_">ref</span>(&#123;&#125;)<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">getUserInfo</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">&#123; account, password &#125;</span>) =&gt; &#123;<br>        <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">loginAPI</span>(&#123; account, password &#125;)<br>        userInfo.<span class="hljs-property">value</span> = res.<span class="hljs-property">result</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123; userInfo, getUserInfo &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="pinia数据持久化存储"><a href="#pinia数据持久化存储" class="headerlink" title="pinia数据持久化存储"></a>pinia数据持久化存储</h3><p>使用pinia-plugin-persistedstate插件对pinia中的数据进行持久化处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> piniaPluginPersistedstate <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia-plugin-persistedstate&#x27;</span><br><span class="hljs-keyword">const</span> pinia=<span class="hljs-title function_">createPinia</span>()<br>app.<span class="hljs-title function_">use</span>(pinia)<br>pinia.<span class="hljs-title function_">use</span>(piniaPluginPersistedstate)<br></code></pre></td></tr></table></figure><p>然后再想要持久化存储的pinia中添加配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useUserStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>......<br>    <span class="hljs-keyword">return</span> &#123; ...... &#125;<br>&#125;,<br>    &#123; <span class="hljs-attr">persist</span>: <span class="hljs-literal">true</span> &#125;<br>)<br><br></code></pre></td></tr></table></figure><h3 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h3><h4 id="页面铺设"><a href="#页面铺设" class="headerlink" title="页面铺设"></a><strong>页面铺设</strong></h4><p>首先新建头部购物车文件，在Layout页面右上角展示购物车图标，小徽标显示里面商品种类数量。</p><p>当鼠标经过购物车图标，并且购物车中商品种类数量大于0并且当前路由路由不是cartlist时，会出现弹出层展示购物车中商品。</p><p>在pinia中定义计算属性totalCount和totalPrice，计算购物车中商品的总数量和总价</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// HeaderCart.vue</span><br>&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; useCartStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/stores&#x27;</span><br><span class="hljs-keyword">import</span> &#123; computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">const</span> cartStore = <span class="hljs-title function_">useCartStore</span>()<br><span class="hljs-keyword">const</span> cartLength = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> cartStore.<span class="hljs-property">cartList</span>.<span class="hljs-property">length</span><br> &#125;)<br>&lt;/script&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cart&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;curr&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;$router.push(&#x27;/cartlist&#x27;)&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iconfont icon-cart&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>&#123;&#123; cartLength &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;layer&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;cartLength &gt; 0 &amp;&amp; $route.path !== &#x27;/cartlist&#x27;&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;foot&quot;</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;total&quot;</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>共 &#123;&#123; cartStore.totalCount &#125;&#125; 件商品<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-symbol">&amp;yen;</span> &#123;&#123; cartStore.totalPrice.toFixed(2) &#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;large&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;$router.push(&#x27;/cartlist&#x27;)&quot;</span>&gt;</span>去购物车结算<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.cart</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">position</span>: relative;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">z-index</span>: <span class="hljs-number">600</span>;</span></span><br><span class="language-css"><span class="language-xml"></span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-selector-class">.curr</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">height</span>: <span class="hljs-number">32px</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">line-height</span>: <span class="hljs-number">32px</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">text-align</span>: center;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">position</span>: relative;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">display</span>: block;</span></span><br><span class="language-css"><span class="language-xml">    &amp;<span class="hljs-selector-pseudo">:hover</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-selector-class">.layer</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">            <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;</span></span><br><span class="language-css"><span class="language-xml">            <span class="hljs-attribute">transform</span>: none;</span></span><br><span class="language-css"><span class="language-xml">        &#125;</span></span><br><span class="language-css"><span class="language-xml">    &#125;</span></span><br><span class="language-css"><span class="language-xml"></span></span><br></code></pre></td></tr></table></figure><h4 id="购物车列表页面"><a href="#购物车列表页面" class="headerlink" title="购物车列表页面"></a><strong>购物车列表页面</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs vue">// views/cartList/index.vue中<br>&lt;script setup&gt;<br>import &#123; useCartStore &#125; from &#x27;@/stores&#x27;;<br>import &#123; useRouter &#125; from &#x27;vue-router&#x27;<br>const cartStore = useCartStore()<br>const singleCheck = (i, selected) =&gt; &#123;<br>    cartStore.singleCheck(i.skuId, selected)<br>&#125;<br>const router =useRouter()<br>const totalCheck = (selected) =&gt; &#123;<br>    cartStore.totalCheck(selected)<br>&#125;<br>const orderPayFn = () =&gt; &#123;<br>    if (!cartStore.isLogin) &#123;<br>        router.push(`/login?redirect=$&#123;router.currentRoute.value.fullPath&#125;`)<br>    &#125; else &#123;<br>        router.push(&#x27;/checkout&#x27;)<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br>&lt;template&gt;<br>    &lt;div class=&quot;xtx-cart-page&quot;&gt;<br>        &lt;div class=&quot;container m-top-20&quot;&gt;<br>            &lt;div class=&quot;bread-container&quot;&gt;<br>                &lt;el-breadcrumb separator=&quot;&gt;&quot;&gt;<br>                    &lt;el-breadcrumb-item :to=&quot;&#123; path: &#x27;/&#x27; &#125;&quot;&gt;首页&lt;/el-breadcrumb-item&gt;<br>                    &lt;el-breadcrumb-item&gt;购物车&lt;/el-breadcrumb-item&gt;<br>                &lt;/el-breadcrumb&gt;<br>            &lt;/div&gt;<br>            &lt;div class=&quot;cart&quot;&gt;<br>                &lt;table&gt;<br>                    &lt;thead&gt;<br>                        &lt;tr&gt;<br>                            &lt;th width=&quot;120&quot;&gt;<br>                                &lt;el-checkbox :model-value=&quot;cartStore.totalChecked&quot; @change=&quot;totalCheck&quot; /&gt;<br>                            &lt;/th&gt;<br>                            &lt;th width=&quot;400&quot;&gt;商品信息&lt;/th&gt;<br>                            &lt;th width=&quot;220&quot;&gt;单价&lt;/th&gt;<br>                            &lt;th width=&quot;180&quot;&gt;数量&lt;/th&gt;<br>                            &lt;th width=&quot;180&quot;&gt;小计&lt;/th&gt;<br>                            &lt;th width=&quot;140&quot;&gt;操作&lt;/th&gt;<br>                        &lt;/tr&gt;<br>                    &lt;/thead&gt;<br>                    &lt;!-- 商品列表 --&gt;<br>                    &lt;tbody&gt;<br>                        &lt;tr v-for=&quot;i in cartStore.cartList&quot; :key=&quot;i.id&quot;&gt;<br>                            &lt;td&gt;<br>                                &lt;el-checkbox :model-value=&quot;i.selected&quot; @change=&quot;(selected) =&gt; singleCheck(i, selected)&quot; /&gt;<br>                            &lt;/td&gt;<br>                            &lt;td&gt;<br>                                &lt;div class=&quot;goods&quot;&gt;<br>                                    &lt;RouterLink to=&quot;/&quot;&gt;&lt;img :src=&quot;i.picture&quot; alt=&quot;&quot; /&gt;&lt;/RouterLink&gt;<br>                                    &lt;div&gt;<br>                                        &lt;p class=&quot;name ellipsis&quot;&gt;<br>                                            &#123;&#123; i.name &#125;&#125;<br>                                        &lt;/p&gt;<br>                                    &lt;/div&gt;<br>                                &lt;/div&gt;<br>                            &lt;/td&gt;<br>                            &lt;td class=&quot;tc&quot;&gt;<br>                                &lt;p&gt;&amp;yen;&#123;&#123; i.price &#125;&#125;&lt;/p&gt;<br>                            &lt;/td&gt;<br>                            &lt;td class=&quot;tc&quot;&gt;<br>                                &lt;el-input-number :min=&#x27;1&#x27; v-model=&quot;i.count&quot; /&gt;<br>                            &lt;/td&gt;<br>                            &lt;td class=&quot;tc&quot;&gt;<br>                                &lt;p class=&quot;f16 red&quot;&gt;&amp;yen;&#123;&#123; (i.price * i.count).toFixed(2) &#125;&#125;&lt;/p&gt;<br>                            &lt;/td&gt;<br>                            &lt;td class=&quot;tc&quot;&gt;<br>                                &lt;p&gt;<br>                                    &lt;el-popconfirm title=&quot;确认删除吗?&quot; confirm-button-text=&quot;确认&quot; cancel-button-text=&quot;取消&quot; @confirm=&quot;cartStore.delCart(i.skuId)&quot;&gt;<br>                                        &lt;template #reference&gt;<br>                                            &lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt;<br>                                        &lt;/template&gt;<br>                                    &lt;/el-popconfirm&gt;<br>                                &lt;/p&gt;<br>                            &lt;/td&gt;<br>                        &lt;/tr&gt;<br>                        &lt;tr v-if=&quot;cartStore.cartList.length === 0&quot;&gt;<br>                            &lt;td colspan=&quot;6&quot;&gt;<br>                                &lt;div class=&quot;cart-none&quot;&gt;<br>                                    &lt;el-empty description=&quot;购物车列表为空&quot;&gt;<br>                                        &lt;el-button type=&quot;primary&quot; @click=&quot;$router.push(&#x27;/&#x27;)&quot;&gt;随便逛逛&lt;/el-button&gt;<br>                                    &lt;/el-empty&gt;<br>                                &lt;/div&gt;<br>                            &lt;/td&gt;<br>                        &lt;/tr&gt;<br>                    &lt;/tbody&gt;<br><br>                &lt;/table&gt;<br>            &lt;/div&gt;<br>            &lt;!-- 操作栏 --&gt;<br>            &lt;div class=&quot;action&quot;&gt;<br>                &lt;div class=&quot;batch&quot;&gt;<br>                    共 &#123;&#123; cartStore.totalCount &#125;&#125; 件商品，已选择 &#123;&#123; cartStore.checkedCount &#125;&#125; 件，商品合计：<br>                    &lt;span class=&quot;red&quot;&gt;¥ &#123;&#123; cartStore.finalPrice.toFixed(2) &#125;&#125; &lt;/span&gt;<br>                &lt;/div&gt;<br>                &lt;div class=&quot;total&quot;&gt;<br>                    &lt;el-button size=&quot;large&quot; type=&quot;primary&quot; @click=&quot;orderPayFn&quot;&gt;下单结算&lt;/el-button&gt;<br>                &lt;/div&gt;<br>            &lt;/div&gt;<br>        &lt;/div&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h4 id="单选框功能"><a href="#单选框功能" class="headerlink" title="单选框功能"></a>单选框功能</h4><p><strong>单选框功能实现</strong>：</p><p>单选框el-checkbox的model-value属性绑定每种商品的selected属性；singleCheck是每种商品前面的单选框的change事件的方法。点击单选框改变选中状态并存到pinia中。</p><p><strong>实现方法</strong>：</p><ul><li>当点击checkbox时传递当前行商品的数据对象和checkbox的选中状态selected（true&#x2F;false）</li><li>调用pinia中singleCheck方法，找到cartList中商品skuId等于传进来的商品数据对象的skuId相等的商品数据对象的selected属性赋予传进来的selected单选框状态</li></ul><h4 id="全选框功能"><a href="#全选框功能" class="headerlink" title="全选框功能"></a>全选框功能</h4><p><strong>全选框功能实现</strong>：</p><ul><li>所有单选框都选中时，全选框才选中，有一个单选框未选中时全选框就不选中</li><li>当点击全选框时，所有单选框都跟着改变</li></ul><p><strong>实现方法</strong>：</p><ul><li>定义getters：totalChecked，使用every方法当cartList中所有商品的selected属性都为true时返回true，否则返回false</li><li>全选框的model-value绑定getters：totalChecked，totalCheck是全选框的change事件的方法</li><li>当点击全选框时totalCheck方法内遍历cartList数组，将每种商品的selected属性赋值传进来的selected属性</li></ul><h4 id="勾选商品总数量-勾选商品总价"><a href="#勾选商品总数量-勾选商品总价" class="headerlink" title="勾选商品总数量&#x2F;勾选商品总价"></a>勾选商品总数量&#x2F;勾选商品总价</h4><p>定义计算属性checkedCount和finalPrice计算勾选商品总数量和勾选商品总价</p><ul><li>使用filter过滤除了cartList数组中商品selected为true的商品再使用reduce求勾选商品总数量checkedCount</li><li>使用filter过滤除了cartList数组中商品selected为true的商品再使用reduce求勾选商品总价finalPrice（selected为true的商品单价乘商品数量）</li></ul><h4 id="获取最新购物车"><a href="#获取最新购物车" class="headerlink" title="获取最新购物车"></a>获取最新购物车</h4><p>在pinia中定义getCart方法，当用户登录时，会将通过调用接口返回的购物车数据覆盖本地购物车数据。</p><h4 id="添加购物车"><a href="#添加购物车" class="headerlink" title="添加购物车"></a><strong>添加购物车</strong></h4><ul><li>用户已登录时，会调用接口，将商品的skuId和商品数量发送给后台，然后重新获取最新的购物车列表</li><li>用户未登录时，使用find方法查找cartList中是否有传进来的商品（根据skuId）<ul><li>如果没有，将商品数据对象push进cartList中</li><li>如果有，就将对应商品的数量count加上传进来的商品数量</li></ul></li></ul><h4 id="删除购物车"><a href="#删除购物车" class="headerlink" title="删除购物车"></a><strong>删除购物车</strong></h4><ul><li>用户已登录时，会调用接口，将商品的skuId（以数组形式）发送给后台，然后重新获取最新的购物车列表</li><li>用户未登录时，使用filter方法将传进来的商品（根据skuId）从cartList过滤出去</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// stores/cart.js</span><br><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><span class="hljs-keyword">import</span> &#123; ref, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; useUserStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user&#x27;</span><br><span class="hljs-keyword">import</span> &#123; addCartAPI, delCartAPI, getCartAPI &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/apis&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCartStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;cart&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUserStore</span>()<br>    <span class="hljs-keyword">const</span> isLogin = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> userStore.<span class="hljs-property">userInfo</span>.<span class="hljs-property">token</span>)<br>    <span class="hljs-comment">// state</span><br>    <span class="hljs-comment">// 购物车数组</span><br>    <span class="hljs-keyword">const</span> cartList = <span class="hljs-title function_">ref</span>([])<br>    <span class="hljs-comment">// actions</span><br>    <span class="hljs-comment">// 获取最新购物车</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">getCart</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getCartAPI</span>()<br>        cartList.<span class="hljs-property">value</span> = res.<span class="hljs-property">result</span><br>    &#125;<br>    <span class="hljs-comment">// 添加购物车</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">addCart</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">goods</span>) =&gt; &#123;<br>        <span class="hljs-comment">// 购物车中已有商品，count+1</span><br>        <span class="hljs-comment">// 没有添加过，直接push</span><br>        <span class="hljs-keyword">if</span> (isLogin.<span class="hljs-property">value</span>) &#123;<br>            <span class="hljs-keyword">await</span> <span class="hljs-title function_">addCartAPI</span>(&#123;<br>                <span class="hljs-attr">skuId</span>: goods.<span class="hljs-property">skuId</span>,<br>                <span class="hljs-attr">count</span>: goods.<span class="hljs-property">count</span><br>            &#125;)<br>            <span class="hljs-title function_">getCart</span>()<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">const</span> item = cartList.<span class="hljs-property">value</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> goods.<span class="hljs-property">skuId</span> === item.<span class="hljs-property">skuId</span>)<br>            <span class="hljs-keyword">if</span> (item) &#123;<br>                item.<span class="hljs-property">count</span> += goods.<span class="hljs-property">count</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cartList.<span class="hljs-property">value</span>.<span class="hljs-title function_">push</span>(goods)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 单选</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">singleCheck</span> = (<span class="hljs-params">id, selected</span>) =&gt; &#123;<br>        cartList.<span class="hljs-property">value</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> id === item.<span class="hljs-property">skuId</span>).<span class="hljs-property">selected</span> = selected<br>    &#125;<br>    <span class="hljs-comment">// 全选</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">totalCheck</span> = (<span class="hljs-params">value</span>) =&gt; &#123;<br>        cartList.<span class="hljs-property">value</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.<span class="hljs-property">selected</span> = value)<br>    &#125;<br>    <span class="hljs-comment">// 删除购物车</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">delCart</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">id</span>) =&gt; &#123;<br>        <span class="hljs-keyword">if</span> (isLogin.<span class="hljs-property">value</span>) &#123;<br>            <span class="hljs-keyword">await</span> <span class="hljs-title function_">delCartAPI</span>([id])<br>            <span class="hljs-title function_">getCart</span>()<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 1.找到要删除项的下标值-splice</span><br>            <span class="hljs-comment">// const idx = cartList.value.findIndex((item) =&gt; id === item.skuId)</span><br>            <span class="hljs-comment">// cartList.value.splice(idx,1)</span><br>            <span class="hljs-comment">// 2.使用数组的过滤方法-filter</span><br>            cartList.<span class="hljs-property">value</span> = cartList.<span class="hljs-property">value</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> id !== item.<span class="hljs-property">skuId</span>)<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-comment">// 清空购物车</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">clearCart</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        cartList.<span class="hljs-property">value</span> = []<br>    &#125;<br>    <span class="hljs-comment">// getters</span><br>    <span class="hljs-comment">// 商品总数</span><br>    <span class="hljs-keyword">const</span> totalCount = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> cartList.<span class="hljs-property">value</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">count, item</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> count += item.<span class="hljs-property">count</span><br>        &#125;, <span class="hljs-number">0</span>)<br>    &#125;)<br>    <span class="hljs-comment">// 选中商品数量</span><br>    <span class="hljs-keyword">const</span> checkedCount = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> cartList.<span class="hljs-property">value</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.<span class="hljs-property">selected</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">count, item</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> count += item.<span class="hljs-property">count</span><br>        &#125;, <span class="hljs-number">0</span>)<br>    &#125;)<br>    <span class="hljs-comment">// 总价</span><br>    <span class="hljs-keyword">const</span> totalPrice = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> cartList.<span class="hljs-property">value</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">price, item</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> price += item.<span class="hljs-property">price</span> * <span class="hljs-number">1000</span> * item.<span class="hljs-property">count</span> / <span class="hljs-number">1000</span><br>        &#125;, <span class="hljs-number">0</span>)<br>    &#125;)<br>    <span class="hljs-comment">// 结算价格</span><br>    <span class="hljs-keyword">const</span> finalPrice = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> cartList.<span class="hljs-property">value</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.<span class="hljs-property">selected</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">price, item</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> price += item.<span class="hljs-property">price</span> * <span class="hljs-number">1000</span> * item.<span class="hljs-property">count</span> / <span class="hljs-number">1000</span><br>        &#125;, <span class="hljs-number">0</span>)<br>    &#125;)<br>    <span class="hljs-comment">// 是否全选</span><br>    <span class="hljs-keyword">const</span> totalChecked = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> cartList.<span class="hljs-property">value</span>.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.<span class="hljs-property">selected</span>)<br>    &#125;)<br><br>    <span class="hljs-keyword">return</span> &#123;<br>        isLogin, cartList, addCart, delCart, getCart, singleCheck, totalCheck, clearCart, totalCount, totalPrice, finalPrice, totalChecked, checkedCount<br>    &#125;<br>&#125;,<br>    &#123; <span class="hljs-attr">persist</span>: <span class="hljs-literal">true</span> &#125;<br>)<br></code></pre></td></tr></table></figure><h4 id="合并购物车"><a href="#合并购物车" class="headerlink" title="合并购物车"></a><strong>合并购物车</strong></h4><p>登录时会将本地购物车的数据调用接口合并到登录时的购物车中</p><p>退出登录时，除了清空用户的数据信息，还要清空pinia中的购物车数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><span class="hljs-keyword">import</span> &#123; loginAPI,mergeCartAPI &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/apis&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; useCartStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./cart&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useUserStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> userInfo = <span class="hljs-title function_">ref</span>(&#123;&#125;)<br>    <span class="hljs-keyword">const</span> cartStore=<span class="hljs-title function_">useCartStore</span>()<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">getUserInfo</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">&#123; account, password &#125;</span>) =&gt; &#123;<br>        <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">loginAPI</span>(&#123; account, password &#125;)<br>        userInfo.<span class="hljs-property">value</span> = res.<span class="hljs-property">result</span><br>        <span class="hljs-keyword">await</span> <span class="hljs-title function_">mergeCartAPI</span>(cartStore.<span class="hljs-property">cartList</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-attr">skuId</span>: item.<span class="hljs-property">skuId</span>,<br>                <span class="hljs-attr">selected</span>: item.<span class="hljs-property">selected</span>,<br>                <span class="hljs-attr">count</span>: item.<span class="hljs-property">count</span><br>            &#125;<br>         &#125;))<br>        cartStore.<span class="hljs-title function_">getCart</span>()<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">clearUserInfo</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        userInfo.<span class="hljs-property">value</span> = &#123;&#125;<br>        cartStore.<span class="hljs-title function_">clearCart</span>()<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123; userInfo, getUserInfo,clearUserInfo &#125;<br>&#125;,<br>    &#123; <span class="hljs-attr">persist</span>: <span class="hljs-literal">true</span> &#125;<br>)<br></code></pre></td></tr></table></figure><p><strong>小技巧</strong>：当需要传递数组，内容是一个对象中的某几个属性时，使用map方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">cartStore.<span class="hljs-property">cartList</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-attr">skuId</span>: item.<span class="hljs-property">skuId</span>,<br>                <span class="hljs-attr">selected</span>: item.<span class="hljs-property">selected</span>,<br>                <span class="hljs-attr">count</span>: item.<span class="hljs-property">count</span><br>            &#125;<br>         &#125;)<br></code></pre></td></tr></table></figure><h3 id="结算模块"><a href="#结算模块" class="headerlink" title="结算模块"></a>结算模块</h3><h4 id="地址渲染"><a href="#地址渲染" class="headerlink" title="地址渲染"></a>地址渲染</h4><p><strong>默认地址渲染</strong>：通过查看生成订单接口返回的数据中包含一个地址数组，中有一个isDefault属性，当isDefault为0时是默认地址</p><p><strong>切换地址按钮功能需求</strong>：</p><ul><li>打开弹框交互：点击切换地址，打开弹窗，回显用户可选地址列表<ul><li>弹框显示隐藏关联showDialog，当showDialog为true时显示弹框，为false时隐藏</li></ul></li><li>切换地址交互：点击某个地址会有高亮（额外样式），点击确认按钮会激活地址替换默认地址<ul><li>绑定点击事件的switchAddress方法，当点击某个地址时，将这个地址对象赋值给activeAddress激活地址。使用动态class，当当前地址的id和激活地址的id相等时，给这个地址添加激活样式active</li><li>点击确认时会将激活地址赋值给curAddress当前页面渲染的地址，然后将弹框关闭，激活地址置空</li></ul></li></ul><h4 id="提交订单"><a href="#提交订单" class="headerlink" title="提交订单"></a>提交订单</h4><p>调用接口方法，传递订单信息，然后携带orderId进行路由跳转</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; getCheckInfoAPI, createOrderAPI &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/apis&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; onMounted, ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; useRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; useCartStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/stores&#x27;</span>;<br><span class="hljs-keyword">const</span> cartStore = <span class="hljs-title function_">useCartStore</span>()<br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()<br><span class="hljs-keyword">const</span> checkInfo = <span class="hljs-title function_">ref</span>(&#123;&#125;); <span class="hljs-comment">// 订单对象</span><br><span class="hljs-keyword">const</span> curAddress = <span class="hljs-title function_">ref</span>(&#123;&#125;);<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getCheckInfo</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getCheckInfoAPI</span>();<br>    checkInfo.<span class="hljs-property">value</span> = res.<span class="hljs-property">result</span>;<br>    curAddress.<span class="hljs-property">value</span> = checkInfo.<span class="hljs-property">value</span>.<span class="hljs-property">userAddresses</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">isDefault</span> === <span class="hljs-number">0</span>);<br>&#125;;<br><span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">getCheckInfo</span>();<br>&#125;);<br><span class="hljs-keyword">const</span> showDialog = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">const</span> activeAddress = <span class="hljs-title function_">ref</span>(&#123;&#125;);<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">switchAddress</span> = item =&gt; &#123;<br>    activeAddress.<span class="hljs-property">value</span> = item;<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">confirmAddress</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    curAddress.<span class="hljs-property">value</span> = activeAddress.<span class="hljs-property">value</span>;<br>    showDialog.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>;<br>    activeAddress.<span class="hljs-property">value</span> = &#123;&#125;;<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">generateOrder</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">createOrderAPI</span>(&#123;<br>        <span class="hljs-attr">deliveryTimeType</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">payType</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">payChannel</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">buyerMessage</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">goods</span>: checkInfo.<span class="hljs-property">value</span>.<span class="hljs-property">goods</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-attr">skuId</span>: item.<span class="hljs-property">skuId</span>,<br>                <span class="hljs-attr">count</span>: item.<span class="hljs-property">count</span><br>            &#125;<br>        &#125;),<br>        <span class="hljs-attr">addressId</span>: curAddress.<span class="hljs-property">value</span>.<span class="hljs-property">id</span><br>    &#125;);<br>    <span class="hljs-keyword">const</span> orderId = res.<span class="hljs-property">result</span>.<span class="hljs-property">id</span><br>    router.<span class="hljs-title function_">push</span>(&#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/pay&#x27;</span>,<br>        <span class="hljs-attr">query</span>: &#123;<br>            <span class="hljs-attr">id</span>: orderId<br>        &#125;<br>    &#125;)<br>    cartStore.<span class="hljs-title function_">getCart</span>()<br>&#125;;<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xtx-pay-checkout-page&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-comment">&lt;!-- 收货地址 --&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box-title&quot;</span>&gt;</span>收货地址<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box-body&quot;</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;address&quot;</span>&gt;</span></span><br><span class="language-xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span></span><br><span class="language-xml">                            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;none&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!curAddress&quot;</span>&gt;</span>您需要先添加收货地址才可提交订单。<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                            <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">v-else</span>&gt;</span></span><br><span class="language-xml">                                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                                    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>收<span class="hljs-tag">&lt;<span class="hljs-name">i</span> /&gt;</span>货<span class="hljs-tag">&lt;<span class="hljs-name">i</span> /&gt;</span>人：<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>&#123;&#123; curAddress.receiver &#125;&#125;                               <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                                    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>联系方式：<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                                    &#123;&#123; curAddress.contact &#125;&#125;</span><br><span class="language-xml">                                <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                                    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>收货地址：<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                                    &#123;&#123; curAddress.fullLocation &#125;&#125; &#123;&#123; curAddress.address &#125;&#125;</span><br><span class="language-xml">                                <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">                        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;action&quot;</span>&gt;</span></span><br><span class="language-xml">                            <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;large&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showDialog = true&quot;</span>&gt;</span>切换地址<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">                            <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;large&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addFlag = true&quot;</span>&gt;</span>添加地址<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">                        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-comment">&lt;!-- 商品信息 --&gt;</span></span><br><span class="language-xml">                ......</span><br><span class="language-xml">                <span class="hljs-comment">&lt;!-- 配送时间 --&gt;</span></span><br><span class="language-xml">                ......</span><br><span class="language-xml">                <span class="hljs-comment">&lt;!-- 支付方式 --&gt;</span></span><br><span class="language-xml">                ......</span><br><span class="language-xml">                <span class="hljs-comment">&lt;!-- 金额明细 --&gt;</span></span><br><span class="language-xml">                ......</span><br><span class="language-xml">                <span class="hljs-comment">&lt;!-- 提交订单 --&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;large&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;generateOrder&quot;</span>&gt;</span>提交订单<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 切换地址 --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-dialog</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;showDialog&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;切换收货地址&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;30%&quot;</span> <span class="hljs-attr">center</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;addressWrapper&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text item&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123; active: item.id === activeAddress.id &#125;&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;switchAddress(item)&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in checkInfo.userAddresses&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>收<span class="hljs-tag">&lt;<span class="hljs-name">i</span> /&gt;</span>货<span class="hljs-tag">&lt;<span class="hljs-name">i</span> /&gt;</span>人：<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                        &#123;&#123; item.receiver &#125;&#125;</span><br><span class="language-xml">                    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>联系方式：<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                        &#123;&#123; item.contact &#125;&#125;</span><br><span class="language-xml">                    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>收货地址：<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                        &#123;&#123; item.fullLocation + item.address &#125;&#125;</span><br><span class="language-xml">                    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">footer</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dialog-footer&quot;</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showDialog = false&quot;</span>&gt;</span>取消<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;confirmAddress&quot;</span>&gt;</span>确定<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">el-dialog</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.text</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">90px</span>;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">display</span>: flex;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">align-items</span>: center;</span></span><br><span class="language-css"><span class="language-xml"></span></span><br><span class="language-css"><span class="language-xml">    &amp;<span class="hljs-selector-class">.item</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#f5f5f5</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">10px</span>;</span></span><br><span class="language-css"><span class="language-xml">        <span class="hljs-attribute">cursor</span>: pointer;</span></span><br><span class="language-css"><span class="language-xml"></span></span><br><span class="language-css"><span class="language-xml">        &amp;<span class="hljs-selector-class">.active</span>,</span></span><br><span class="language-css"><span class="language-xml">        &amp;<span class="hljs-selector-pseudo">:hover</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">            <span class="hljs-attribute">border-color</span>: $xtxColor;</span></span><br><span class="language-css"><span class="language-xml">            <span class="hljs-attribute">background</span>: <span class="hljs-built_in">lighten</span>($xtxColor, <span class="hljs-number">50%</span>);</span></span><br><span class="language-css"><span class="language-xml">        &#125;</span></span><br><span class="language-css"><span class="language-xml"></span></span><br><span class="language-css"><span class="language-xml">        &gt;<span class="hljs-selector-tag">ul</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;</span></span><br><span class="language-css"><span class="language-xml">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;</span></span><br><span class="language-css"><span class="language-xml">            <span class="hljs-attribute">line-height</span>: <span class="hljs-number">30px</span>;</span></span><br><span class="language-css"><span class="language-xml">        &#125;</span></span><br><span class="language-css"><span class="language-xml">    &#125;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="支付模块"><a href="#支付模块" class="headerlink" title="支付模块"></a>支付模块</h3><h4 id="倒计时函数封装"><a href="#倒计时函数封装" class="headerlink" title="倒计时函数封装"></a>倒计时函数封装</h4><p>导入dayjs库，定义格式化后的时间formatTime和倒计时函数start，return出来在页面中使用</p><ul><li>倒计时函数start，传入currentTime，开启定时器，每隔一秒time.value–，在组件销毁onUnMounted阶段清除定时器</li><li>格式化后的时间formatTime定义为计算属性，调用dayjs.unix方法格式化为’mm分ss秒’。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// composables/useCountDown.js</span><br><span class="hljs-comment">// 封装倒计时逻辑函数</span><br><span class="hljs-keyword">import</span> dayjs <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;dayjs&quot;</span><br><span class="hljs-keyword">import</span> &#123; computed, onUnmounted, ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useCountDown</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// 格式化时间 xx分xx秒</span><br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>    <span class="hljs-comment">// 1.响应式数据</span><br>    <span class="hljs-keyword">const</span> time = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">const</span> formatTime = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> dayjs.<span class="hljs-title function_">unix</span>(time.<span class="hljs-property">value</span>).<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;mm分ss秒&#x27;</span>))<br>    <span class="hljs-comment">// 2.开启倒计时的函数</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">start</span> = (<span class="hljs-params">currentTime</span>) =&gt; &#123;<br>        time.<span class="hljs-property">value</span> = currentTime<br>        timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            time.<span class="hljs-property">value</span>--<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;<br>    <span class="hljs-comment">// 组件销毁时清除定时器</span><br>    <span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        timer &amp;&amp; <span class="hljs-built_in">clearInterval</span>(timer)<br>    &#125;)<br>    <span class="hljs-keyword">return</span> &#123;<br>        formatTime,<br>        start<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在页面中导入并调用useCountDown方法并进行解构赋值，拿到start方法和formatTime变量，获取到支付信息时，在返回的数据中有countdown属性，调用方法start(countdown)，然后在页面中直接使用formatTime</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; getOrderAPI &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/apis&#x27;</span><br><span class="hljs-keyword">import</span> &#123; ref, onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; useRoute &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; useCountDown &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/composables/useCountDown&#x27;</span><br><span class="hljs-keyword">const</span> &#123; formatTime, start &#125; = <span class="hljs-title function_">useCountDown</span>()<br><span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()<br><span class="hljs-keyword">const</span> payInfo = <span class="hljs-title function_">ref</span>(&#123;&#125;)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getPayInfo</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getOrderAPI</span>(route.<span class="hljs-property">query</span>.<span class="hljs-property">id</span>)<br>    payInfo.<span class="hljs-property">value</span> = res.<span class="hljs-property">result</span><br>    <span class="hljs-title function_">start</span>(res.<span class="hljs-property">result</span>.<span class="hljs-property">countdown</span>)<br>&#125;<br><span class="hljs-title function_">onMounted</span>(<span class="hljs-title function_">async</span> () =&gt; &#123;<br>    <span class="hljs-title function_">getPayInfo</span>()<br>&#125;)<br><span class="hljs-comment">// 跳转支付</span><br><span class="hljs-comment">// 支付地址</span><br><span class="hljs-keyword">const</span> baseURL = <span class="hljs-string">&#x27;http://pcapi-xiaotuxian-front-devtest.itheima.net/&#x27;</span><br><span class="hljs-keyword">const</span> backURL = <span class="hljs-string">&#x27;http://localhost:5173/paycallback&#x27;</span><br><span class="hljs-keyword">const</span> redirectUrl = <span class="hljs-built_in">encodeURIComponent</span>(backURL)<br><span class="hljs-keyword">const</span> payUrl = <span class="hljs-string">`<span class="hljs-subst">$&#123;baseURL&#125;</span>pay/aliPay?orderId=<span class="hljs-subst">$&#123;route.query.id&#125;</span>&amp;redirect=<span class="hljs-subst">$&#123;redirectUrl&#125;</span>`</span><br>&lt;/script&gt;<br><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xtx-pay-page&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!-- 付款信息 --&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pay-info&quot;</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon iconfont icon-queren2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tip&quot;</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>订单提交成功！请尽快完成支付。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>支付还剩 <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; formatTime &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>, 超时后将取消订单<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;amount&quot;</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>应付总额：<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>¥&#123;&#123; payInfo.payMoney?.toFixed(2) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!-- 付款方式 --&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pay-type&quot;</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;head&quot;</span>&gt;</span>选择以下支付方式付款<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>支付平台<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn wx&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn alipay&quot;</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;payUrl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>支付方式<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span>招商银行<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span>工商银行<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span>建设银行<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span>农业银行<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span>交通银行<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="会员中心模块"><a href="#会员中心模块" class="headerlink" title="会员中心模块"></a>会员中心模块</h3><p>包括个人中心和我的订单，使用的是三级路由，为了一进来就加载个人中心页面，三级路由的oath设置为空</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">BASE_URL</span>),<br>  <span class="hljs-attr">routes</span>: [<br>  &#123;<br>      <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Layout&#x27;</span>,<br>      <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/Layout/index.vue&#x27;</span>),<br>      <span class="hljs-attr">children</span>: [<br>        &#123;<br>          <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;member&#x27;</span>,<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Member&#x27;</span>,<br>          <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/Member/index.vue&#x27;</span>),<br>          <span class="hljs-attr">children</span>: [<br>            &#123;<br>              <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>              <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;UserInfo&#x27;</span>,<br>              <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/Member/Components/UserInfo.vue&#x27;</span>),<br>            &#125;,<br>            &#123;<br>              <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;order&#x27;</span>,<br>              <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;UserOrder&#x27;</span>,<br>              <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/Member/Components/UserOrder.vue&#x27;</span>),<br>            &#125;,<br>          ]<br>        &#125;,<br>      ]<br>    &#125;,<br>    <span class="hljs-title function_">scrollBehavior</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">top</span>: <span class="hljs-number">0</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="个人中心"><a href="#个人中心" class="headerlink" title="个人中心"></a>个人中心</h4><ul><li>直接从pinia中拿用户的信息渲染到页面上</li><li>猜你喜欢：调用接口获取喜欢列表数据，渲染到页面上</li></ul><h4 id="我的订单模块"><a href="#我的订单模块" class="headerlink" title="我的订单模块"></a>我的订单模块</h4><p><strong>分页功能</strong></p><p>使用elementPlus的分页组件el-pagination，page-size属性绑定调用获取订单列表接口时传递参数对象params的pageSize每页条数属性，page-sizes属性是可选的pageSize数组，total属性是调用获取订单列表接口返回的订单总数totalCount，size-change和current-change事件分别为每页条数和当前页码改变时触发的事件，后面跟方法。当每页条数和当前页码改变时传递新的pageSize和page，赋值给params，然后调用获取订单列表接口方法重新获取订单列表数据。</p><p><strong>tab栏切换</strong></p><p>点击tab栏时，会触发el-tabs组件的tab-change事件，执行对应的事件方法，传递的值是订单状态orderState，然后重新获取订单列表数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; getOrderListAPI &#125; from &#x27;@/apis&#x27;;<br>import &#123; ref, onMounted &#125; from &#x27;vue&#x27;;<br>import OrderItem from &#x27;./OrderItem.vue&#x27;<br>// tab列表<br>const tabTypes = [<br>    &#123; name: &quot;all&quot;, label: &quot;全部订单&quot; &#125;,<br>    &#123; name: &quot;unpay&quot;, label: &quot;待付款&quot; &#125;,<br>    &#123; name: &quot;deliver&quot;, label: &quot;待发货&quot; &#125;,<br>    &#123; name: &quot;receive&quot;, label: &quot;待收货&quot; &#125;,<br>    &#123; name: &quot;comment&quot;, label: &quot;待评价&quot; &#125;,<br>    &#123; name: &quot;complete&quot;, label: &quot;已完成&quot; &#125;,<br>    &#123; name: &quot;cancel&quot;, label: &quot;已取消&quot; &#125;<br>]<br>// 订单列表<br>const orderList = ref([])<br>const totalCount = ref(0)<br>const params = ref(&#123;<br>    page: 1,<br>    pageSize: 2,<br>    orderState: 0<br>&#125;)<br>const getOrderList = async () =&gt; &#123;<br>    const res = await getOrderListAPI(params.value)<br>    orderList.value = res.result<br>    totalCount.value = res.result.counts<br>&#125;<br>onMounted(() =&gt; &#123;<br>    getOrderList()<br>&#125;)<br>const tabChange = (type) =&gt; &#123;<br>    params.value.orderState = type<br>    getOrderList()<br>&#125;<br>const handleSizeChange = (pageSize) =&gt; &#123;<br>    params.value.pageSize = pageSize<br>    getOrderList()<br>&#125;<br>const handleCurrentChange = (page) =&gt; &#123;<br>    params.value.page = page<br>    getOrderList()<br>&#125;<br>&lt;/script&gt;<br>&lt;template&gt;<br>    &lt;div class=&quot;order-container&quot;&gt;<br>        &lt;el-tabs @tab-change=&quot;tabChange&quot;&gt;<br>            &lt;!-- tab切换 --&gt;<br>            &lt;el-tab-pane v-for=&quot;item in tabTypes&quot; :key=&quot;item.name&quot; :label=&quot;item.label&quot; /&gt;<br>            &lt;div class=&quot;main-container&quot;&gt;<br>                &lt;div class=&quot;holder-container&quot; v-if=&quot;orderList.length === 0&quot;&gt;<br>                    &lt;el-empty description=&quot;暂无订单数据&quot; /&gt;<br>                &lt;/div&gt;<br>                &lt;div v-else&gt;<br>                    &lt;!-- 订单列表 --&gt;<br>                    &lt;div class=&quot;order-item&quot; v-for=&quot;order in orderList.items&quot; :key=&quot;order.id&quot;&gt;<br>                        &lt;OrderItem :order=&quot;order&quot;&gt;&lt;/OrderItem&gt;                        <br>                    &lt;/div&gt;<br>                    &lt;!-- 分页 --&gt;<br>                    &lt;div class=&quot;pagination-container&quot;&gt;<br>                        &lt;el-pagination :page-size=&quot;params.pageSize&quot; :page-sizes=&quot;[2, 5, 10, 20]&quot; small           layout=&quot;sizes, prev, pager, next&quot; :total=&quot;totalCount&quot; background @size-change=&quot;handleSizeChange&quot;<br>                            @current-change=&quot;handleCurrentChange&quot; /&gt;<br>                    &lt;/div&gt;<br>                &lt;/div&gt;<br>            &lt;/div&gt;<br><br>        &lt;/el-tabs&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>封装每个订单项的orderItem组件，将orderList订单列表中的每一项传值给orderItem进行数据渲染。</p><p><strong>倒计时</strong>：</p><p>导入封装的倒计时函数在组件挂载onMounted后进行调用，传进去的是每个订单order中的countdown</p><p><strong>订单状态</strong>：</p><p>默认渲染出来的是数字，想要显示对应的订单状态，定义formatPayState方法，定义数字和订单状态映射关系的stateMap对象，<code>return stateMap[payState]</code>，然后在页面中使用formatPayState方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; onMounted &#125; from &#x27;vue&#x27;<br>import &#123; useCountDown &#125; from &#x27;@/composables/useCountDown&#x27;;<br><br>const props = defineProps(&#123;<br>    order: &#123;<br>        type: Object,<br>        default: () =&gt; (&#123;&#125;)<br>    &#125;<br>&#125;)<br>const &#123; formatTime, start &#125; = useCountDown()<br>onMounted(() =&gt; &#123;<br>    start(props.order.countdown)<br>&#125;)<br>const formatPayState = (payState) =&gt; &#123;<br>    const stateMap = &#123;<br>        1: &#x27;待付款&#x27;,<br>        2: &#x27;待发货&#x27;,<br>        3: &#x27;待收货&#x27;,<br>        4: &#x27;待评价&#x27;,<br>        5: &#x27;已完成&#x27;,<br>        6: &#x27;已取消&#x27;,<br>    &#125;<br>    return stateMap[payState]<br>&#125;<br>&lt;/script&gt;<br>&lt;template&gt;<br>    &lt;div class=&quot;head&quot;&gt;<br>        &lt;span&gt;下单时间：&#123;&#123; order.createTime &#125;&#125;&lt;/span&gt;<br>        &lt;span&gt;订单编号：&#123;&#123; order.id &#125;&#125;&lt;/span&gt;<br>        &lt;!-- 未付款，倒计时时间还有 --&gt;<br>        &lt;span class=&quot;down-time&quot; v-if=&quot;order.orderState === 1&quot;&gt;<br>            &lt;i class=&quot;iconfont icon-down-time&quot;&gt;&lt;/i&gt;<br>            &lt;b&gt;付款截止: &#123;&#123; formatTime &#125;&#125;&lt;/b&gt;<br>        &lt;/span&gt;<br>    &lt;/div&gt;<br>    &lt;div class=&quot;body&quot;&gt;<br>        &lt;div class=&quot;column goods&quot;&gt;<br>......<br>        &lt;/div&gt;<br>        &lt;div class=&quot;column state&quot;&gt;<br>            &lt;p&gt;&#123;&#123; formatPayState(order.orderState) &#125;&#125;&lt;/p&gt;<br>            &lt;p v-if=&quot;order.orderState === 3&quot;&gt;<br>                &lt;a href=&quot;javascript:;&quot; class=&quot;green&quot;&gt;查看物流&lt;/a&gt;<br>            &lt;/p&gt;<br>            &lt;p v-if=&quot;order.orderState === 4&quot;&gt;<br>                &lt;a href=&quot;javascript:;&quot; class=&quot;green&quot;&gt;评价商品&lt;/a&gt;<br>            &lt;/p&gt;<br>            &lt;p v-if=&quot;order.orderState === 5&quot;&gt;<br>                &lt;a href=&quot;javascript:;&quot; class=&quot;green&quot;&gt;查看评价&lt;/a&gt;<br>            &lt;/p&gt;<br>        &lt;/div&gt;<br>......<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;style  scoped lang=&quot;scss&quot;&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
